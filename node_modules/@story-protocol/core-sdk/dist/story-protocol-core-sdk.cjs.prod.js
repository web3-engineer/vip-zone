'use strict';

var dotenv = require('dotenv');
var viem = require('viem');
var utils = require('viem/utils');
var bs58 = require('bs58');
var base58 = require('multiformats/bases/base58');
var cid = require('multiformats/cid');
var accounts = require('viem/accounts');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var dotenv__namespace = /*#__PURE__*/_interopNamespace(dotenv);
var bs58__default = /*#__PURE__*/_interopDefault(bs58);

function _regeneratorDefine(e, r, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e) {
    i = 0;
  }
  _regeneratorDefine = function (e, r, n, t) {
    function o(r, n) {
      _regeneratorDefine(e, r, function (e) {
        return this._invoke(r, n, e);
      });
    }
    r ? i ? i(e, r, {
      value: n,
      enumerable: !t,
      configurable: !t,
      writable: !t
    }) : e[r] = n : (o("next", 0), o("throw", 1), o("return", 2));
  }, _regeneratorDefine(e, r, n, t);
}

function _regenerator() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  var e,
    t,
    r = "function" == typeof Symbol ? Symbol : {},
    n = r.iterator || "@@iterator",
    o = r.toStringTag || "@@toStringTag";
  function i(r, n, o, i) {
    var c = n && n.prototype instanceof Generator ? n : Generator,
      u = Object.create(c.prototype);
    return _regeneratorDefine(u, "_invoke", function (r, n, o) {
      var i,
        c,
        u,
        f = 0,
        p = o || [],
        y = false,
        G = {
          p: 0,
          n: 0,
          v: e,
          a: d,
          f: d.bind(e, 4),
          d: function (t, r) {
            return i = t, c = 0, u = e, G.n = r, a;
          }
        };
      function d(r, n) {
        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {
          var o,
            i = p[t],
            d = G.p,
            l = i[2];
          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));
        }
        if (o || r > 1) return a;
        throw y = true, n;
      }
      return function (o, p, l) {
        if (f > 1) throw TypeError("Generator is already running");
        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {
          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);
          try {
            if (f = 2, i) {
              if (c || (o = "next"), t = i[o]) {
                if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u = t.value, c < 2 && (c = 0);
              } else 1 === c && (t = i.return) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1);
              i = e;
            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;
          } catch (t) {
            i = e, c = 1, u = t;
          } finally {
            f = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r, o, i), true), u;
  }
  var a = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  t = Object.getPrototypeOf;
  var c = [][n] ? t(t([][n]())) : (_regeneratorDefine(t = {}, n, function () {
      return this;
    }), t),
    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);
  function f(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine(u), _regeneratorDefine(u, o, "Generator"), _regeneratorDefine(u, n, function () {
    return this;
  }), _regeneratorDefine(u, "toString", function () {
    return "[object Generator]";
  }), (_regenerator = function () {
    return {
      w: i,
      m: f
    };
  })();
}

function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c),
      u = i.value;
  } catch (n) {
    return void e(n);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function () {
    var t = this,
      e = arguments;
    return new Promise(function (r, o) {
      var a = n.apply(t, e);
      function _next(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
      }
      function _throw(n) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
      }
      _next(void 0);
    });
  };
}

function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (String )(t);
}

function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {
      t && (r = t);
      var n = 0,
        F = function () {};
      return {
        s: F,
        n: function () {
          return n >= r.length ? {
            done: true
          } : {
            done: false,
            value: r[n++]
          };
        },
        e: function (r) {
          throw r;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o,
    a = true,
    u = false;
  return {
    s: function () {
      t = t.call(r);
    },
    n: function () {
      var r = t.next();
      return a = r.done, r;
    },
    e: function (r) {
      u = true, o = r;
    },
    f: function () {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u) throw o;
      }
    }
  };
}

function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = true,
      o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = true, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}

function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}

function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}

// AccessController
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a)
 */var accessControllerAbi=[{type:"constructor",inputs:[{name:"ipAccountRegistry",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"}],name:"AccessController__BothCallerAndRecipientAreNotRegisteredModule"},{type:"error",inputs:[],name:"AccessController__CallerIsNotIPAccountOrOwner"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessController__IPAccountIsNotValid"},{type:"error",inputs:[],name:"AccessController__IPAccountIsZeroAddress"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"}],name:"AccessController__OwnerIsIPAccount"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"AccessController__PermissionDenied"},{type:"error",inputs:[],name:"AccessController__PermissionIsNotValid"},{type:"error",inputs:[],name:"AccessController__SignerIsZeroAddress"},{type:"error",inputs:[],name:"AccessController__ToAndFuncAreZeroAddressShouldCallSetAllPermissions"},{type:"error",inputs:[],name:"AccessController__ZeroAccessManager"},{type:"error",inputs:[],name:"AccessController__ZeroIPAccountRegistry"},{type:"error",inputs:[],name:"AccessController__ZeroModuleRegistry"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"ipAccountOwner",internalType:"address",type:"address",indexed:false},{name:"ipAccount",internalType:"address",type:"address",indexed:true},{name:"signer",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"func",internalType:"bytes4",type:"bytes4",indexed:false},{name:"permission",internalType:"uint8",type:"uint8",indexed:false}],name:"PermissionSet"},{type:"event",anonymous:false,inputs:[{name:"ipAccountOwner",internalType:"address",type:"address",indexed:false},{name:"ipAccount",internalType:"address",type:"address",indexed:true},{name:"signer",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"func",internalType:"bytes4",type:"bytes4",indexed:false},{name:"permission",internalType:"uint8",type:"uint8",indexed:false}],name:"TransientPermissionSet"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"contract IModuleRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"checkPermission",outputs:[],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"getPermanentPermission",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"getPermission",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"}],name:"getTransientPermission",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setAllPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setAllTransientPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"permissions",internalType:"struct AccessPermission.Permission[]",type:"tuple[]",components:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}]}],name:"setBatchPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"permissions",internalType:"struct AccessPermission.Permission[]",type:"tuple[]",components:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}]}],name:"setBatchTransientPermissions",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setPermission",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipAccount",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"func",internalType:"bytes4",type:"bytes4"},{name:"permission",internalType:"uint8",type:"uint8"}],name:"setTransientPermission",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a)
 */var accessControllerAddress={1315:"0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a",1514:"0xcCF37d0a503Ee1D4C11208672e622ed3DFB2275a"};// ArbitrationPolicyUMA
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936)
 */var arbitrationPolicyUmaAbi=[{type:"constructor",inputs:[{name:"disputeModule",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__BondAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__CannotCancel"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__CannotDisputeAssertionIfTagIsInherited"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__CurrencyNotWhitelisted"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__DisputeNotFound"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__IpOwnerTimePercentAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__LivenessAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__LivenessBelowMin"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__MaxBondBelowMinimumBond"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__MinLivenessAboveMax"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__NoCounterEvidence"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__NotDisputeModule"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__NotOOV3"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__OnlyDisputePolicyUMA"},{type:"error",inputs:[{name:"elapsedTime",internalType:"uint64",type:"uint64"},{name:"liveness",internalType:"uint64",type:"uint64"},{name:"caller",internalType:"address",type:"address"}],name:"ArbitrationPolicyUMA__OnlyTargetIpIdCanDisputeWithinTimeWindow"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroAccessManager"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroDisputeModule"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroMaxLiveness"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroMinLiveness"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroOOV3"},{type:"error",inputs:[],name:"ArbitrationPolicyUMA__ZeroRoyaltyModule"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"assertionId",internalType:"bytes32",type:"bytes32",indexed:false},{name:"counterEvidenceHash",internalType:"bytes32",type:"bytes32",indexed:false}],name:"AssertionDisputed"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"assertionId",internalType:"bytes32",type:"bytes32",indexed:false},{name:"caller",internalType:"address",type:"address",indexed:false},{name:"liveness",internalType:"uint64",type:"uint64",indexed:false},{name:"currency",internalType:"address",type:"address",indexed:false},{name:"bond",internalType:"uint256",type:"uint256",indexed:false}],name:"DisputeRaisedUMA"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"minLiveness",internalType:"uint64",type:"uint64",indexed:false},{name:"maxLiveness",internalType:"uint64",type:"uint64",indexed:false},{name:"ipOwnerTimePercent",internalType:"uint32",type:"uint32",indexed:false}],name:"LivenessSet"},{type:"event",anonymous:false,inputs:[{name:"token",internalType:"address",type:"address",indexed:false},{name:"maxBond",internalType:"uint256",type:"uint256",indexed:false}],name:"MaxBondSet"},{type:"event",anonymous:false,inputs:[{name:"oov3",internalType:"address",type:"address",indexed:false}],name:"OOV3Set"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"}],name:"assertionDisputedCallback",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"}],name:"assertionIdToDisputeId",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"},{name:"assertedTruthfully",internalType:"bool",type:"bool"}],name:"assertionResolvedCallback",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"assertionId",internalType:"bytes32",type:"bytes32"},{name:"counterEvidenceHash",internalType:"bytes32",type:"bytes32"}],name:"disputeAssertion",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"}],name:"disputeIdToAssertionId",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"ipOwnerTimePercent",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"}],name:"ipOwnerTimePercents",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"maxBonds",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxLiveness",outputs:[{name:"",internalType:"uint64",type:"uint64"}],stateMutability:"view"},{type:"function",inputs:[],name:"minLiveness",outputs:[{name:"",internalType:"uint64",type:"uint64"}],stateMutability:"view"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onDisputeCancel",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"decision",internalType:"bool",type:"bool"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onDisputeJudgement",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"targetIpId",internalType:"address",type:"address"},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32"},{name:"targetTag",internalType:"bytes32",type:"bytes32"},{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onRaiseDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"onResolveDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"oov3",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"minLiveness",internalType:"uint64",type:"uint64"},{name:"maxLiveness",internalType:"uint64",type:"uint64"},{name:"ipOwnerTimePercent",internalType:"uint32",type:"uint32"}],name:"setLiveness",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"},{name:"maxBond",internalType:"uint256",type:"uint256"}],name:"setMaxBond",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"oov3",internalType:"address",type:"address"}],name:"setOOV3",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936)
 */var arbitrationPolicyUmaAddress={1315:"0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936",1514:"0xfFD98c3877B8789124f02C7E8239A4b0Ef11E936"};// CoreMetadataModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16)
 */var coreMetadataModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAccountRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[],name:"CoreMetadataModule__MetadataAlreadyFrozen"},{type:"error",inputs:[],name:"CoreMetadataModule__ZeroAccessManager"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true}],name:"MetadataFrozen"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"metadataURI",internalType:"string",type:"string",indexed:false},{name:"metadataHash",internalType:"bytes32",type:"bytes32",indexed:false}],name:"MetadataURISet"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"nftTokenURI",internalType:"string",type:"string",indexed:false},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32",indexed:false}],name:"NFTTokenURISet"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"freezeMetadata",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"isMetadataFrozen",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"metadataURI",internalType:"string",type:"string"},{name:"metadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"setAll",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"metadataURI",internalType:"string",type:"string"},{name:"metadataHash",internalType:"bytes32",type:"bytes32"}],name:"setMetadataURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"updateNftTokenURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16)
 */var coreMetadataModuleAddress={1315:"0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16",1514:"0x6E81a25C99C6e8430aeC7353325EB138aFE5DC16"};// DerivativeWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x9e2d496f72C547C2C535B167e06ED8729B374a4f)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x9e2d496f72C547C2C535B167e06ED8729B374a4f)
 */var derivativeWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"caller",internalType:"address",type:"address"},{name:"actualTokenOwner",internalType:"address",type:"address"}],name:"DerivativeWorkflows__CallerAndNotTokenOwner"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"DerivativeWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"DerivativeWorkflows__EmptyLicenseTokens"},{type:"error",inputs:[],name:"DerivativeWorkflows__ZeroAddressParam"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"LicensingHelper__ParentIpIdsAndLicenseTermsIdsMismatch"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PermissionHelper__ModulesAndSelectorsMismatch"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_TOKEN",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"recipient",internalType:"address",type:"address"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndMakeDerivative",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"recipient",internalType:"address",type:"address"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivative",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivativeWithLicenseTokens",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x9e2d496f72C547C2C535B167e06ED8729B374a4f)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x9e2d496f72C547C2C535B167e06ED8729B374a4f)
 */var derivativeWorkflowsAddress={1315:"0x9e2d496f72C547C2C535B167e06ED8729B374a4f",1514:"0x9e2d496f72C547C2C535B167e06ED8729B374a4f"};// DisputeModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x9b7A9c70AFF961C799110954fc06F3093aeb94C5)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x9b7A9c70AFF961C799110954fc06F3093aeb94C5)
 */var disputeModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[],name:"DisputeModule__CannotBlacklistBaseArbitrationPolicy"},{type:"error",inputs:[],name:"DisputeModule__DisputeAlreadyPropagated"},{type:"error",inputs:[],name:"DisputeModule__DisputeWithoutInfringementTag"},{type:"error",inputs:[],name:"DisputeModule__EvidenceHashAlreadyUsed"},{type:"error",inputs:[],name:"DisputeModule__NotAbleToResolve"},{type:"error",inputs:[],name:"DisputeModule__NotAllowedToWhitelist"},{type:"error",inputs:[],name:"DisputeModule__NotArbitrationRelayer"},{type:"error",inputs:[],name:"DisputeModule__NotDerivativeOrGroupIp"},{type:"error",inputs:[],name:"DisputeModule__NotDisputeInitiator"},{type:"error",inputs:[],name:"DisputeModule__NotInDisputeState"},{type:"error",inputs:[],name:"DisputeModule__NotRegisteredIpId"},{type:"error",inputs:[],name:"DisputeModule__NotWhitelistedArbitrationPolicy"},{type:"error",inputs:[],name:"DisputeModule__NotWhitelistedDisputeTag"},{type:"error",inputs:[],name:"DisputeModule__RelatedDisputeNotResolved"},{type:"error",inputs:[],name:"DisputeModule__ZeroAccessController"},{type:"error",inputs:[],name:"DisputeModule__ZeroAccessManager"},{type:"error",inputs:[],name:"DisputeModule__ZeroArbitrationPolicy"},{type:"error",inputs:[],name:"DisputeModule__ZeroArbitrationPolicyCooldown"},{type:"error",inputs:[],name:"DisputeModule__ZeroDisputeEvidenceHash"},{type:"error",inputs:[],name:"DisputeModule__ZeroDisputeTag"},{type:"error",inputs:[],name:"DisputeModule__ZeroIPAssetRegistry"},{type:"error",inputs:[],name:"DisputeModule__ZeroIPGraphACL"},{type:"error",inputs:[],name:"DisputeModule__ZeroLicenseRegistry"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"cooldown",internalType:"uint256",type:"uint256",indexed:false}],name:"ArbitrationPolicyCooldownUpdated"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"nextArbitrationUpdateTimestamp",internalType:"uint256",type:"uint256",indexed:false}],name:"ArbitrationPolicySet"},{type:"event",anonymous:false,inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"ArbitrationPolicyWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"arbitrationRelayer",internalType:"address",type:"address",indexed:false}],name:"ArbitrationRelayerUpdated"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false}],name:"DefaultArbitrationPolicyUpdated"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeCancelled"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"decision",internalType:"bool",type:"bool",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeJudgementSet"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"targetIpId",internalType:"address",type:"address",indexed:false},{name:"disputeInitiator",internalType:"address",type:"address",indexed:false},{name:"disputeTimestamp",internalType:"uint256",type:"uint256",indexed:false},{name:"arbitrationPolicy",internalType:"address",type:"address",indexed:false},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32",indexed:false},{name:"targetTag",internalType:"bytes32",type:"bytes32",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeRaised"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false}],name:"DisputeResolved"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"disputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"infringingIpId",internalType:"address",type:"address",indexed:false},{name:"ipIdToTag",internalType:"address",type:"address",indexed:false},{name:"infringerDisputeId",internalType:"uint256",type:"uint256",indexed:false},{name:"tag",internalType:"bytes32",type:"bytes32",indexed:false},{name:"disputeTimestamp",internalType:"uint256",type:"uint256",indexed:false}],name:"IpTaggedOnRelatedIpInfringement"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"tag",internalType:"bytes32",type:"bytes32",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"TagWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IN_DISPUTE",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"arbitrationPolicies",outputs:[{name:"policy",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"arbitrationPolicyCooldown",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],name:"arbitrationRelayer",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"baseArbitrationPolicy",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"cancelDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"disputeCounter",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"}],name:"disputes",outputs:[{name:"targetIpId",internalType:"address",type:"address"},{name:"disputeInitiator",internalType:"address",type:"address"},{name:"disputeTimestamp",internalType:"uint256",type:"uint256"},{name:"arbitrationPolicy",internalType:"address",type:"address"},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32"},{name:"targetTag",internalType:"bytes32",type:"bytes32"},{name:"currentTag",internalType:"bytes32",type:"bytes32"},{name:"infringerDisputeId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"isIpTagged",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],name:"isWhitelistedArbitrationPolicy",outputs:[{name:"allowed",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"tag",internalType:"bytes32",type:"bytes32"}],name:"isWhitelistedDisputeTag",outputs:[{name:"allowed",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"nextArbitrationPolicies",outputs:[{name:"policy",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"nextArbitrationUpdateTimestamps",outputs:[{name:"timestamp",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"targetIpId",internalType:"address",type:"address"},{name:"disputeEvidenceHash",internalType:"bytes32",type:"bytes32"},{name:"targetTag",internalType:"bytes32",type:"bytes32"},{name:"data",internalType:"bytes",type:"bytes"}],name:"raiseDispute",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"resolveDispute",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"nextArbitrationPolicy",internalType:"address",type:"address"}],name:"setArbitrationPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"cooldown",internalType:"uint256",type:"uint256"}],name:"setArbitrationPolicyCooldown",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"},{name:"arbPolicyRelayer",internalType:"address",type:"address"}],name:"setArbitrationRelayer",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],name:"setBaseArbitrationPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"disputeId",internalType:"uint256",type:"uint256"},{name:"decision",internalType:"bool",type:"bool"},{name:"data",internalType:"bytes",type:"bytes"}],name:"setDisputeJudgement",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipIdToTag",internalType:"address",type:"address"},{name:"infringerDisputeId",internalType:"uint256",type:"uint256"}],name:"tagIfRelatedIpInfringed",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"updateActiveArbitrationPolicy",outputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"arbitrationPolicy",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistArbitrationPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"tag",internalType:"bytes32",type:"bytes32"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistDisputeTag",outputs:[],stateMutability:"nonpayable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x9b7A9c70AFF961C799110954fc06F3093aeb94C5)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x9b7A9c70AFF961C799110954fc06F3093aeb94C5)
 */var disputeModuleAddress={1315:"0x9b7A9c70AFF961C799110954fc06F3093aeb94C5",1514:"0x9b7A9c70AFF961C799110954fc06F3093aeb94C5"};// ERC20
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xF2104833d386a2734a4eB3B8ad6FC6812F29E38E)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xF2104833d386a2734a4eB3B8ad6FC6812F29E38E)
 */var erc20Abi=[{type:"constructor",inputs:[],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"allowance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientAllowance"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"balance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientBalance"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC20InvalidApprover"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC20InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC20InvalidSender"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"}],name:"ERC20InvalidSpender"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"spender",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Transfer"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"}],name:"allowance",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"account",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"decimals",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transfer",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xF2104833d386a2734a4eB3B8ad6FC6812F29E38E)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xF2104833d386a2734a4eB3B8ad6FC6812F29E38E)
 */var erc20Address={1315:"0xF2104833d386a2734a4eB3B8ad6FC6812F29E38E",1514:"0xF2104833d386a2734a4eB3B8ad6FC6812F29E38E"};// GroupingModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac)
 */var groupingModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"groupNFT",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"GroupingModule__CannotAddDisputedIpToGroup"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"childGroupId",internalType:"address",type:"address"}],name:"GroupingModule__CannotAddGroupToGroup"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__DisputedGroupCannotAddIp"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__DisputedGroupCannotClaimReward"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__DisputedGroupCannotCollectRoyalties"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupFrozenDueToAlreadyMintLicenseTokens"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupFrozenDueToHasDerivativeIps"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupIPHasNoLicenseTerms"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupingModule__GroupIPLicenseHasNotSpecifyRevenueToken"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"groupRewardPool",internalType:"address",type:"address"}],name:"GroupingModule__GroupRewardPoolNotWhitelisted"},{type:"error",inputs:[{name:"groupNFT",internalType:"address",type:"address"}],name:"GroupingModule__InvalidGroupNFT"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipId",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"expectGroupRewardShare",internalType:"uint256",type:"uint256"}],name:"GroupingModule__IpExpectedShareExceedsMaxAllowedShare"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"}],name:"GroupingModule__MaxAllowedRewardShareExceeds100Percent"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"royaltyToken",internalType:"address",type:"address"}],name:"GroupingModule__RoyaltyTokenNotWhitelisted"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"groupCurrentToken",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"GroupingModule__TokenNotMatchGroupRevenueToken"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"totalGroupRewardShare",internalType:"uint256",type:"uint256"},{name:"ipId",internalType:"address",type:"address"},{name:"expectGroupRewardShare",internalType:"uint256",type:"uint256"}],name:"GroupingModule__TotalGroupRewardShareExceeds100Percent"},{type:"error",inputs:[],name:"GroupingModule__ZeroAccessManager"},{type:"error",inputs:[],name:"GroupingModule__ZeroGroupNFT"},{type:"error",inputs:[],name:"GroupingModule__ZeroGroupRewardPool"},{type:"error",inputs:[],name:"GroupingModule__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"GroupingModule__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"GroupingModule__ZeroLicenseToken"},{type:"error",inputs:[],name:"GroupingModule__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"ipIds",internalType:"address[]",type:"address[]",indexed:false}],name:"AddedIpToGroup"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"token",internalType:"address",type:"address",indexed:true},{name:"ipId",internalType:"address[]",type:"address[]",indexed:false},{name:"amount",internalType:"uint256[]",type:"uint256[]",indexed:false}],name:"ClaimedReward"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"token",internalType:"address",type:"address",indexed:true},{name:"pool",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"CollectedRoyaltiesToGroupPool"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"groupPool",internalType:"address",type:"address",indexed:true}],name:"IPGroupRegistered"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"groupId",internalType:"address",type:"address",indexed:true},{name:"ipIds",internalType:"address[]",type:"address[]",indexed:false}],name:"RemovedIpFromGroup"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_NFT",outputs:[{name:"",internalType:"contract IGroupNFT",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_TOKEN",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"}],name:"addIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"claimReward",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"collectRoyalties",outputs:[{name:"royalties",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"getClaimableReward",outputs:[{name:"",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"}],name:"registerGroup",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"removeIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"rewardPool",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistGroupRewardPool",outputs:[],stateMutability:"nonpayable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac)
 */var groupingModuleAddress={1315:"0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac",1514:"0x69D3a7aa9edb72Bc226E745A7cCdd50D947b69Ac"};// GroupingWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd)
 */var groupingWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"groupingModule",internalType:"address",type:"address"},{name:"groupNft",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"GroupingWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"GroupingWorkflows__NoLicenseData"},{type:"error",inputs:[],name:"GroupingWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PermissionHelper__ModulesAndSelectorsMismatch"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_MODULE",outputs:[{name:"",internalType:"contract IGroupingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_NFT",outputs:[{name:"",internalType:"contract GroupNFT",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract RoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupIpId",internalType:"address",type:"address"},{name:"currencyTokens",internalType:"address[]",type:"address[]"},{name:"memberIpIds",internalType:"address[]",type:"address[]"}],name:"collectRoyaltiesAndClaimReward",outputs:[{name:"collectedRoyalties",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"licensesData",internalType:"struct WorkflowStructs.LicenseData[]",type:"tuple[]",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigAddToGroup",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"},{name:"licenseData",internalType:"struct WorkflowStructs.LicenseData",type:"tuple",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]}],name:"registerGroupAndAttachLicense",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupPool",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"licenseData",internalType:"struct WorkflowStructs.LicenseData",type:"tuple",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]}],name:"registerGroupAndAttachLicenseAndAddIps",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"groupId",internalType:"address",type:"address"},{name:"maxAllowedRewardShare",internalType:"uint256",type:"uint256"},{name:"licensesData",internalType:"struct WorkflowStructs.LicenseData[]",type:"tuple[]",components:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]},{name:"sigAddToGroup",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachLicenseAndAddToGroup",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd)
 */var groupingWorkflowsAddress={1315:"0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd",1514:"0xD7c0beb3aa4DCD4723465f1ecAd045676c24CDCd"};// IPAccountImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x7343646585443F1c3F64E4F08b708788527e1C77)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x7343646585443F1c3F64E4F08b708788527e1C77)
 */var ipAccountImplAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[],name:"FnSelectorNotRecognized"},{type:"error",inputs:[],name:"IPAccountStorage__InvalidBatchLengths"},{type:"error",inputs:[{name:"module",internalType:"address",type:"address"}],name:"IPAccountStorage__NotRegisteredModule"},{type:"error",inputs:[],name:"IPAccountStorage__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"IPAccountStorage__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"IPAccountStorage__ZeroModuleRegistry"},{type:"error",inputs:[],name:"IPAccount__ExpiredSignature"},{type:"error",inputs:[],name:"IPAccount__InvalidCalldata"},{type:"error",inputs:[],name:"IPAccount__InvalidOperation"},{type:"error",inputs:[],name:"IPAccount__InvalidSignature"},{type:"error",inputs:[],name:"IPAccount__InvalidSigner"},{type:"error",inputs:[],name:"IPAccount__UUPSUpgradeDisabled"},{type:"error",inputs:[],name:"IPAccount__ZeroAccessController"},{type:"error",inputs:[],name:"OperationNotSupported"},{type:"error",inputs:[],name:"SelfOwnDetected"},{type:"error",inputs:[],name:"Unauthorized"},{type:"error",inputs:[],name:"UnauthorizedCallContext"},{type:"error",inputs:[],name:"UpgradeFailed"},{type:"event",anonymous:false,inputs:[{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false},{name:"nonce",internalType:"bytes32",type:"bytes32",indexed:false}],name:"Executed"},{type:"event",anonymous:false,inputs:[{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false},{name:"data",internalType:"bytes",type:"bytes",indexed:false},{name:"nonce",internalType:"bytes32",type:"bytes32",indexed:false},{name:"deadline",internalType:"uint256",type:"uint256",indexed:false},{name:"signer",internalType:"address",type:"address",indexed:true},{name:"signature",internalType:"bytes",type:"bytes",indexed:false}],name:"ExecutedWithSig"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"fallback",stateMutability:"payable"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"",internalType:"bytes32",type:"bytes32"},{name:"",internalType:"bytes32",type:"bytes32"}],name:"bytes32Data",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"",internalType:"bytes32",type:"bytes32"},{name:"",internalType:"bytes32",type:"bytes32"}],name:"bytesData",outputs:[{name:"",internalType:"bytes",type:"bytes"}],stateMutability:"view"},{type:"function",inputs:[],name:"eip712Domain",outputs:[{name:"fields",internalType:"bytes1",type:"bytes1"},{name:"name",internalType:"string",type:"string"},{name:"version",internalType:"string",type:"string"},{name:"chainId",internalType:"uint256",type:"uint256"},{name:"verifyingContract",internalType:"address",type:"address"},{name:"salt",internalType:"bytes32",type:"bytes32"},{name:"extensions",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"},{name:"operation",internalType:"uint8",type:"uint8"}],name:"execute",outputs:[{name:"result",internalType:"bytes",type:"bytes"}],stateMutability:"payable"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"execute",outputs:[{name:"result",internalType:"bytes",type:"bytes"}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct ERC6551.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}]},{name:"operation",internalType:"uint8",type:"uint8"}],name:"executeBatch",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"payable"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"},{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}],name:"executeWithSig",outputs:[{name:"result",internalType:"bytes",type:"bytes"}],stateMutability:"payable"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes",outputs:[{name:"",internalType:"bytes",type:"bytes"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespace",internalType:"bytes32",type:"bytes32"},{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes",outputs:[{name:"",internalType:"bytes",type:"bytes"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespace",internalType:"bytes32",type:"bytes32"},{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes32",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"}],name:"getBytes32",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespaces",internalType:"bytes32[]",type:"bytes32[]"},{name:"keys",internalType:"bytes32[]",type:"bytes32[]"}],name:"getBytes32Batch",outputs:[{name:"values",internalType:"bytes32[]",type:"bytes32[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"namespaces",internalType:"bytes32[]",type:"bytes32[]"},{name:"keys",internalType:"bytes32[]",type:"bytes32[]"}],name:"getBytesBatch",outputs:[{name:"values",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"hash",internalType:"bytes32",type:"bytes32"},{name:"signature",internalType:"bytes",type:"bytes"}],name:"isValidSignature",outputs:[{name:"result",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"signer",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"isValidSigner",outputs:[{name:"result",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"signer",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"isValidSigner",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"owner",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"},{name:"value",internalType:"bytes",type:"bytes"}],name:"setBytes",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"key",internalType:"bytes32",type:"bytes32"},{name:"value",internalType:"bytes32",type:"bytes32"}],name:"setBytes32",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"keys",internalType:"bytes32[]",type:"bytes32[]"},{name:"values",internalType:"bytes32[]",type:"bytes32[]"}],name:"setBytes32Batch",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"keys",internalType:"bytes32[]",type:"bytes32[]"},{name:"values",internalType:"bytes[]",type:"bytes[]"}],name:"setBytesBatch",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"state",outputs:[{name:"result",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"token",outputs:[{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"receive",stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x7343646585443F1c3F64E4F08b708788527e1C77)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x7343646585443F1c3F64E4F08b708788527e1C77)
 */var ipAccountImplAddress={1315:"0x7343646585443F1c3F64E4F08b708788527e1C77",1514:"0x7343646585443F1c3F64E4F08b708788527e1C77"};// IPAssetRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x77319B4031e6eF1250907aa00018B8B1c67a244b)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x77319B4031e6eF1250907aa00018B8B1c67a244b)
 */var ipAssetRegistryAbi=[{type:"constructor",inputs:[{name:"erc6551Registry",internalType:"address",type:"address"},{name:"ipAccountImpl",internalType:"address",type:"address"},{name:"groupingModule",internalType:"address",type:"address"},{name:"ipAccountImplBeacon",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__CallerIsNotGroupingModule"},{type:"error",inputs:[{name:"groupPool",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__GroupRewardPoolNotRegistered"},{type:"error",inputs:[{name:"groupSize",internalType:"uint256",type:"uint256"},{name:"limit",internalType:"uint256",type:"uint256"}],name:"GroupIPAssetRegistry__GroupSizeExceedsLimit"},{type:"error",inputs:[{name:"rewardPool",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__InvalidGroupRewardPool"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__NotRegisteredGroupIP"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"GroupIPAssetRegistry__NotRegisteredIP"},{type:"error",inputs:[{name:"pageSize",internalType:"uint256",type:"uint256"},{name:"limit",internalType:"uint256",type:"uint256"}],name:"GroupIPAssetRegistry__PageSizeExceedsLimit"},{type:"error",inputs:[],name:"IPAccountRegistry_ZeroERC6551Registry"},{type:"error",inputs:[],name:"IPAccountRegistry_ZeroIpAccountImpl"},{type:"error",inputs:[],name:"IPAccountRegistry_ZeroIpAccountImplBeacon"},{type:"error",inputs:[{name:"contractAddress",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"IPAssetRegistry__InvalidToken"},{type:"error",inputs:[{name:"contractAddress",internalType:"address",type:"address"}],name:"IPAssetRegistry__UnsupportedIERC721"},{type:"error",inputs:[{name:"contractAddress",internalType:"address",type:"address"}],name:"IPAssetRegistry__UnsupportedIERC721Metadata"},{type:"error",inputs:[],name:"IPAssetRegistry__ZeroAccessManager"},{type:"error",inputs:[{name:"name",internalType:"string",type:"string"}],name:"IPAssetRegistry__ZeroAddress"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[{name:"value",internalType:"uint256",type:"uint256"},{name:"length",internalType:"uint256",type:"uint256"}],name:"StringsInsufficientHexLength"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:true},{name:"implementation",internalType:"address",type:"address",indexed:true},{name:"chainId",internalType:"uint256",type:"uint256",indexed:true},{name:"tokenContract",internalType:"address",type:"address",indexed:false},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"IPAccountRegistered"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"chainId",internalType:"uint256",type:"uint256",indexed:true},{name:"tokenContract",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true},{name:"name",internalType:"string",type:"string",indexed:false},{name:"uri",internalType:"string",type:"string",indexed:false},{name:"registrationDate",internalType:"uint256",type:"uint256",indexed:false}],name:"IPRegistered"},{type:"event",anonymous:false,inputs:[{name:"payer",internalType:"address",type:"address",indexed:true},{name:"treasury",internalType:"address",type:"address",indexed:true},{name:"feeToken",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint96",type:"uint96",indexed:false}],name:"IPRegistrationFeePaid"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"treasury",internalType:"address",type:"address",indexed:true},{name:"feeToken",internalType:"address",type:"address",indexed:true},{name:"feeAmount",internalType:"uint96",type:"uint96",indexed:false}],name:"RegistrationFeeSet"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ERC6551_PUBLIC_REGISTRY",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_MODULE",outputs:[{name:"",internalType:"contract IGroupingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ACCOUNT_IMPL",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ACCOUNT_IMPL_UPGRADEABLE_BEACON",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ACCOUNT_SALT",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_GROUP_SIZE",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"addGroupMember",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipId",internalType:"address",type:"address"}],name:"containsIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"getFeeAmount",outputs:[{name:"",internalType:"uint96",type:"uint96"}],stateMutability:"view"},{type:"function",inputs:[],name:"getFeeToken",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"startIndex",internalType:"uint256",type:"uint256"},{name:"size",internalType:"uint256",type:"uint256"}],name:"getGroupMembers",outputs:[{name:"results",internalType:"address[]",type:"address[]"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"getGroupRewardPool",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"getIPAccountImpl",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"getTreasury",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"chainId",internalType:"uint256",type:"uint256"},{name:"tokenContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ipAccount",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"chainId",internalType:"uint256",type:"uint256"},{name:"tokenContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ipId",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"id",internalType:"address",type:"address"}],name:"isRegistered",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"isRegisteredGroup",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"rewardPool",internalType:"address",type:"address"}],name:"isWhitelistedGroupRewardPool",outputs:[{name:"isWhitelisted",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"chainid",internalType:"uint256",type:"uint256"},{name:"tokenContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"register",outputs:[{name:"id",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupNft",internalType:"address",type:"address"},{name:"groupNftId",internalType:"uint256",type:"uint256"},{name:"rewardPool",internalType:"address",type:"address"},{name:"registerFeePayer",internalType:"address",type:"address"}],name:"registerGroup",outputs:[{name:"groupId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipIds",internalType:"address[]",type:"address[]"}],name:"removeGroupMember",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"treasury",internalType:"address",type:"address"},{name:"feeToken",internalType:"address",type:"address"},{name:"feeAmount",internalType:"uint96",type:"uint96"}],name:"setRegistrationFee",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"totalMembers",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newIpAccountImpl",internalType:"address",type:"address"}],name:"upgradeIPAccountImpl",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"rewardPool",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistGroupRewardPool",outputs:[],stateMutability:"nonpayable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x77319B4031e6eF1250907aa00018B8B1c67a244b)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x77319B4031e6eF1250907aa00018B8B1c67a244b)
 */var ipAssetRegistryAddress={1315:"0x77319B4031e6eF1250907aa00018B8B1c67a244b",1514:"0x77319B4031e6eF1250907aa00018B8B1c67a244b"};// IpRoyaltyVaultImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x73e2D097F71e5103824abB6562362106A8955AEc)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x63cC7611316880213f3A4Ba9bD72b0EaA2010298)
 */var ipRoyaltyVaultImplAbi=[{type:"constructor",inputs:[{name:"disputeModule",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"groupingModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"allowance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientAllowance"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"balance",internalType:"uint256",type:"uint256"},{name:"needed",internalType:"uint256",type:"uint256"}],name:"ERC20InsufficientBalance"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC20InvalidApprover"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC20InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC20InvalidSender"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"}],name:"ERC20InvalidSpender"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"IpRoyaltyVault__EnforcedPause"},{type:"error",inputs:[],name:"IpRoyaltyVault__GroupPoolMustClaimViaGroupingModule"},{type:"error",inputs:[{name:"vault",internalType:"address",type:"address"},{name:"account",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"IpRoyaltyVault__InsufficientBalance"},{type:"error",inputs:[],name:"IpRoyaltyVault__InvalidTargetIpId"},{type:"error",inputs:[],name:"IpRoyaltyVault__NegativeValueUnsafeCastingToUint256"},{type:"error",inputs:[],name:"IpRoyaltyVault__NoClaimableTokens"},{type:"error",inputs:[],name:"IpRoyaltyVault__NotAllowedToAddTokenToVault"},{type:"error",inputs:[],name:"IpRoyaltyVault__NotWhitelistedRoyaltyToken"},{type:"error",inputs:[{name:"vault",internalType:"address",type:"address"},{name:"from",internalType:"address",type:"address"}],name:"IpRoyaltyVault__SameFromToAddress"},{type:"error",inputs:[],name:"IpRoyaltyVault__VaultDoesNotBelongToAnAncestor"},{type:"error",inputs:[],name:"IpRoyaltyVault__VaultsMustClaimAsSelf"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroAmount"},{type:"error",inputs:[{name:"vault",internalType:"address",type:"address"},{name:"account",internalType:"address",type:"address"}],name:"IpRoyaltyVault__ZeroBalance"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroDisputeModule"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroGroupingModule"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"IpRoyaltyVault__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"spender",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"claimer",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"revenueDebt",internalType:"int256",type:"int256",indexed:false}],name:"RevenueDebtUpdated"},{type:"event",anonymous:false,inputs:[{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"RevenueTokenAddedToVault"},{type:"event",anonymous:false,inputs:[{name:"claimer",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"RevenueTokenClaimed"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"value",internalType:"uint256",type:"uint256",indexed:false}],name:"Transfer"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_MODULE",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"}],name:"allowance",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"account",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenList",internalType:"address[]",type:"address[]"},{name:"targetIpId",internalType:"address",type:"address"}],name:"claimByTokenBatchAsSelf",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"claimRevenueOnBehalf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"tokenList",internalType:"address[]",type:"address[]"}],name:"claimRevenueOnBehalfByTokenBatch",outputs:[{name:"",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"claimableRevenue",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"claimer",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"claimerRevenueDebt",outputs:[{name:"",internalType:"int256",type:"int256"}],stateMutability:"view"},{type:"function",inputs:[],name:"decimals",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"pure"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"symbol",internalType:"string",type:"string"},{name:"supply",internalType:"uint32",type:"uint32"},{name:"ipIdAddress",internalType:"address",type:"address"},{name:"rtReceiver",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"ipId",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"tokens",outputs:[{name:"",internalType:"address[]",type:"address[]"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transfer",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"updateVaultBalance",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"vaultAccBalances",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x73e2D097F71e5103824abB6562362106A8955AEc)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x63cC7611316880213f3A4Ba9bD72b0EaA2010298)
 */var ipRoyaltyVaultImplAddress={1315:"0x73e2D097F71e5103824abB6562362106A8955AEc",1514:"0x63cC7611316880213f3A4Ba9bD72b0EaA2010298"};// LicenseAttachmentWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8)
 */var licenseAttachmentWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"LicenseAttachmentWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"LicenseAttachmentWorkflows__NoLicenseTermsData"},{type:"error",inputs:[],name:"LicenseAttachmentWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PermissionHelper__ModulesAndSelectorsMismatch"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachDefaultTerms",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachPILTerms",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadataAndDefaultTerms",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachDefaultTerms",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachPILTerms",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"sigAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerPILTermsAndAttach",outputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8)
 */var licenseAttachmentWorkflowsAddress={1315:"0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8",1514:"0xcC2E862bCee5B6036Db0de6E06Ae87e524a79fd8"};// LicenseRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x529a750E02d8E2f15649c13D69a465286a780e24)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x529a750E02d8E2f15649c13D69a465286a780e24)
 */var licenseRegistryAbi=[{type:"constructor",inputs:[{name:"groupIpAssetRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"}],name:"LicenseRegistry__AddParentIpToIPGraphFailed"},{type:"error",inputs:[],name:"LicenseRegistry__CallFailed"},{type:"error",inputs:[],name:"LicenseRegistry__CallerNotLicensingModule"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__CannotAddIpWithExpirationToGroup"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeAlreadyRegistered"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeIpAlreadyHasChild"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeIpAlreadyHasLicense"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__DerivativeIsParent"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__DuplicateParentIp"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__EmptyGroupCannotMintLicenseToken"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__GroupCannotHasParentIp"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__GroupIpAlreadyHasLicenseTerms"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"ipCommercialRevShare",internalType:"uint32",type:"uint32"},{name:"groupCommercialRevShare",internalType:"uint32",type:"uint32"}],name:"LicenseRegistry__GroupIpCommercialRevShareConfigMustNotLessThanIp"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__GroupMustBeSoleParent"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"},{name:"length",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IndexOutOfBounds"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"expectGroupRewardPool",internalType:"address",type:"address"},{name:"groupId",internalType:"address",type:"address"},{name:"groupRewardPool",internalType:"address",type:"address"}],name:"LicenseRegistry__IpExpectGroupRewardPoolNotMatch"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__IpExpectGroupRewardPoolNotSet"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__IpExpired"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IpHasNoGroupLicenseTerms"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IpLicenseDisabled"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"groupHookData",internalType:"bytes",type:"bytes"}],name:"LicenseRegistry__IpLicensingHookDataNotMatchWithGroup"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licensingHook",internalType:"address",type:"address"},{name:"groupLicensingHook",internalType:"address",type:"address"}],name:"LicenseRegistry__IpLicensingHookNotMatchWithGroup"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"groupMintingFee",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__IpMintingFeeNotMatchWithGroup"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicenseTermsAlreadyAttached"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicenseTermsCannotAttachToGroupIp"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicenseTermsNotExists"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__LicensorIpHasNoLicenseTerms"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__NotLicenseTemplate"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpExpired"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__ParentIpHasNoLicenseTerms"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpIsEmptyGroup"},{type:"error",inputs:[{name:"parentIpId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpNotRegistered"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpTagged"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__ParentIpUnmatchedLicenseTemplate"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestors",internalType:"uint256",type:"uint256"},{name:"maxAncestors",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__TooManyAncestors"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parents",internalType:"uint256",type:"uint256"},{name:"maxParents",internalType:"uint256",type:"uint256"}],name:"LicenseRegistry__TooManyParents"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"newLicenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__UnmatchedLicenseTemplate"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__UnregisteredLicenseTemplate"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroAccessManager"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroDisputeModule"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroGroupIpRegistry"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroIPGraphACL"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroLicenseTemplate"},{type:"error",inputs:[],name:"LicenseRegistry__ZeroLicensingModule"},{type:"error",inputs:[],name:"LicensingModule__DerivativesCannotAddLicenseTerms"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicenseTermsNotFound"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"RoyaltyModule__CallFailed"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"licenseTemplate",internalType:"address",type:"address",indexed:false},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:false}],name:"DefaultLicenseTermsSet"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"expireTime",internalType:"uint256",type:"uint256",indexed:false}],name:"ExpirationTimeSet"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"licenseTemplate",internalType:"address",type:"address",indexed:true}],name:"LicenseTemplateRegistered"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:true},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}],indexed:false}],name:"LicensingConfigSetForLicense"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"EXPIRATION_TIME",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUP_IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_ANCESTORS",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_PARENTS",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"attachLicenseTermsToIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"exists",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getAncestorsCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"getAttachedLicenseTerms",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getAttachedLicenseTermsCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getDefaultLicenseTerms",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"getDerivativeIp",outputs:[{name:"childIpId",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"}],name:"getDerivativeIpCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getExpireTime",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getLicensingConfig",outputs:[{name:"",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"getParentIp",outputs:[{name:"parentIpId",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"getParentIpCount",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"}],name:"getParentLicenseTerms",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getRoyaltyPercent",outputs:[{name:"royaltyPercent",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"}],name:"hasDerivativeIps",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"hasIpAttachedLicenseTerms",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"}],name:"initializeLicenseTemplate",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"isDefaultLicense",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"isDerivativeIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"isExpiredNow",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"childIpId",internalType:"address",type:"address"}],name:"isParentIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"isRegisteredLicenseTemplate",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"isUsingLicenseToken",internalType:"bool",type:"bool"}],name:"registerDerivativeIp",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"registerLicenseTemplate",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newLicenseTemplate",internalType:"address",type:"address"},{name:"newLicenseTermsId",internalType:"uint256",type:"uint256"}],name:"setDefaultLicenseTerms",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],name:"setLicensingConfigForLicense",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"groupRewardPool",internalType:"address",type:"address"},{name:"ipId",internalType:"address",type:"address"},{name:"groupLicenseTemplate",internalType:"address",type:"address"},{name:"groupLicenseTermsId",internalType:"uint256",type:"uint256"}],name:"verifyGroupAddIp",outputs:[{name:"ipLicensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"isMintedByIpOwner",internalType:"bool",type:"bool"}],name:"verifyMintLicenseToken",outputs:[{name:"",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],stateMutability:"view"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x529a750E02d8E2f15649c13D69a465286a780e24)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x529a750E02d8E2f15649c13D69a465286a780e24)
 */var licenseRegistryAddress={1315:"0x529a750E02d8E2f15649c13D69a465286a780e24",1514:"0x529a750E02d8E2f15649c13D69a465286a780e24"};// LicenseToken
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC)
 */var licenseTokenAbi=[{type:"constructor",inputs:[{name:"licensingModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"ERC721EnumerableForbiddenBatchMint"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"owner",internalType:"address",type:"address"}],name:"ERC721IncorrectOwner"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721InsufficientApproval"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC721InvalidApprover"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"}],name:"ERC721InvalidOperator"},{type:"error",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"ERC721InvalidOwner"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC721InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC721InvalidSender"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721NonexistentToken"},{type:"error",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"ERC721OutOfBoundsIndex"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"anotherLicenseTemplate",internalType:"address",type:"address"}],name:"LicenseToken__AllLicenseTokensMustFromSameLicenseTemplate"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"caller",internalType:"address",type:"address"},{name:"childIpIp",internalType:"address",type:"address"},{name:"actualTokenOwner",internalType:"address",type:"address"}],name:"LicenseToken__CallerAndChildIPNotTokenOwner"},{type:"error",inputs:[],name:"LicenseToken__CallerNotLicensingModule"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicenseToken__ChildIPAlreadyHasBeenMintedLicenseTokens"},{type:"error",inputs:[{name:"commercialRevenueShare",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"},{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseToken__CommercialRevenueShareExceedMaxRevenueShare"},{type:"error",inputs:[{name:"invalidRoyaltyPercent",internalType:"uint32",type:"uint32"},{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicenseToken__InvalidRoyaltyPercent"},{type:"error",inputs:[],name:"LicenseToken__NotTransferable"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"LicenseToken__RevokedLicense"},{type:"error",inputs:[],name:"LicenseToken__ZeroAccessManager"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"value",internalType:"uint256",type:"uint256"},{name:"length",internalType:"uint256",type:"uint256"}],name:"StringsInsufficientHexLength"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"operator",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"bool",type:"bool",indexed:false}],name:"ApprovalForAll"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"_fromTokenId",internalType:"uint256",type:"uint256",indexed:false},{name:"_toTokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"BatchMetadataUpdate"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"minter",internalType:"address",type:"address",indexed:true},{name:"receiver",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"LicenseTokenMinted"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Transfer"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_COMMERCIAL_REVENUE_SHARE",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"holder",internalType:"address",type:"address"},{name:"tokenIds",internalType:"uint256[]",type:"uint256[]"}],name:"burnLicenseTokens",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getApproved",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicenseTemplate",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicenseTermsId",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicenseTokenMetadata",outputs:[{name:"",internalType:"struct ILicenseToken.LicenseTokenMetadata",type:"tuple",components:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"transferable",internalType:"bool",type:"bool"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getLicensorIpId",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"}],name:"getTotalTokensByLicensor",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"},{name:"imageUrl",internalType:"string",type:"string"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"operator",internalType:"address",type:"address"}],name:"isApprovedForAll",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"isLicenseTokenRevoked",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"minter",internalType:"address",type:"address"},{name:"receiver",internalType:"address",type:"address"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"mintLicenseTokens",outputs:[{name:"startLicenseTokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ownerOf",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"approved",internalType:"bool",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"url",internalType:"string",type:"string"}],name:"setLicensingImageUrl",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"index",internalType:"uint256",type:"uint256"}],name:"tokenByIndex",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"index",internalType:"uint256",type:"uint256"}],name:"tokenOfOwnerByIndex",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"id",internalType:"uint256",type:"uint256"}],name:"tokenURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalMintedTokens",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"childIpId",internalType:"address",type:"address"},{name:"tokenIds",internalType:"uint256[]",type:"uint256[]"}],name:"validateLicenseTokensForDerivative",outputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licensorIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"commercialRevShares",internalType:"uint32[]",type:"uint32[]"}],stateMutability:"view"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC)
 */var licenseTokenAddress={1315:"0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC",1514:"0xFe3838BFb30B34170F00030B52eA4893d8aAC6bC"};// LicensingModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f)
 */var licensingModuleAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAccountRegistry",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"LicenseRegistry__LicenseTemplateCannotBeZeroAddress"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"}],name:"LicenseRegistry__UnregisteredLicenseTemplate"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"newRoyaltyPercent",internalType:"uint32",type:"uint32"}],name:"LicensingModule__CurrentLicenseNotAllowOverrideRoyaltyPercent"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicensingModule__DerivativeAlreadyHasBeenMintedLicenseTokens"},{type:"error",inputs:[],name:"LicensingModule__DisputedIpId"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"revenueShare",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"LicensingModule__ExceedMaxRevenueShare"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeHookData"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeIsSet"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeLicensingHook"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotChangeMintingFee"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"newRoyaltyPercent",internalType:"uint32",type:"uint32"},{name:"oldRoyaltyPercent",internalType:"uint32",type:"uint32"}],name:"LicensingModule__GroupIpCannotDecreaseRoyalty"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"}],name:"LicensingModule__GroupIpCannotSetExpectGroupRewardPool"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicensingModule__InvalidLicenseTermsId"},{type:"error",inputs:[{name:"hook",internalType:"address",type:"address"}],name:"LicensingModule__InvalidLicensingHook"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensorIpId",internalType:"address",type:"address"}],name:"LicensingModule__LicenseDenyMintLicenseToken"},{type:"error",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicenseDisabled"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"}],name:"LicensingModule__LicenseNotCompatibleForDerivative"},{type:"error",inputs:[{name:"ipLength",internalType:"uint256",type:"uint256"},{name:"licenseTermsLength",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicenseTermsLengthMismatch"},{type:"error",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"}],name:"LicensingModule__LicenseTokenNotCompatibleForDerivative"},{type:"error",inputs:[{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfigMintingFee",internalType:"uint256",type:"uint256"},{name:"licenseTermsMintingFee",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicensingConfigMintingFeeBelowLicenseTerms"},{type:"error",inputs:[{name:"licensingHookMintingFee",internalType:"uint256",type:"uint256"},{name:"licenseTermsMintingFee",internalType:"uint256",type:"uint256"}],name:"LicensingModule__LicensingHookMintingFeeBelowLicenseTerms"},{type:"error",inputs:[],name:"LicensingModule__LicensorIpNotRegistered"},{type:"error",inputs:[],name:"LicensingModule__MintAmountZero"},{type:"error",inputs:[{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"}],name:"LicensingModule__MintingFeeExceedMaxMintingFee"},{type:"error",inputs:[],name:"LicensingModule__MintingFeeRequiresRoyaltyPolicy"},{type:"error",inputs:[],name:"LicensingModule__NoLicenseToken"},{type:"error",inputs:[],name:"LicensingModule__NoParentIp"},{type:"error",inputs:[],name:"LicensingModule__ReceiverZeroAddress"},{type:"error",inputs:[{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"anotherRoyaltyPolicy",internalType:"address",type:"address"}],name:"LicensingModule__RoyaltyPolicyMismatch"},{type:"error",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"ancestors",internalType:"uint256",type:"uint256"},{name:"maxAncestors",internalType:"uint256",type:"uint256"}],name:"LicensingModule__TooManyAncestorsForMintingLicenseTokenAllowRegisterDerivative"},{type:"error",inputs:[],name:"LicensingModule__ZeroAccessManager"},{type:"error",inputs:[],name:"LicensingModule__ZeroDisputeModule"},{type:"error",inputs:[],name:"LicensingModule__ZeroIPGraphACL"},{type:"error",inputs:[],name:"LicensingModule__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"LicensingModule__ZeroLicenseTemplate"},{type:"error",inputs:[],name:"LicensingModule__ZeroLicenseToken"},{type:"error",inputs:[],name:"LicensingModule__ZeroModuleRegistry"},{type:"error",inputs:[],name:"LicensingModule__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"caller",internalType:"address",type:"address",indexed:true},{name:"childIpId",internalType:"address",type:"address",indexed:true},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]",indexed:false},{name:"parentIpIds",internalType:"address[]",type:"address[]",indexed:false},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]",indexed:false},{name:"licenseTemplate",internalType:"address",type:"address",indexed:false}],name:"DerivativeRegistered"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"caller",internalType:"address",type:"address",indexed:true},{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:false},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:false}],name:"LicenseTermsAttached"},{type:"event",anonymous:false,inputs:[{name:"caller",internalType:"address",type:"address",indexed:true},{name:"licensorIpId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:false},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false},{name:"receiver",internalType:"address",type:"address",indexed:false},{name:"startLicenseTokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"LicenseTokensMinted"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_NFT",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"contract IModuleRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract RoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"attachDefaultLicenseTerms",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"attachLicenseTerms",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"receiver",internalType:"address",type:"address"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"mintLicenseTokens",outputs:[{name:"startLicenseTokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"receiver",internalType:"address",type:"address"},{name:"royaltyContext",internalType:"bytes",type:"bytes"}],name:"predictMintingLicenseFee",outputs:[{name:"currencyToken",internalType:"address",type:"address"},{name:"tokenAmount",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}],name:"registerDerivative",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"licenseTokenIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"}],name:"registerDerivativeWithLicenseTokens",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}],name:"setLicensingConfig",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f)
 */var licensingModuleAddress={1315:"0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f",1514:"0x04fbd8a2e56dd85CFD5500A4A4DfA955B9f1dE6f"};// ModuleRegistry
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5)
 */var moduleRegistryAbi=[{type:"constructor",inputs:[],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"ModuleRegistry__InterfaceIdZero"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleAddressNotContract"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleAddressZeroAddress"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleAlreadyRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleNotRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleNotSupportExpectedModuleTypeInterfaceId"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleTypeAlreadyRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleTypeEmptyString"},{type:"error",inputs:[],name:"ModuleRegistry__ModuleTypeNotRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__NameAlreadyRegistered"},{type:"error",inputs:[],name:"ModuleRegistry__NameDoesNotMatch"},{type:"error",inputs:[],name:"ModuleRegistry__NameEmptyString"},{type:"error",inputs:[],name:"ModuleRegistry__ZeroAccessManager"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"name",internalType:"string",type:"string",indexed:false},{name:"module",internalType:"address",type:"address",indexed:true},{name:"moduleTypeInterfaceId",internalType:"bytes4",type:"bytes4",indexed:true},{name:"moduleType",internalType:"string",type:"string",indexed:false}],name:"ModuleAdded"},{type:"event",anonymous:false,inputs:[{name:"name",internalType:"string",type:"string",indexed:false},{name:"module",internalType:"address",type:"address",indexed:true}],name:"ModuleRemoved"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"}],name:"getModule",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"moduleAddress",internalType:"address",type:"address"}],name:"getModuleType",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"moduleType",internalType:"string",type:"string"}],name:"getModuleTypeInterfaceId",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"moduleAddress",internalType:"address",type:"address"}],name:"isRegistered",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"moduleAddress",internalType:"address",type:"address"}],name:"registerModule",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"moduleAddress",internalType:"address",type:"address"},{name:"moduleType",internalType:"string",type:"string"}],name:"registerModule",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"},{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"registerModuleType",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"}],name:"removeModule",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"name",internalType:"string",type:"string"}],name:"removeModuleType",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5)
 */var moduleRegistryAddress={1315:"0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5",1514:"0x022DBAAeA5D8fB31a0Ad793335e39Ced5D631fa5"};// Multicall3
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xca11bde05977b3631167028862be2a173976ca11)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xca11bde05977b3631167028862be2a173976ca11)
 */var multicall3Abi=[{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"aggregate",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"},{name:"returnData",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call3[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"allowFailure",internalType:"bool",type:"bool"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"aggregate3",outputs:[{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call3Value[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"allowFailure",internalType:"bool",type:"bool"},{name:"value",internalType:"uint256",type:"uint256"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"aggregate3Value",outputs:[{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"blockAndAggregate",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"},{name:"blockHash",internalType:"bytes32",type:"bytes32"},{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[],name:"getBasefee",outputs:[{name:"basefee",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"}],name:"getBlockHash",outputs:[{name:"blockHash",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"getBlockNumber",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getChainId",outputs:[{name:"chainid",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockCoinbase",outputs:[{name:"coinbase",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockDifficulty",outputs:[{name:"difficulty",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockGasLimit",outputs:[{name:"gaslimit",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getCurrentBlockTimestamp",outputs:[{name:"timestamp",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"addr",internalType:"address",type:"address"}],name:"getEthBalance",outputs:[{name:"balance",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"getLastBlockHash",outputs:[{name:"blockHash",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"requireSuccess",internalType:"bool",type:"bool"},{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"tryAggregate",outputs:[{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"},{type:"function",inputs:[{name:"requireSuccess",internalType:"bool",type:"bool"},{name:"calls",internalType:"struct Multicall3.Call[]",type:"tuple[]",components:[{name:"target",internalType:"address",type:"address"},{name:"callData",internalType:"bytes",type:"bytes"}]}],name:"tryBlockAndAggregate",outputs:[{name:"blockNumber",internalType:"uint256",type:"uint256"},{name:"blockHash",internalType:"bytes32",type:"bytes32"},{name:"returnData",internalType:"struct Multicall3.Result[]",type:"tuple[]",components:[{name:"success",internalType:"bool",type:"bool"},{name:"returnData",internalType:"bytes",type:"bytes"}]}],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xca11bde05977b3631167028862be2a173976ca11)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xca11bde05977b3631167028862be2a173976ca11)
 */var multicall3Address={1315:"0xcA11bde05977b3631167028862bE2a173976CA11",1514:"0xcA11bde05977b3631167028862bE2a173976CA11"};// PILicenseTemplate
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316)
 */var piLicenseTemplateAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"ipAccountRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"moduleRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddAttribution"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddCommercializers"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddDerivativeRevCeiling"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddRevCeiling"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddRevShare"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialDisabled_CantAddRoyaltyPolicy"},{type:"error",inputs:[],name:"PILicenseTemplate__CommercialEnabled_RoyaltyPolicyRequired"},{type:"error",inputs:[{name:"checker",internalType:"address",type:"address"}],name:"PILicenseTemplate__CommercializerCheckerDoesNotSupportHook"},{type:"error",inputs:[{name:"commercializerChecker",internalType:"address",type:"address"}],name:"PILicenseTemplate__CommercializerCheckerNotRegistered"},{type:"error",inputs:[],name:"PILicenseTemplate__CurrencyTokenNotWhitelisted"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddApproval"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddAttribution"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddDerivativeRevCeiling"},{type:"error",inputs:[],name:"PILicenseTemplate__DerivativesDisabled_CantAddReciprocal"},{type:"error",inputs:[],name:"PILicenseTemplate__MintingFeeRequiresRoyaltyPolicy"},{type:"error",inputs:[],name:"PILicenseTemplate__RoyaltyPolicyNotWhitelisted"},{type:"error",inputs:[],name:"PILicenseTemplate__RoyaltyPolicyRequiresCurrencyToken"},{type:"error",inputs:[],name:"PILicenseTemplate__ZeroAccessManager"},{type:"error",inputs:[],name:"PILicenseTemplate__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"PILicenseTemplate__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"ipId",internalType:"address",type:"address",indexed:true},{name:"caller",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"bool",type:"bool",indexed:false}],name:"DerivativeApproved"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:true},{name:"licenseTerms",internalType:"bytes",type:"bytes",indexed:false}],name:"LicenseTermsRegistered"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MODULE_REGISTRY",outputs:[{name:"",internalType:"contract IModuleRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"TERMS_RENDERER",outputs:[{name:"",internalType:"contract PILTermsRenderer",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"allowDerivativeRegistration",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"canAttachToGroupIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"newRoyaltyPercent",internalType:"uint32",type:"uint32"}],name:"canOverrideRoyaltyPercent",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"exists",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"start",internalType:"uint256",type:"uint256"}],name:"getEarlierExpireTime",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"start",internalType:"uint256",type:"uint256"}],name:"getExpireTime",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"selectedLicenseTermsId",internalType:"uint256",type:"uint256"}],name:"getLicenseTerms",outputs:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],stateMutability:"view"},{type:"function",inputs:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],name:"getLicenseTermsId",outputs:[{name:"selectedLicenseTermsId",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getLicenseTermsURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"getMetadataURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getRoyaltyPolicy",outputs:[{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"royaltyPercent",internalType:"uint32",type:"uint32"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"},{name:"name",internalType:"string",type:"string"},{name:"metadataURI",internalType:"string",type:"string"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"childIpId",internalType:"address",type:"address"}],name:"isDerivativeApproved",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"isLicenseTransferable",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]}],name:"registerLicenseTerms",outputs:[{name:"id",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"childIpId",internalType:"address",type:"address"},{name:"approved",internalType:"bool",type:"bool"}],name:"setApproval",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"toJson",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalRegisteredLicenseTerms",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],name:"verifyCompatibleLicenses",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensee",internalType:"address",type:"address"},{name:"licensorIpId",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"}],name:"verifyMintLicenseToken",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"licensee",internalType:"address",type:"address"}],name:"verifyRegisterDerivative",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"caller",internalType:"address",type:"address"}],name:"verifyRegisterDerivativeForAllParents",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316)
 */var piLicenseTemplateAddress={1315:"0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316",1514:"0x2E896b0b2Fdb7457499B56AAaA4AE55BCB4Cd316"};// RegistrationWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424)
 */var registrationWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"RegistrationWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"RegistrationWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"spgNftContract",internalType:"address",type:"address",indexed:true}],name:"CollectionCreated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftInitParams",internalType:"struct ISPGNFT.InitParams",type:"tuple",components:[{name:"name",internalType:"string",type:"string"},{name:"symbol",internalType:"string",type:"string"},{name:"baseURI",internalType:"string",type:"string"},{name:"contractURI",internalType:"string",type:"string"},{name:"maxSupply",internalType:"uint32",type:"uint32"},{name:"mintFee",internalType:"uint256",type:"uint256"},{name:"mintFeeToken",internalType:"address",type:"address"},{name:"mintFeeRecipient",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"},{name:"mintOpen",internalType:"bool",type:"bool"},{name:"isPublicMinting",internalType:"bool",type:"bool"}]}],name:"createCollection",outputs:[{name:"spgNftContract",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIp",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"sigMetadata",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIp",outputs:[{name:"ipId",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newNftContractBeacon",internalType:"address",type:"address"}],name:"setNftContractBeacon",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newNftContract",internalType:"address",type:"address"}],name:"upgradeCollections",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424)
 */var registrationWorkflowsAddress={1315:"0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424",1514:"0xbe39E1C756e921BD25DF86e7AAa31106d1eb0424"};// RoyaltyModule
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086)
 */var royaltyModuleAbi=[{type:"constructor",inputs:[{name:"licensingModule",internalType:"address",type:"address"},{name:"disputeModule",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"RoyaltyModule__AboveAccumulatedRoyaltyPoliciesLimit"},{type:"error",inputs:[],name:"RoyaltyModule__AboveMaxPercent"},{type:"error",inputs:[],name:"RoyaltyModule__AboveMaxRts"},{type:"error",inputs:[],name:"RoyaltyModule__CallFailed"},{type:"error",inputs:[{name:"groupId",internalType:"address",type:"address"},{name:"rewardPool",internalType:"address",type:"address"}],name:"RoyaltyModule__GroupRewardPoolNotWhitelisted"},{type:"error",inputs:[],name:"RoyaltyModule__InvalidExternalRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__IpExpired"},{type:"error",inputs:[],name:"RoyaltyModule__IpIsTagged"},{type:"error",inputs:[],name:"RoyaltyModule__NoParentsOnLinking"},{type:"error",inputs:[],name:"RoyaltyModule__NotAllowedCaller"},{type:"error",inputs:[],name:"RoyaltyModule__NotWhitelistedOrRegisteredRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__NotWhitelistedRoyaltyToken"},{type:"error",inputs:[],name:"RoyaltyModule__PaymentAmountIsTooLow"},{type:"error",inputs:[],name:"RoyaltyModule__PolicyAlreadyRegisteredAsExternalRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__PolicyAlreadyWhitelistedOrRegistered"},{type:"error",inputs:[],name:"RoyaltyModule__UnlinkableToParents"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroAccessManager"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroAccumulatedRoyaltyPoliciesLimit"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroAmount"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroDisputeModule"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroIpAssetRegistry"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroIpGraphAcl"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroLicenseRegistry"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroLicensingModule"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroParentIpId"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroReceiverVault"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroRoyaltyPolicy"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroRoyaltyToken"},{type:"error",inputs:[],name:"RoyaltyModule__ZeroTreasury"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"VaultController__ZeroIpRoyaltyVaultBeacon"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"externalRoyaltyPolicy",internalType:"address",type:"address",indexed:false}],name:"ExternalRoyaltyPolicyRegistered"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"ipRoyaltyVault",internalType:"address",type:"address",indexed:false}],name:"IpRoyaltyVaultDeployed"},{type:"event",anonymous:false,inputs:[{name:"receiverIpId",internalType:"address",type:"address",indexed:false},{name:"payerAddress",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false},{name:"amountAfterFee",internalType:"uint256",type:"uint256",indexed:false}],name:"LicenseMintingFeePaid"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"royaltyPolicy",internalType:"address",type:"address",indexed:false},{name:"licensePercent",internalType:"uint32",type:"uint32",indexed:false},{name:"externalData",internalType:"bytes",type:"bytes",indexed:false}],name:"LicensedWithRoyalty"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"parentIpIds",internalType:"address[]",type:"address[]",indexed:false},{name:"licenseRoyaltyPolicies",internalType:"address[]",type:"address[]",indexed:false},{name:"licensesPercent",internalType:"uint32[]",type:"uint32[]",indexed:false},{name:"externalData",internalType:"bytes",type:"bytes",indexed:false}],name:"LinkedToParents"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"royaltyFeePercent",internalType:"uint256",type:"uint256",indexed:false}],name:"RoyaltyFeePercentSet"},{type:"event",anonymous:false,inputs:[{name:"accumulatedRoyaltyPoliciesLimit",internalType:"uint256",type:"uint256",indexed:false}],name:"RoyaltyLimitsUpdated"},{type:"event",anonymous:false,inputs:[{name:"receiverIpId",internalType:"address",type:"address",indexed:false},{name:"payerIpId",internalType:"address",type:"address",indexed:false},{name:"sender",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false},{name:"amountAfterFee",internalType:"uint256",type:"uint256",indexed:false}],name:"RoyaltyPaid"},{type:"event",anonymous:false,inputs:[{name:"royaltyPolicy",internalType:"address",type:"address",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"RoyaltyPolicyWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"token",internalType:"address",type:"address",indexed:false},{name:"allowed",internalType:"bool",type:"bool",indexed:false}],name:"RoyaltyTokenWhitelistUpdated"},{type:"event",anonymous:false,inputs:[{name:"treasury",internalType:"address",type:"address",indexed:false}],name:"TreasurySet"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"DISPUTE_MODULE",outputs:[{name:"",internalType:"contract IDisputeModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IGroupIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"MAX_PERCENT",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"accumulatedRoyaltyPolicies",outputs:[{name:"",internalType:"address[]",type:"address[]"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"globalRoyaltyStack",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestorIpId",internalType:"address",type:"address"}],name:"hasAncestorIp",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"},{name:"accumulatedRoyaltyPoliciesLimit",internalType:"uint256",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"ipRoyaltyVaultBeacon",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"ipRoyaltyVaults",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipRoyaltyVault",internalType:"address",type:"address"}],name:"isIpRoyaltyVault",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"externalRoyaltyPolicy",internalType:"address",type:"address"}],name:"isRegisteredExternalRoyaltyPolicy",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"royaltyPolicy",internalType:"address",type:"address"}],name:"isWhitelistedRoyaltyPolicy",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"isWhitelistedRoyaltyToken",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxAccumulatedRoyaltyPolicies",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxAncestors",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxParents",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"maxPercent",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"pure"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"licensePercent",internalType:"uint32",type:"uint32"},{name:"externalData",internalType:"bytes",type:"bytes"}],name:"onLicenseMinting",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseRoyaltyPolicies",internalType:"address[]",type:"address[]"},{name:"licensesPercent",internalType:"uint32[]",type:"uint32[]"},{name:"externalData",internalType:"bytes",type:"bytes"},{name:"maxRts",internalType:"uint32",type:"uint32"}],name:"onLinkToParents",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"receiverIpId",internalType:"address",type:"address"},{name:"payerAddress",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"payLicenseMintingFee",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"receiverIpId",internalType:"address",type:"address"},{name:"payerIpId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"payRoyaltyOnBehalf",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"externalRoyaltyPolicy",internalType:"address",type:"address"}],name:"registerExternalRoyaltyPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"royaltyFeePercent",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"beacon",internalType:"address",type:"address"}],name:"setIpRoyaltyVaultBeacon",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"royaltyFeePercent",internalType:"uint32",type:"uint32"}],name:"setRoyaltyFeePercent",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accumulatedRoyaltyPoliciesLimit",internalType:"uint256",type:"uint256"}],name:"setRoyaltyLimits",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"treasury",internalType:"address",type:"address"}],name:"setTreasury",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"},{name:"royaltyPolicy",internalType:"address",type:"address"}],name:"totalRevenueTokensAccounted",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"totalRevenueTokensReceived",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"treasury",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"},{type:"function",inputs:[{name:"newVault",internalType:"address",type:"address"}],name:"upgradeVaults",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistRoyaltyPolicy",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"},{name:"allowed",internalType:"bool",type:"bool"}],name:"whitelistRoyaltyToken",outputs:[],stateMutability:"nonpayable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086)
 */var royaltyModuleAddress={1315:"0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086",1514:"0xD2f60c40fEbccf6311f8B47c4f2Ec6b040400086"};/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E)
 */var royaltyPolicyLapAddress={1315:"0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E",1514:"0xBe54FB168b3c982b7AaE60dB6CF75Bd8447b390E"};// RoyaltyPolicyLRP
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x9156e603C949481883B1d3355c6f1132D191fC41)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x9156e603C949481883B1d3355c6f1132D191fC41)
 */var royaltyPolicyLrpAbi=[{type:"constructor",inputs:[{name:"royaltyModule",internalType:"address",type:"address"},{name:"royaltyPolicyLAP",internalType:"address",type:"address"},{name:"ipGraphAcl",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"EnforcedPause"},{type:"error",inputs:[],name:"ExpectedPause"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"ReentrancyGuardReentrantCall"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__AboveMaxPercent"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__CallFailed"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__NotRoyaltyModule"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__SameIpTransfer"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroAccessManager"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroClaimableRoyalty"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroIPGraphACL"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroRoyaltyModule"},{type:"error",inputs:[],name:"RoyaltyPolicyLRP__ZeroRoyaltyPolicyLAP"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Paused"},{type:"event",anonymous:false,inputs:[{name:"ipId",internalType:"address",type:"address",indexed:false},{name:"ancestorIpId",internalType:"address",type:"address",indexed:false},{name:"token",internalType:"address",type:"address",indexed:false},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"RevenueTransferredToVault"},{type:"event",anonymous:false,inputs:[{name:"account",internalType:"address",type:"address",indexed:false}],name:"Unpaused"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"IP_GRAPH",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_GRAPH_ACL",outputs:[{name:"",internalType:"contract IPGraphACL",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_POLICY_LAP",outputs:[{name:"",internalType:"contract IGraphAwareRoyaltyPolicy",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"__ProtocolPausable_init",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestorIpId",internalType:"address",type:"address"}],name:"getPolicyRoyalty",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"}],name:"getPolicyRoyaltyStack",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licensePercent",internalType:"uint32",type:"uint32"}],name:"getPolicyRtsRequiredToLink",outputs:[{name:"",internalType:"uint32",type:"uint32"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestorIpId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"getTransferredTokens",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[],name:"isSupportGroup",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licensePercent",internalType:"uint32",type:"uint32"},{name:"",internalType:"bytes",type:"bytes"}],name:"onLicenseMinting",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseRoyaltyPolicies",internalType:"address[]",type:"address[]"},{name:"licensesPercent",internalType:"uint32[]",type:"uint32[]"},{name:"",internalType:"bytes",type:"bytes"}],name:"onLinkToParents",outputs:[{name:"newRoyaltyStackLRP",internalType:"uint32",type:"uint32"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"paused",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ancestorIpId",internalType:"address",type:"address"},{name:"token",internalType:"address",type:"address"}],name:"transferToVault",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x9156e603C949481883B1d3355c6f1132D191fC41)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x9156e603C949481883B1d3355c6f1132D191fC41)
 */var royaltyPolicyLrpAddress={1315:"0x9156e603C949481883B1d3355c6f1132D191fC41",1514:"0x9156e603C949481883B1d3355c6f1132D191fC41"};// RoyaltyTokenDistributionWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xa38f42B8d33809917f23997B8423054aAB97322C)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xa38f42B8d33809917f23997B8423054aAB97322C)
 */var royaltyTokenDistributionWorkflowsAbi=[{type:"constructor",inputs:[{name:"accessController",internalType:"address",type:"address"},{name:"coreMetadataModule",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"},{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licensingModule",internalType:"address",type:"address"},{name:"pilTemplate",internalType:"address",type:"address"},{name:"royaltyModule",internalType:"address",type:"address"},{name:"royaltyPolicyLRP",internalType:"address",type:"address"},{name:"wip",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"LicensingHelper__ParentIpIdsAndLicenseTermsIdsMismatch"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"PermissionHelper__ModulesAndSelectorsMismatch"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"signer",internalType:"address",type:"address"}],name:"RoyaltyTokenDistributionWorkflows__CallerNotSigner"},{type:"error",inputs:[],name:"RoyaltyTokenDistributionWorkflows__NoLicenseTermsData"},{type:"error",inputs:[],name:"RoyaltyTokenDistributionWorkflows__RoyaltyVaultNotDeployed"},{type:"error",inputs:[{name:"totalShares",internalType:"uint32",type:"uint32"},{name:"ipAccountBalance",internalType:"uint32",type:"uint32"}],name:"RoyaltyTokenDistributionWorkflows__TotalSharesExceedsIPAccountBalance"},{type:"error",inputs:[],name:"RoyaltyTokenDistributionWorkflows__ZeroAddressParam"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"error",inputs:[],name:"Workflow__CallerNotAuthorizedToMint"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"CORE_METADATA_MODULE",outputs:[{name:"",internalType:"contract ICoreMetadataModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSING_MODULE",outputs:[{name:"",internalType:"contract ILicensingModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"PIL_TEMPLATE",outputs:[{name:"",internalType:"contract IPILicenseTemplate",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_POLICY_LRP",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"WIP",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ipId",internalType:"address",type:"address"},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]},{name:"sigApproveRoyaltyTokens",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"distributeRoyaltyTokens",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"recipient",internalType:"address",type:"address"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"royaltyShares",internalType:"struct WorkflowStructs.RoyaltyShare[]",type:"tuple[]",components:[{name:"recipient",internalType:"address",type:"address"},{name:"percentage",internalType:"uint32",type:"uint32"}]},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"",internalType:"address",type:"address"},{name:"",internalType:"address",type:"address"},{name:"",internalType:"uint256",type:"uint256"},{name:"",internalType:"bytes",type:"bytes"}],name:"onERC721Received",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"licenseTermsData",internalType:"struct WorkflowStructs.LicenseTermsData[]",type:"tuple[]",components:[{name:"terms",internalType:"struct PILTerms",type:"tuple",components:[{name:"transferable",internalType:"bool",type:"bool"},{name:"royaltyPolicy",internalType:"address",type:"address"},{name:"defaultMintingFee",internalType:"uint256",type:"uint256"},{name:"expiration",internalType:"uint256",type:"uint256"},{name:"commercialUse",internalType:"bool",type:"bool"},{name:"commercialAttribution",internalType:"bool",type:"bool"},{name:"commercializerChecker",internalType:"address",type:"address"},{name:"commercializerCheckerData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"commercialRevCeiling",internalType:"uint256",type:"uint256"},{name:"derivativesAllowed",internalType:"bool",type:"bool"},{name:"derivativesAttribution",internalType:"bool",type:"bool"},{name:"derivativesApproval",internalType:"bool",type:"bool"},{name:"derivativesReciprocal",internalType:"bool",type:"bool"},{name:"derivativeRevCeiling",internalType:"uint256",type:"uint256"},{name:"currency",internalType:"address",type:"address"},{name:"uri",internalType:"string",type:"string"}]},{name:"licensingConfig",internalType:"struct Licensing.LicensingConfig",type:"tuple",components:[{name:"isSet",internalType:"bool",type:"bool"},{name:"mintingFee",internalType:"uint256",type:"uint256"},{name:"licensingHook",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"},{name:"commercialRevShare",internalType:"uint32",type:"uint32"},{name:"disabled",internalType:"bool",type:"bool"},{name:"expectMinimumGroupRewardShare",internalType:"uint32",type:"uint32"},{name:"expectGroupRewardPool",internalType:"address",type:"address"}]}]},{name:"sigMetadataAndAttachAndConfig",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndAttachPILTermsAndDeployRoyaltyVault",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"ipRoyaltyVault",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"nftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"ipMetadata",internalType:"struct WorkflowStructs.IPMetadata",type:"tuple",components:[{name:"ipMetadataURI",internalType:"string",type:"string"},{name:"ipMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}]},{name:"derivData",internalType:"struct WorkflowStructs.MakeDerivative",type:"tuple",components:[{name:"parentIpIds",internalType:"address[]",type:"address[]"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsIds",internalType:"uint256[]",type:"uint256[]"},{name:"royaltyContext",internalType:"bytes",type:"bytes"},{name:"maxMintingFee",internalType:"uint256",type:"uint256"},{name:"maxRts",internalType:"uint32",type:"uint32"},{name:"maxRevenueShare",internalType:"uint32",type:"uint32"}]},{name:"sigMetadataAndRegister",internalType:"struct WorkflowStructs.SignatureData",type:"tuple",components:[{name:"signer",internalType:"address",type:"address"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"signature",internalType:"bytes",type:"bytes"}]}],name:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",outputs:[{name:"ipId",internalType:"address",type:"address"},{name:"ipRoyaltyVault",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xa38f42B8d33809917f23997B8423054aAB97322C)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xa38f42B8d33809917f23997B8423054aAB97322C)
 */var royaltyTokenDistributionWorkflowsAddress={1315:"0xa38f42B8d33809917f23997B8423054aAB97322C",1514:"0xa38f42B8d33809917f23997B8423054aAB97322C"};// RoyaltyWorkflows
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890)
 */var royaltyWorkflowsAbi=[{type:"constructor",inputs:[{name:"royaltyModule",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"authority",internalType:"address",type:"address"}],name:"AccessManagedInvalidAuthority"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"delay",internalType:"uint32",type:"uint32"}],name:"AccessManagedRequiredDelay"},{type:"error",inputs:[{name:"caller",internalType:"address",type:"address"}],name:"AccessManagedUnauthorized"},{type:"error",inputs:[{name:"target",internalType:"address",type:"address"}],name:"AddressEmptyCode"},{type:"error",inputs:[{name:"implementation",internalType:"address",type:"address"}],name:"ERC1967InvalidImplementation"},{type:"error",inputs:[],name:"ERC1967NonPayable"},{type:"error",inputs:[],name:"FailedCall"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"RoyaltyWorkflows__ZeroAddressParam"},{type:"error",inputs:[],name:"UUPSUnauthorizedCallContext"},{type:"error",inputs:[{name:"slot",internalType:"bytes32",type:"bytes32"}],name:"UUPSUnsupportedProxiableUUID"},{type:"event",anonymous:false,inputs:[{name:"authority",internalType:"address",type:"address",indexed:false}],name:"AuthorityUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"implementation",internalType:"address",type:"address",indexed:true}],name:"Upgraded"},{type:"function",inputs:[],name:"ROYALTY_MODULE",outputs:[{name:"",internalType:"contract IRoyaltyModule",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"UPGRADE_INTERFACE_VERSION",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"authority",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"ancestorIpId",internalType:"address",type:"address"},{name:"claimer",internalType:"address",type:"address"},{name:"childIpIds",internalType:"address[]",type:"address[]"},{name:"royaltyPolicies",internalType:"address[]",type:"address[]"},{name:"currencyTokens",internalType:"address[]",type:"address[]"}],name:"claimAllRevenue",outputs:[{name:"amountsClaimed",internalType:"uint256[]",type:"uint256[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"accessManager",internalType:"address",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"isConsumingScheduledOp",outputs:[{name:"",internalType:"bytes4",type:"bytes4"}],stateMutability:"view"},{type:"function",inputs:[{name:"data",internalType:"bytes[]",type:"bytes[]"}],name:"multicall",outputs:[{name:"results",internalType:"bytes[]",type:"bytes[]"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"proxiableUUID",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"newAuthority",internalType:"address",type:"address"}],name:"setAuthority",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newImplementation",internalType:"address",type:"address"},{name:"data",internalType:"bytes",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890)
 */var royaltyWorkflowsAddress={1315:"0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890",1514:"0x9515faE61E0c0447C6AC6dEe5628A2097aFE1890"};// SPGNFTImpl
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x5266215a00c31AaA2f2BB7b951Ea0028Ea8b4e37)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x6Cfa03Bc64B1a76206d0Ea10baDed31D520449F5)
 */var spgnftImplAbi=[{type:"constructor",inputs:[{name:"derivativeWorkflows",internalType:"address",type:"address"},{name:"groupingWorkflows",internalType:"address",type:"address"},{name:"licenseAttachmentWorkflows",internalType:"address",type:"address"},{name:"registrationWorkflows",internalType:"address",type:"address"},{name:"royaltyTokenDistributionWorkflows",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[],name:"AccessControlBadConfirmation"},{type:"error",inputs:[{name:"account",internalType:"address",type:"address"},{name:"neededRole",internalType:"bytes32",type:"bytes32"}],name:"AccessControlUnauthorizedAccount"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"owner",internalType:"address",type:"address"}],name:"ERC721IncorrectOwner"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721InsufficientApproval"},{type:"error",inputs:[{name:"approver",internalType:"address",type:"address"}],name:"ERC721InvalidApprover"},{type:"error",inputs:[{name:"operator",internalType:"address",type:"address"}],name:"ERC721InvalidOperator"},{type:"error",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"ERC721InvalidOwner"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC721InvalidReceiver"},{type:"error",inputs:[{name:"sender",internalType:"address",type:"address"}],name:"ERC721InvalidSender"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ERC721NonexistentToken"},{type:"error",inputs:[],name:"InvalidInitialization"},{type:"error",inputs:[],name:"NotInitializing"},{type:"error",inputs:[],name:"SPGNFT__CallerNotFeeRecipientOrAdmin"},{type:"error",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"caller",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"}],name:"SPGNFT__CallerNotOwner"},{type:"error",inputs:[],name:"SPGNFT__CallerNotPeripheryContract"},{type:"error",inputs:[{name:"spgNftContract",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"SPGNFT__DuplicatedNFTMetadataHash"},{type:"error",inputs:[],name:"SPGNFT__MaxSupplyReached"},{type:"error",inputs:[],name:"SPGNFT__MintingClosed"},{type:"error",inputs:[],name:"SPGNFT__MintingDenied"},{type:"error",inputs:[],name:"SPGNFT__ZeroAddressParam"},{type:"error",inputs:[],name:"SPGNFT__ZeroMaxSupply"},{type:"error",inputs:[{name:"token",internalType:"address",type:"address"}],name:"SafeERC20FailedOperation"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"operator",internalType:"address",type:"address",indexed:true},{name:"approved",internalType:"bool",type:"bool",indexed:false}],name:"ApprovalForAll"},{type:"event",anonymous:false,inputs:[{name:"_fromTokenId",internalType:"uint256",type:"uint256",indexed:false},{name:"_toTokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"BatchMetadataUpdate"},{type:"event",anonymous:false,inputs:[],name:"ContractURIUpdated"},{type:"event",anonymous:false,inputs:[{name:"version",internalType:"uint64",type:"uint64",indexed:false}],name:"Initialized"},{type:"event",anonymous:false,inputs:[{name:"_tokenId",internalType:"uint256",type:"uint256",indexed:false}],name:"MetadataUpdate"},{type:"event",anonymous:false,inputs:[{name:"role",internalType:"bytes32",type:"bytes32",indexed:true},{name:"previousAdminRole",internalType:"bytes32",type:"bytes32",indexed:true},{name:"newAdminRole",internalType:"bytes32",type:"bytes32",indexed:true}],name:"RoleAdminChanged"},{type:"event",anonymous:false,inputs:[{name:"role",internalType:"bytes32",type:"bytes32",indexed:true},{name:"account",internalType:"address",type:"address",indexed:true},{name:"sender",internalType:"address",type:"address",indexed:true}],name:"RoleGranted"},{type:"event",anonymous:false,inputs:[{name:"role",internalType:"bytes32",type:"bytes32",indexed:true},{name:"account",internalType:"address",type:"address",indexed:true},{name:"sender",internalType:"address",type:"address",indexed:true}],name:"RoleRevoked"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"tokenId",internalType:"uint256",type:"uint256",indexed:true}],name:"Transfer"},{type:"function",inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[],name:"DERIVATIVE_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"GROUPING_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_ATTACHMENT_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"REGISTRATION_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"ROYALTY_TOKEN_DISTRIBUTION_WORKFLOWS_ADDRESS",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"baseURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"contractURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"getApproved",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"}],name:"getRoleAdmin",outputs:[{name:"",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"}],name:"getTokenIdByMetadataHash",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"account",internalType:"address",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"account",internalType:"address",type:"address"}],name:"hasRole",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"initParams",internalType:"struct ISPGNFT.InitParams",type:"tuple",components:[{name:"name",internalType:"string",type:"string"},{name:"symbol",internalType:"string",type:"string"},{name:"baseURI",internalType:"string",type:"string"},{name:"contractURI",internalType:"string",type:"string"},{name:"maxSupply",internalType:"uint32",type:"uint32"},{name:"mintFee",internalType:"uint256",type:"uint256"},{name:"mintFeeToken",internalType:"address",type:"address"},{name:"mintFeeRecipient",internalType:"address",type:"address"},{name:"owner",internalType:"address",type:"address"},{name:"mintOpen",internalType:"bool",type:"bool"},{name:"isPublicMinting",internalType:"bool",type:"bool"}]}],name:"initialize",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"operator",internalType:"address",type:"address"}],name:"isApprovedForAll",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mint",outputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"payer",internalType:"address",type:"address"},{name:"nftMetadataURI",internalType:"string",type:"string"},{name:"nftMetadataHash",internalType:"bytes32",type:"bytes32"},{name:"allowDuplicates",internalType:"bool",type:"bool"}],name:"mintByPeriphery",outputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"mintFee",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"mintFeeRecipient",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"mintFeeToken",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"mintOpen",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"ownerOf",outputs:[{name:"",internalType:"address",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"publicMinting",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"callerConfirmation",internalType:"address",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"role",internalType:"bytes32",type:"bytes32"},{name:"account",internalType:"address",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"data",internalType:"bytes",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"operator",internalType:"address",type:"address"},{name:"approved",internalType:"bool",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"baseURI",internalType:"string",type:"string"}],name:"setBaseURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"contractURI",internalType:"string",type:"string"}],name:"setContractURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"fee",internalType:"uint256",type:"uint256"}],name:"setMintFee",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"newFeeRecipient",internalType:"address",type:"address"}],name:"setMintFeeRecipient",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"setMintFeeToken",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"mintOpen",internalType:"bool",type:"bool"}],name:"setMintOpen",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"isPublicMinting",internalType:"bool",type:"bool"}],name:"setPublicMinting",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"},{name:"tokenUri",internalType:"string",type:"string"}],name:"setTokenURI",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"tokenURI",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"tokenId",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"token",internalType:"address",type:"address"}],name:"withdrawToken",outputs:[],stateMutability:"nonpayable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x5266215a00c31AaA2f2BB7b951Ea0028Ea8b4e37)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x6Cfa03Bc64B1a76206d0Ea10baDed31D520449F5)
 */var spgnftImplAddress={1315:"0x5266215a00c31AaA2f2BB7b951Ea0028Ea8b4e37",1514:"0x6Cfa03Bc64B1a76206d0Ea10baDed31D520449F5"};// TotalLicenseTokenLimitHook
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xaBAD364Bfa41230272b08f171E0Ca939bD600478)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xB72C9812114a0Fc74D49e01385bd266A75960Cda)
 */var totalLicenseTokenLimitHookAbi=[{type:"constructor",inputs:[{name:"licenseRegistry",internalType:"address",type:"address"},{name:"licenseToken",internalType:"address",type:"address"},{name:"accessController",internalType:"address",type:"address"},{name:"ipAssetRegistry",internalType:"address",type:"address"}],stateMutability:"nonpayable"},{type:"error",inputs:[{name:"ipAccount",internalType:"address",type:"address"}],name:"AccessControlled__NotIpAccount"},{type:"error",inputs:[],name:"AccessControlled__ZeroAddress"},{type:"error",inputs:[{name:"totalSupply",internalType:"uint256",type:"uint256"},{name:"limit",internalType:"uint256",type:"uint256"}],name:"TotalLicenseTokenLimitHook_LimitLowerThanTotalSupply"},{type:"error",inputs:[{name:"totalSupply",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"limit",internalType:"uint256",type:"uint256"}],name:"TotalLicenseTokenLimitHook_TotalLicenseTokenLimitExceeded"},{type:"error",inputs:[],name:"TotalLicenseTokenLimitHook_ZeroLicenseRegistry"},{type:"error",inputs:[],name:"TotalLicenseTokenLimitHook_ZeroLicenseToken"},{type:"event",anonymous:false,inputs:[{name:"licensorIpId",internalType:"address",type:"address",indexed:true},{name:"licenseTemplate",internalType:"address",type:"address",indexed:true},{name:"licenseTermsId",internalType:"uint256",type:"uint256",indexed:true},{name:"limit",internalType:"uint256",type:"uint256",indexed:false}],name:"SetTotalLicenseTokenLimit"},{type:"function",inputs:[],name:"ACCESS_CONTROLLER",outputs:[{name:"",internalType:"contract IAccessController",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"IP_ASSET_REGISTRY",outputs:[{name:"",internalType:"contract IIPAssetRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_REGISTRY",outputs:[{name:"",internalType:"contract ILicenseRegistry",type:"address"}],stateMutability:"view"},{type:"function",inputs:[],name:"LICENSE_TOKEN",outputs:[{name:"",internalType:"contract ILicenseToken",type:"address"}],stateMutability:"view"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"receiver",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"}],name:"beforeMintLicenseTokens",outputs:[{name:"totalMintingFee",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"childIpId",internalType:"address",type:"address"},{name:"parentIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"hookData",internalType:"bytes",type:"bytes"}],name:"beforeRegisterDerivative",outputs:[{name:"mintingFee",internalType:"uint256",type:"uint256"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"caller",internalType:"address",type:"address"},{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"amount",internalType:"uint256",type:"uint256"},{name:"receiver",internalType:"address",type:"address"},{name:"hookData",internalType:"bytes",type:"bytes"}],name:"calculateMintingFee",outputs:[{name:"totalMintingFee",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"}],name:"getTotalLicenseTokenLimit",outputs:[{name:"limit",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"view"},{type:"function",inputs:[{name:"licensorIpId",internalType:"address",type:"address"},{name:"licenseTemplate",internalType:"address",type:"address"},{name:"licenseTermsId",internalType:"uint256",type:"uint256"},{name:"limit",internalType:"uint256",type:"uint256"}],name:"setTotalLicenseTokenLimit",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"interfaceId",internalType:"bytes4",type:"bytes4"}],name:"supportsInterface",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"view"},{type:"function",inputs:[{name:"",internalType:"bytes32",type:"bytes32"}],name:"totalLicenseTokenLimit",outputs:[{name:"",internalType:"uint256",type:"uint256"}],stateMutability:"view"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0xaBAD364Bfa41230272b08f171E0Ca939bD600478)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0xB72C9812114a0Fc74D49e01385bd266A75960Cda)
 */var totalLicenseTokenLimitHookAddress={1315:"0xaBAD364Bfa41230272b08f171E0Ca939bD600478",1514:"0xB72C9812114a0Fc74D49e01385bd266A75960Cda"};// WrappedIP
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x1514000000000000000000000000000000000000)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x1514000000000000000000000000000000000000)
 */var wrappedIpAbi=[{type:"error",inputs:[],name:"AllowanceOverflow"},{type:"error",inputs:[],name:"AllowanceUnderflow"},{type:"error",inputs:[{name:"receiver",internalType:"address",type:"address"}],name:"ERC20InvalidReceiver"},{type:"error",inputs:[{name:"spender",internalType:"address",type:"address"}],name:"ERC20InvalidSpender"},{type:"error",inputs:[],name:"IPTransferFailed"},{type:"error",inputs:[],name:"InsufficientAllowance"},{type:"error",inputs:[],name:"InsufficientBalance"},{type:"error",inputs:[],name:"InvalidPermit"},{type:"error",inputs:[],name:"Permit2AllowanceIsFixedAtInfinity"},{type:"error",inputs:[],name:"PermitExpired"},{type:"error",inputs:[],name:"TotalSupplyOverflow"},{type:"event",anonymous:false,inputs:[{name:"owner",internalType:"address",type:"address",indexed:true},{name:"spender",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Approval"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Deposit"},{type:"event",anonymous:false,inputs:[{name:"from",internalType:"address",type:"address",indexed:true},{name:"to",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Transfer"},{type:"event",anonymous:false,inputs:[{name:"to",internalType:"address",type:"address",indexed:true},{name:"amount",internalType:"uint256",type:"uint256",indexed:false}],name:"Withdrawal"},{type:"function",inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{name:"result",internalType:"bytes32",type:"bytes32"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"}],name:"allowance",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"spender",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"approve",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"balanceOf",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[],name:"decimals",outputs:[{name:"",internalType:"uint8",type:"uint8"}],stateMutability:"view"},{type:"function",inputs:[],name:"deposit",outputs:[],stateMutability:"payable"},{type:"function",inputs:[],name:"name",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"}],name:"nonces",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"owner",internalType:"address",type:"address"},{name:"spender",internalType:"address",type:"address"},{name:"value",internalType:"uint256",type:"uint256"},{name:"deadline",internalType:"uint256",type:"uint256"},{name:"v",internalType:"uint8",type:"uint8"},{name:"r",internalType:"bytes32",type:"bytes32"},{name:"s",internalType:"bytes32",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable"},{type:"function",inputs:[],name:"symbol",outputs:[{name:"",internalType:"string",type:"string"}],stateMutability:"pure"},{type:"function",inputs:[],name:"totalSupply",outputs:[{name:"result",internalType:"uint256",type:"uint256"}],stateMutability:"view"},{type:"function",inputs:[{name:"to",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"transfer",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"from",internalType:"address",type:"address"},{name:"to",internalType:"address",type:"address"},{name:"amount",internalType:"uint256",type:"uint256"}],name:"transferFrom",outputs:[{name:"",internalType:"bool",type:"bool"}],stateMutability:"nonpayable"},{type:"function",inputs:[{name:"value",internalType:"uint256",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable"},{type:"receive",stateMutability:"payable"}];/**
 * - [__View Contract on Story Aeneid Story Aeneid Explorer__](https://aeneid.storyscan.xyz/address/0x1514000000000000000000000000000000000000)
 * - [__View Contract on Story Story Explorer__](https://storyscan.xyz/address/0x1514000000000000000000000000000000000000)
 */var wrappedIpAddress={1315:"0x1514000000000000000000000000000000000000",1514:"0x1514000000000000000000000000000000000000"};// SDK
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// COMMON =============================================================
function getAddress(address,chainId){return address[chainId||0]||"0x";}// Contract AccessController =============================================================
/**
 * AccessControllerPermissionSetEvent
 *
 * @param ipAccountOwner address
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 *//**
 * AccessControllerSetAllPermissionsRequest
 *
 * @param ipAccount address
 * @param signer address
 * @param permission uint8
 *//**
 * AccessControllerSetBatchPermissionsRequest
 *
 * @param permissions tuple[]
 *//**
 * AccessControllerSetPermissionRequest
 *
 * @param ipAccount address
 * @param signer address
 * @param to address
 * @param func bytes4
 * @param permission uint8
 *//**
 * contract AccessController event
 */var AccessControllerEventClient=/*#__PURE__*/function(){function AccessControllerEventClient(rpcClient,address){var _rpcClient$chain;_classCallCheck(this,AccessControllerEventClient);this.address=address||getAddress(accessControllerAddress,(_rpcClient$chain=rpcClient.chain)===null||_rpcClient$chain===void 0?void 0:_rpcClient$chain.id);this.rpcClient=rpcClient;}/**
   * event PermissionSet for contract AccessController
   */return _createClass(AccessControllerEventClient,[{key:"watchPermissionSetEvent",value:function watchPermissionSetEvent(_onLogs){return this.rpcClient.watchContractEvent({abi:accessControllerAbi,address:this.address,eventName:"PermissionSet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event PermissionSet for contract AccessController
   */},{key:"parseTxPermissionSetEvent",value:function parseTxPermissionSetEvent(txReceipt){var targetLogs=[];var _iterator=_createForOfIteratorHelper(txReceipt.logs),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var log=_step.value;try{var event=viem.decodeEventLog({abi:accessControllerAbi,eventName:"PermissionSet",data:log.data,topics:log.topics});if(event.eventName==="PermissionSet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return targetLogs;}}]);}();/**
 * contract AccessController write method
 */var AccessControllerClient=/*#__PURE__*/function(_AccessControllerEven){function AccessControllerClient(rpcClient,wallet,address){var _this;_classCallCheck(this,AccessControllerClient);_this=_callSuper(this,AccessControllerClient,[rpcClient,address]);_this.wallet=wallet;return _this;}/**
   * method setAllPermissions for contract AccessController
   *
   * @param request AccessControllerSetAllPermissionsRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(AccessControllerClient,_AccessControllerEven);return _createClass(AccessControllerClient,[{key:"setAllPermissions",value:(function(){var _setAllPermissions=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(request){var _yield$this$rpcClient,call;return _regenerator().w(function(_context){while(1)switch(_context.n){case 0:_context.n=1;return this.rpcClient.simulateContract({abi:accessControllerAbi,address:this.address,functionName:"setAllPermissions",account:this.wallet.account,args:[request.ipAccount,request.signer,request.permission]});case 1:_yield$this$rpcClient=_context.v;call=_yield$this$rpcClient.request;_context.n=2;return this.wallet.writeContract(call);case 2:return _context.a(2,_context.v);}},_callee,this);}));function setAllPermissions(_x){return _setAllPermissions.apply(this,arguments);}return setAllPermissions;}()/**
   * method setAllPermissions for contract AccessController with only encode
   *
   * @param request AccessControllerSetAllPermissionsRequest
   * @return EncodedTxData
   */)},{key:"setAllPermissionsEncode",value:function setAllPermissionsEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:accessControllerAbi,functionName:"setAllPermissions",args:[request.ipAccount,request.signer,request.permission]})};}/**
   * method setBatchPermissions for contract AccessController
   *
   * @param request AccessControllerSetBatchPermissionsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setBatchPermissions",value:(function(){var _setBatchPermissions=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(request){var _yield$this$rpcClient2,call;return _regenerator().w(function(_context2){while(1)switch(_context2.n){case 0:_context2.n=1;return this.rpcClient.simulateContract({abi:accessControllerAbi,address:this.address,functionName:"setBatchPermissions",account:this.wallet.account,args:[request.permissions]});case 1:_yield$this$rpcClient2=_context2.v;call=_yield$this$rpcClient2.request;_context2.n=2;return this.wallet.writeContract(call);case 2:return _context2.a(2,_context2.v);}},_callee2,this);}));function setBatchPermissions(_x2){return _setBatchPermissions.apply(this,arguments);}return setBatchPermissions;}()/**
   * method setBatchPermissions for contract AccessController with only encode
   *
   * @param request AccessControllerSetBatchPermissionsRequest
   * @return EncodedTxData
   */)},{key:"setBatchPermissionsEncode",value:function setBatchPermissionsEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:accessControllerAbi,functionName:"setBatchPermissions",args:[request.permissions]})};}/**
   * method setPermission for contract AccessController
   *
   * @param request AccessControllerSetPermissionRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setPermission",value:(function(){var _setPermission=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(request){var _yield$this$rpcClient3,call;return _regenerator().w(function(_context3){while(1)switch(_context3.n){case 0:_context3.n=1;return this.rpcClient.simulateContract({abi:accessControllerAbi,address:this.address,functionName:"setPermission",account:this.wallet.account,args:[request.ipAccount,request.signer,request.to,request.func,request.permission]});case 1:_yield$this$rpcClient3=_context3.v;call=_yield$this$rpcClient3.request;_context3.n=2;return this.wallet.writeContract(call);case 2:return _context3.a(2,_context3.v);}},_callee3,this);}));function setPermission(_x3){return _setPermission.apply(this,arguments);}return setPermission;}()/**
   * method setPermission for contract AccessController with only encode
   *
   * @param request AccessControllerSetPermissionRequest
   * @return EncodedTxData
   */)},{key:"setPermissionEncode",value:function setPermissionEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:accessControllerAbi,functionName:"setPermission",args:[request.ipAccount,request.signer,request.to,request.func,request.permission]})};}}]);}(AccessControllerEventClient);// Contract ArbitrationPolicyUMA =============================================================
/**
 * ArbitrationPolicyUmaDisputeIdToAssertionIdRequest
 *
 * @param disputeId uint256
 *//**
 * ArbitrationPolicyUmaMaxBondsRequest
 *
 * @param token address
 *//**
 * ArbitrationPolicyUmaDisputeAssertionRequest
 *
 * @param assertionId bytes32
 * @param counterEvidenceHash bytes32
 *//**
 * contract ArbitrationPolicyUMA readonly method
 */var ArbitrationPolicyUmaReadOnlyClient=/*#__PURE__*/function(){function ArbitrationPolicyUmaReadOnlyClient(rpcClient,address){var _rpcClient$chain2;_classCallCheck(this,ArbitrationPolicyUmaReadOnlyClient);this.address=address||getAddress(arbitrationPolicyUmaAddress,(_rpcClient$chain2=rpcClient.chain)===null||_rpcClient$chain2===void 0?void 0:_rpcClient$chain2.id);this.rpcClient=rpcClient;}/**
   * method disputeIdToAssertionId for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaDisputeIdToAssertionIdRequest
   * @return Promise<ArbitrationPolicyUmaDisputeIdToAssertionIdResponse>
   */return _createClass(ArbitrationPolicyUmaReadOnlyClient,[{key:"disputeIdToAssertionId",value:(function(){var _disputeIdToAssertionId=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(request){return _regenerator().w(function(_context4){while(1)switch(_context4.n){case 0:_context4.n=1;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"disputeIdToAssertionId",args:[request.disputeId]});case 1:return _context4.a(2,_context4.v);}},_callee4,this);}));function disputeIdToAssertionId(_x4){return _disputeIdToAssertionId.apply(this,arguments);}return disputeIdToAssertionId;}()/**
   * method maxBonds for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaMaxBondsRequest
   * @return Promise<ArbitrationPolicyUmaMaxBondsResponse>
   */)},{key:"maxBonds",value:(function(){var _maxBonds=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(request){return _regenerator().w(function(_context5){while(1)switch(_context5.n){case 0:_context5.n=1;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"maxBonds",args:[request.token]});case 1:return _context5.a(2,_context5.v);}},_callee5,this);}));function maxBonds(_x5){return _maxBonds.apply(this,arguments);}return maxBonds;}()/**
   * method maxLiveness for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaMaxLivenessRequest
   * @return Promise<ArbitrationPolicyUmaMaxLivenessResponse>
   */)},{key:"maxLiveness",value:(function(){var _maxLiveness=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(){return _regenerator().w(function(_context6){while(1)switch(_context6.n){case 0:_context6.n=1;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"maxLiveness"});case 1:return _context6.a(2,_context6.v);}},_callee6,this);}));function maxLiveness(){return _maxLiveness.apply(this,arguments);}return maxLiveness;}()/**
   * method minLiveness for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaMinLivenessRequest
   * @return Promise<ArbitrationPolicyUmaMinLivenessResponse>
   */)},{key:"minLiveness",value:(function(){var _minLiveness=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(){return _regenerator().w(function(_context7){while(1)switch(_context7.n){case 0:_context7.n=1;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"minLiveness"});case 1:return _context7.a(2,_context7.v);}},_callee7,this);}));function minLiveness(){return _minLiveness.apply(this,arguments);}return minLiveness;}()/**
   * method oov3 for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaOov3Request
   * @return Promise<ArbitrationPolicyUmaOov3Response>
   */)},{key:"oov3",value:(function(){var _oov=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(){return _regenerator().w(function(_context8){while(1)switch(_context8.n){case 0:_context8.n=1;return this.rpcClient.readContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"oov3"});case 1:return _context8.a(2,_context8.v);}},_callee8,this);}));function oov3(){return _oov.apply(this,arguments);}return oov3;}())}]);}();/**
 * contract ArbitrationPolicyUMA write method
 */var ArbitrationPolicyUmaClient=/*#__PURE__*/function(_ArbitrationPolicyUma){function ArbitrationPolicyUmaClient(rpcClient,wallet,address){var _this2;_classCallCheck(this,ArbitrationPolicyUmaClient);_this2=_callSuper(this,ArbitrationPolicyUmaClient,[rpcClient,address]);_this2.wallet=wallet;return _this2;}/**
   * method disputeAssertion for contract ArbitrationPolicyUMA
   *
   * @param request ArbitrationPolicyUmaDisputeAssertionRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(ArbitrationPolicyUmaClient,_ArbitrationPolicyUma);return _createClass(ArbitrationPolicyUmaClient,[{key:"disputeAssertion",value:(function(){var _disputeAssertion=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(request){var _yield$this$rpcClient4,call;return _regenerator().w(function(_context9){while(1)switch(_context9.n){case 0:_context9.n=1;return this.rpcClient.simulateContract({abi:arbitrationPolicyUmaAbi,address:this.address,functionName:"disputeAssertion",account:this.wallet.account,args:[request.assertionId,request.counterEvidenceHash]});case 1:_yield$this$rpcClient4=_context9.v;call=_yield$this$rpcClient4.request;_context9.n=2;return this.wallet.writeContract(call);case 2:return _context9.a(2,_context9.v);}},_callee9,this);}));function disputeAssertion(_x6){return _disputeAssertion.apply(this,arguments);}return disputeAssertion;}()/**
   * method disputeAssertion for contract ArbitrationPolicyUMA with only encode
   *
   * @param request ArbitrationPolicyUmaDisputeAssertionRequest
   * @return EncodedTxData
   */)},{key:"disputeAssertionEncode",value:function disputeAssertionEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:arbitrationPolicyUmaAbi,functionName:"disputeAssertion",args:[request.assertionId,request.counterEvidenceHash]})};}}]);}(ArbitrationPolicyUmaReadOnlyClient);// Contract CoreMetadataModule =============================================================
/**
 * CoreMetadataModuleAuthorityUpdatedEvent
 *
 * @param authority address
 *//**
 * CoreMetadataModuleInitializedEvent
 *
 * @param version uint64
 *//**
 * CoreMetadataModuleMetadataFrozenEvent
 *
 * @param ipId address
 *//**
 * CoreMetadataModuleMetadataUriSetEvent
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 *//**
 * CoreMetadataModuleNftTokenUriSetEvent
 *
 * @param ipId address
 * @param nftTokenURI string
 * @param nftMetadataHash bytes32
 *//**
 * CoreMetadataModuleUpgradedEvent
 *
 * @param implementation address
 *//**
 * CoreMetadataModuleIsMetadataFrozenRequest
 *
 * @param ipId address
 *//**
 * CoreMetadataModuleSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 *//**
 * CoreMetadataModuleFreezeMetadataRequest
 *
 * @param ipId address
 *//**
 * CoreMetadataModuleInitializeRequest
 *
 * @param accessManager address
 *//**
 * CoreMetadataModuleSetAllRequest
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 * @param nftMetadataHash bytes32
 *//**
 * CoreMetadataModuleSetAuthorityRequest
 *
 * @param newAuthority address
 *//**
 * CoreMetadataModuleSetMetadataUriRequest
 *
 * @param ipId address
 * @param metadataURI string
 * @param metadataHash bytes32
 *//**
 * CoreMetadataModuleUpdateNftTokenUriRequest
 *
 * @param ipId address
 * @param nftMetadataHash bytes32
 *//**
 * CoreMetadataModuleUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 *//**
 * contract CoreMetadataModule event
 */var CoreMetadataModuleEventClient=/*#__PURE__*/function(){function CoreMetadataModuleEventClient(rpcClient,address){var _rpcClient$chain3;_classCallCheck(this,CoreMetadataModuleEventClient);this.address=address||getAddress(coreMetadataModuleAddress,(_rpcClient$chain3=rpcClient.chain)===null||_rpcClient$chain3===void 0?void 0:_rpcClient$chain3.id);this.rpcClient=rpcClient;}/**
   * event AuthorityUpdated for contract CoreMetadataModule
   */return _createClass(CoreMetadataModuleEventClient,[{key:"watchAuthorityUpdatedEvent",value:function watchAuthorityUpdatedEvent(_onLogs2){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"AuthorityUpdated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs2(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event AuthorityUpdated for contract CoreMetadataModule
   */},{key:"parseTxAuthorityUpdatedEvent",value:function parseTxAuthorityUpdatedEvent(txReceipt){var targetLogs=[];var _iterator2=_createForOfIteratorHelper(txReceipt.logs),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var log=_step2.value;try{var event=viem.decodeEventLog({abi:coreMetadataModuleAbi,eventName:"AuthorityUpdated",data:log.data,topics:log.topics});if(event.eventName==="AuthorityUpdated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}return targetLogs;}/**
   * event Initialized for contract CoreMetadataModule
   */},{key:"watchInitializedEvent",value:function watchInitializedEvent(_onLogs3){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"Initialized",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs3(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Initialized for contract CoreMetadataModule
   */},{key:"parseTxInitializedEvent",value:function parseTxInitializedEvent(txReceipt){var targetLogs=[];var _iterator3=_createForOfIteratorHelper(txReceipt.logs),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var log=_step3.value;try{var event=viem.decodeEventLog({abi:coreMetadataModuleAbi,eventName:"Initialized",data:log.data,topics:log.topics});if(event.eventName==="Initialized"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}return targetLogs;}/**
   * event MetadataFrozen for contract CoreMetadataModule
   */},{key:"watchMetadataFrozenEvent",value:function watchMetadataFrozenEvent(_onLogs4){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"MetadataFrozen",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs4(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event MetadataFrozen for contract CoreMetadataModule
   */},{key:"parseTxMetadataFrozenEvent",value:function parseTxMetadataFrozenEvent(txReceipt){var targetLogs=[];var _iterator4=_createForOfIteratorHelper(txReceipt.logs),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var log=_step4.value;try{var event=viem.decodeEventLog({abi:coreMetadataModuleAbi,eventName:"MetadataFrozen",data:log.data,topics:log.topics});if(event.eventName==="MetadataFrozen"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}return targetLogs;}/**
   * event MetadataURISet for contract CoreMetadataModule
   */},{key:"watchMetadataUriSetEvent",value:function watchMetadataUriSetEvent(_onLogs5){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"MetadataURISet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs5(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event MetadataURISet for contract CoreMetadataModule
   */},{key:"parseTxMetadataUriSetEvent",value:function parseTxMetadataUriSetEvent(txReceipt){var targetLogs=[];var _iterator5=_createForOfIteratorHelper(txReceipt.logs),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var log=_step5.value;try{var event=viem.decodeEventLog({abi:coreMetadataModuleAbi,eventName:"MetadataURISet",data:log.data,topics:log.topics});if(event.eventName==="MetadataURISet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}return targetLogs;}/**
   * event NFTTokenURISet for contract CoreMetadataModule
   */},{key:"watchNftTokenUriSetEvent",value:function watchNftTokenUriSetEvent(_onLogs6){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"NFTTokenURISet",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs6(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event NFTTokenURISet for contract CoreMetadataModule
   */},{key:"parseTxNftTokenUriSetEvent",value:function parseTxNftTokenUriSetEvent(txReceipt){var targetLogs=[];var _iterator6=_createForOfIteratorHelper(txReceipt.logs),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var log=_step6.value;try{var event=viem.decodeEventLog({abi:coreMetadataModuleAbi,eventName:"NFTTokenURISet",data:log.data,topics:log.topics});if(event.eventName==="NFTTokenURISet"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}return targetLogs;}/**
   * event Upgraded for contract CoreMetadataModule
   */},{key:"watchUpgradedEvent",value:function watchUpgradedEvent(_onLogs7){return this.rpcClient.watchContractEvent({abi:coreMetadataModuleAbi,address:this.address,eventName:"Upgraded",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs7(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Upgraded for contract CoreMetadataModule
   */},{key:"parseTxUpgradedEvent",value:function parseTxUpgradedEvent(txReceipt){var targetLogs=[];var _iterator7=_createForOfIteratorHelper(txReceipt.logs),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var log=_step7.value;try{var event=viem.decodeEventLog({abi:coreMetadataModuleAbi,eventName:"Upgraded",data:log.data,topics:log.topics});if(event.eventName==="Upgraded"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}return targetLogs;}}]);}();/**
 * contract CoreMetadataModule readonly method
 */var CoreMetadataModuleReadOnlyClient=/*#__PURE__*/function(_CoreMetadataModuleEv){function CoreMetadataModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,CoreMetadataModuleReadOnlyClient);return _callSuper(this,CoreMetadataModuleReadOnlyClient,[rpcClient,address]);}/**
   * method ACCESS_CONTROLLER for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleAccessControllerRequest
   * @return Promise<CoreMetadataModuleAccessControllerResponse>
   */_inherits(CoreMetadataModuleReadOnlyClient,_CoreMetadataModuleEv);return _createClass(CoreMetadataModuleReadOnlyClient,[{key:"accessController",value:(function(){var _accessController=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(){return _regenerator().w(function(_context0){while(1)switch(_context0.n){case 0:_context0.n=1;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"ACCESS_CONTROLLER"});case 1:return _context0.a(2,_context0.v);}},_callee0,this);}));function accessController(){return _accessController.apply(this,arguments);}return accessController;}()/**
   * method IP_ASSET_REGISTRY for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleIpAssetRegistryRequest
   * @return Promise<CoreMetadataModuleIpAssetRegistryResponse>
   */)},{key:"ipAssetRegistry",value:(function(){var _ipAssetRegistry=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(){return _regenerator().w(function(_context1){while(1)switch(_context1.n){case 0:_context1.n=1;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"IP_ASSET_REGISTRY"});case 1:return _context1.a(2,_context1.v);}},_callee1,this);}));function ipAssetRegistry(){return _ipAssetRegistry.apply(this,arguments);}return ipAssetRegistry;}()/**
   * method UPGRADE_INTERFACE_VERSION for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleUpgradeInterfaceVersionRequest
   * @return Promise<CoreMetadataModuleUpgradeInterfaceVersionResponse>
   */)},{key:"upgradeInterfaceVersion",value:(function(){var _upgradeInterfaceVersion=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(){return _regenerator().w(function(_context10){while(1)switch(_context10.n){case 0:_context10.n=1;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"UPGRADE_INTERFACE_VERSION"});case 1:return _context10.a(2,_context10.v);}},_callee10,this);}));function upgradeInterfaceVersion(){return _upgradeInterfaceVersion.apply(this,arguments);}return upgradeInterfaceVersion;}()/**
   * method authority for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleAuthorityRequest
   * @return Promise<CoreMetadataModuleAuthorityResponse>
   */)},{key:"authority",value:(function(){var _authority=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(){return _regenerator().w(function(_context11){while(1)switch(_context11.n){case 0:_context11.n=1;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"authority"});case 1:return _context11.a(2,_context11.v);}},_callee11,this);}));function authority(){return _authority.apply(this,arguments);}return authority;}()/**
   * method isConsumingScheduledOp for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleIsConsumingScheduledOpRequest
   * @return Promise<CoreMetadataModuleIsConsumingScheduledOpResponse>
   */)},{key:"isConsumingScheduledOp",value:(function(){var _isConsumingScheduledOp=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(){return _regenerator().w(function(_context12){while(1)switch(_context12.n){case 0:_context12.n=1;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"isConsumingScheduledOp"});case 1:return _context12.a(2,_context12.v);}},_callee12,this);}));function isConsumingScheduledOp(){return _isConsumingScheduledOp.apply(this,arguments);}return isConsumingScheduledOp;}()/**
   * method isMetadataFrozen for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleIsMetadataFrozenRequest
   * @return Promise<CoreMetadataModuleIsMetadataFrozenResponse>
   */)},{key:"isMetadataFrozen",value:(function(){var _isMetadataFrozen=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(request){return _regenerator().w(function(_context13){while(1)switch(_context13.n){case 0:_context13.n=1;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"isMetadataFrozen",args:[request.ipId]});case 1:return _context13.a(2,_context13.v);}},_callee13,this);}));function isMetadataFrozen(_x7){return _isMetadataFrozen.apply(this,arguments);}return isMetadataFrozen;}()/**
   * method name for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleNameRequest
   * @return Promise<CoreMetadataModuleNameResponse>
   */)},{key:"name",value:(function(){var _name=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(){return _regenerator().w(function(_context14){while(1)switch(_context14.n){case 0:_context14.n=1;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"name"});case 1:return _context14.a(2,_context14.v);}},_callee14,this);}));function name(){return _name.apply(this,arguments);}return name;}()/**
   * method proxiableUUID for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleProxiableUuidRequest
   * @return Promise<CoreMetadataModuleProxiableUuidResponse>
   */)},{key:"proxiableUuid",value:(function(){var _proxiableUuid=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15(){return _regenerator().w(function(_context15){while(1)switch(_context15.n){case 0:_context15.n=1;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"proxiableUUID"});case 1:return _context15.a(2,_context15.v);}},_callee15,this);}));function proxiableUuid(){return _proxiableUuid.apply(this,arguments);}return proxiableUuid;}()/**
   * method supportsInterface for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSupportsInterfaceRequest
   * @return Promise<CoreMetadataModuleSupportsInterfaceResponse>
   */)},{key:"supportsInterface",value:(function(){var _supportsInterface=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(request){return _regenerator().w(function(_context16){while(1)switch(_context16.n){case 0:_context16.n=1;return this.rpcClient.readContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"supportsInterface",args:[request.interfaceId]});case 1:return _context16.a(2,_context16.v);}},_callee16,this);}));function supportsInterface(_x8){return _supportsInterface.apply(this,arguments);}return supportsInterface;}())}]);}(CoreMetadataModuleEventClient);/**
 * contract CoreMetadataModule write method
 */var CoreMetadataModuleClient=/*#__PURE__*/function(_CoreMetadataModuleRe){function CoreMetadataModuleClient(rpcClient,wallet,address){var _this3;_classCallCheck(this,CoreMetadataModuleClient);_this3=_callSuper(this,CoreMetadataModuleClient,[rpcClient,address]);_this3.wallet=wallet;return _this3;}/**
   * method freezeMetadata for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleFreezeMetadataRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(CoreMetadataModuleClient,_CoreMetadataModuleRe);return _createClass(CoreMetadataModuleClient,[{key:"freezeMetadata",value:(function(){var _freezeMetadata=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(request){var _yield$this$rpcClient5,call;return _regenerator().w(function(_context17){while(1)switch(_context17.n){case 0:_context17.n=1;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"freezeMetadata",account:this.wallet.account,args:[request.ipId]});case 1:_yield$this$rpcClient5=_context17.v;call=_yield$this$rpcClient5.request;_context17.n=2;return this.wallet.writeContract(call);case 2:return _context17.a(2,_context17.v);}},_callee17,this);}));function freezeMetadata(_x9){return _freezeMetadata.apply(this,arguments);}return freezeMetadata;}()/**
   * method freezeMetadata for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleFreezeMetadataRequest
   * @return EncodedTxData
   */)},{key:"freezeMetadataEncode",value:function freezeMetadataEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"freezeMetadata",args:[request.ipId]})};}/**
   * method initialize for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleInitializeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"initialize",value:(function(){var _initialize=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(request){var _yield$this$rpcClient6,call;return _regenerator().w(function(_context18){while(1)switch(_context18.n){case 0:_context18.n=1;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"initialize",account:this.wallet.account,args:[request.accessManager]});case 1:_yield$this$rpcClient6=_context18.v;call=_yield$this$rpcClient6.request;_context18.n=2;return this.wallet.writeContract(call);case 2:return _context18.a(2,_context18.v);}},_callee18,this);}));function initialize(_x0){return _initialize.apply(this,arguments);}return initialize;}()/**
   * method initialize for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleInitializeRequest
   * @return EncodedTxData
   */)},{key:"initializeEncode",value:function initializeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"initialize",args:[request.accessManager]})};}/**
   * method setAll for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSetAllRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAll",value:(function(){var _setAll=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(request){var _yield$this$rpcClient7,call;return _regenerator().w(function(_context19){while(1)switch(_context19.n){case 0:_context19.n=1;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"setAll",account:this.wallet.account,args:[request.ipId,request.metadataURI,request.metadataHash,request.nftMetadataHash]});case 1:_yield$this$rpcClient7=_context19.v;call=_yield$this$rpcClient7.request;_context19.n=2;return this.wallet.writeContract(call);case 2:return _context19.a(2,_context19.v);}},_callee19,this);}));function setAll(_x1){return _setAll.apply(this,arguments);}return setAll;}()/**
   * method setAll for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleSetAllRequest
   * @return EncodedTxData
   */)},{key:"setAllEncode",value:function setAllEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"setAll",args:[request.ipId,request.metadataURI,request.metadataHash,request.nftMetadataHash]})};}/**
   * method setAuthority for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSetAuthorityRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAuthority",value:(function(){var _setAuthority=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20(request){var _yield$this$rpcClient8,call;return _regenerator().w(function(_context20){while(1)switch(_context20.n){case 0:_context20.n=1;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"setAuthority",account:this.wallet.account,args:[request.newAuthority]});case 1:_yield$this$rpcClient8=_context20.v;call=_yield$this$rpcClient8.request;_context20.n=2;return this.wallet.writeContract(call);case 2:return _context20.a(2,_context20.v);}},_callee20,this);}));function setAuthority(_x10){return _setAuthority.apply(this,arguments);}return setAuthority;}()/**
   * method setAuthority for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleSetAuthorityRequest
   * @return EncodedTxData
   */)},{key:"setAuthorityEncode",value:function setAuthorityEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"setAuthority",args:[request.newAuthority]})};}/**
   * method setMetadataURI for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleSetMetadataUriRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setMetadataUri",value:(function(){var _setMetadataUri=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee21(request){var _yield$this$rpcClient9,call;return _regenerator().w(function(_context21){while(1)switch(_context21.n){case 0:_context21.n=1;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"setMetadataURI",account:this.wallet.account,args:[request.ipId,request.metadataURI,request.metadataHash]});case 1:_yield$this$rpcClient9=_context21.v;call=_yield$this$rpcClient9.request;_context21.n=2;return this.wallet.writeContract(call);case 2:return _context21.a(2,_context21.v);}},_callee21,this);}));function setMetadataUri(_x11){return _setMetadataUri.apply(this,arguments);}return setMetadataUri;}()/**
   * method setMetadataURI for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleSetMetadataUriRequest
   * @return EncodedTxData
   */)},{key:"setMetadataUriEncode",value:function setMetadataUriEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"setMetadataURI",args:[request.ipId,request.metadataURI,request.metadataHash]})};}/**
   * method updateNftTokenURI for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleUpdateNftTokenUriRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"updateNftTokenUri",value:(function(){var _updateNftTokenUri=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee22(request){var _yield$this$rpcClient0,call;return _regenerator().w(function(_context22){while(1)switch(_context22.n){case 0:_context22.n=1;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"updateNftTokenURI",account:this.wallet.account,args:[request.ipId,request.nftMetadataHash]});case 1:_yield$this$rpcClient0=_context22.v;call=_yield$this$rpcClient0.request;_context22.n=2;return this.wallet.writeContract(call);case 2:return _context22.a(2,_context22.v);}},_callee22,this);}));function updateNftTokenUri(_x12){return _updateNftTokenUri.apply(this,arguments);}return updateNftTokenUri;}()/**
   * method updateNftTokenURI for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleUpdateNftTokenUriRequest
   * @return EncodedTxData
   */)},{key:"updateNftTokenUriEncode",value:function updateNftTokenUriEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"updateNftTokenURI",args:[request.ipId,request.nftMetadataHash]})};}/**
   * method upgradeToAndCall for contract CoreMetadataModule
   *
   * @param request CoreMetadataModuleUpgradeToAndCallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"upgradeToAndCall",value:(function(){var _upgradeToAndCall=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee23(request){var _yield$this$rpcClient1,call;return _regenerator().w(function(_context23){while(1)switch(_context23.n){case 0:_context23.n=1;return this.rpcClient.simulateContract({abi:coreMetadataModuleAbi,address:this.address,functionName:"upgradeToAndCall",account:this.wallet.account,args:[request.newImplementation,request.data]});case 1:_yield$this$rpcClient1=_context23.v;call=_yield$this$rpcClient1.request;_context23.n=2;return this.wallet.writeContract(call);case 2:return _context23.a(2,_context23.v);}},_callee23,this);}));function upgradeToAndCall(_x13){return _upgradeToAndCall.apply(this,arguments);}return upgradeToAndCall;}()/**
   * method upgradeToAndCall for contract CoreMetadataModule with only encode
   *
   * @param request CoreMetadataModuleUpgradeToAndCallRequest
   * @return EncodedTxData
   */)},{key:"upgradeToAndCallEncode",value:function upgradeToAndCallEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:coreMetadataModuleAbi,functionName:"upgradeToAndCall",args:[request.newImplementation,request.data]})};}}]);}(CoreMetadataModuleReadOnlyClient);// Contract DerivativeWorkflows =============================================================
/**
 * DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeRequest
 *
 * @param spgNftContract address
 * @param derivData tuple
 * @param ipMetadata tuple
 * @param recipient address
 * @param allowDuplicates bool
 *//**
 * DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param spgNftContract address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param maxRts uint32
 * @param ipMetadata tuple
 * @param recipient address
 * @param allowDuplicates bool
 *//**
 * DerivativeWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * DerivativeWorkflowsRegisterIpAndMakeDerivativeRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param derivData tuple
 * @param ipMetadata tuple
 * @param sigMetadataAndRegister tuple
 *//**
 * DerivativeWorkflowsRegisterIpAndMakeDerivativeWithLicenseTokensRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param maxRts uint32
 * @param ipMetadata tuple
 * @param sigMetadataAndRegister tuple
 *//**
 * contract DerivativeWorkflows write method
 */var DerivativeWorkflowsClient=/*#__PURE__*/function(){function DerivativeWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain4;_classCallCheck(this,DerivativeWorkflowsClient);this.address=address||getAddress(derivativeWorkflowsAddress,(_rpcClient$chain4=rpcClient.chain)===null||_rpcClient$chain4===void 0?void 0:_rpcClient$chain4.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method mintAndRegisterIpAndMakeDerivative for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(DerivativeWorkflowsClient,[{key:"mintAndRegisterIpAndMakeDerivative",value:(function(){var _mintAndRegisterIpAndMakeDerivative=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee24(request){var _yield$this$rpcClient10,call;return _regenerator().w(function(_context24){while(1)switch(_context24.n){case 0:_context24.n=1;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndMakeDerivative",account:this.wallet.account,args:[request.spgNftContract,request.derivData,request.ipMetadata,request.recipient,request.allowDuplicates]});case 1:_yield$this$rpcClient10=_context24.v;call=_yield$this$rpcClient10.request;_context24.n=2;return this.wallet.writeContract(call);case 2:return _context24.a(2,_context24.v);}},_callee24,this);}));function mintAndRegisterIpAndMakeDerivative(_x14){return _mintAndRegisterIpAndMakeDerivative.apply(this,arguments);}return mintAndRegisterIpAndMakeDerivative;}()/**
   * method mintAndRegisterIpAndMakeDerivative for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndMakeDerivativeEncode",value:function mintAndRegisterIpAndMakeDerivativeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"mintAndRegisterIpAndMakeDerivative",args:[request.spgNftContract,request.derivData,request.ipMetadata,request.recipient,request.allowDuplicates]})};}/**
   * method mintAndRegisterIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",value:(function(){var _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee25(request){var _yield$this$rpcClient11,call;return _regenerator().w(function(_context25){while(1)switch(_context25.n){case 0:_context25.n=1;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",account:this.wallet.account,args:[request.spgNftContract,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.recipient,request.allowDuplicates]});case 1:_yield$this$rpcClient11=_context25.v;call=_yield$this$rpcClient11.request;_context25.n=2;return this.wallet.writeContract(call);case 2:return _context25.a(2,_context25.v);}},_callee25,this);}));function mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_x15){return _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens.apply(this,arguments);}return mintAndRegisterIpAndMakeDerivativeWithLicenseTokens;}()/**
   * method mintAndRegisterIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsMintAndRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode",value:function mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",args:[request.spgNftContract,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.recipient,request.allowDuplicates]})};}/**
   * method multicall for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee26(request){var _yield$this$rpcClient12,call;return _regenerator().w(function(_context26){while(1)switch(_context26.n){case 0:_context26.n=1;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 1:_yield$this$rpcClient12=_context26.v;call=_yield$this$rpcClient12.request;_context26.n=2;return this.wallet.writeContract(call);case 2:return _context26.a(2,_context26.v);}},_callee26,this);}));function multicall(_x16){return _multicall.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIpAndMakeDerivative for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndMakeDerivative",value:(function(){var _registerIpAndMakeDerivative=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee27(request){var _yield$this$rpcClient13,call;return _regenerator().w(function(_context27){while(1)switch(_context27.n){case 0:_context27.n=1;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"registerIpAndMakeDerivative",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.derivData,request.ipMetadata,request.sigMetadataAndRegister]});case 1:_yield$this$rpcClient13=_context27.v;call=_yield$this$rpcClient13.request;_context27.n=2;return this.wallet.writeContract(call);case 2:return _context27.a(2,_context27.v);}},_callee27,this);}));function registerIpAndMakeDerivative(_x17){return _registerIpAndMakeDerivative.apply(this,arguments);}return registerIpAndMakeDerivative;}()/**
   * method registerIpAndMakeDerivative for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndMakeDerivativeEncode",value:function registerIpAndMakeDerivativeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"registerIpAndMakeDerivative",args:[request.nftContract,request.tokenId,request.derivData,request.ipMetadata,request.sigMetadataAndRegister]})};}/**
   * method registerIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndMakeDerivativeWithLicenseTokens",value:(function(){var _registerIpAndMakeDerivativeWithLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee28(request){var _yield$this$rpcClient14,call;return _regenerator().w(function(_context28){while(1)switch(_context28.n){case 0:_context28.n=1;return this.rpcClient.simulateContract({abi:derivativeWorkflowsAbi,address:this.address,functionName:"registerIpAndMakeDerivativeWithLicenseTokens",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.sigMetadataAndRegister]});case 1:_yield$this$rpcClient14=_context28.v;call=_yield$this$rpcClient14.request;_context28.n=2;return this.wallet.writeContract(call);case 2:return _context28.a(2,_context28.v);}},_callee28,this);}));function registerIpAndMakeDerivativeWithLicenseTokens(_x18){return _registerIpAndMakeDerivativeWithLicenseTokens.apply(this,arguments);}return registerIpAndMakeDerivativeWithLicenseTokens;}()/**
   * method registerIpAndMakeDerivativeWithLicenseTokens for contract DerivativeWorkflows with only encode
   *
   * @param request DerivativeWorkflowsRegisterIpAndMakeDerivativeWithLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndMakeDerivativeWithLicenseTokensEncode",value:function registerIpAndMakeDerivativeWithLicenseTokensEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:derivativeWorkflowsAbi,functionName:"registerIpAndMakeDerivativeWithLicenseTokens",args:[request.nftContract,request.tokenId,request.licenseTokenIds,request.royaltyContext,request.maxRts,request.ipMetadata,request.sigMetadataAndRegister]})};}}]);}();// Contract DisputeModule =============================================================
/**
 * DisputeModuleDisputeCancelledEvent
 *
 * @param disputeId uint256
 * @param data bytes
 *//**
 * DisputeModuleDisputeRaisedEvent
 *
 * @param disputeId uint256
 * @param targetIpId address
 * @param disputeInitiator address
 * @param disputeTimestamp uint256
 * @param arbitrationPolicy address
 * @param disputeEvidenceHash bytes32
 * @param targetTag bytes32
 * @param data bytes
 *//**
 * DisputeModuleDisputeResolvedEvent
 *
 * @param disputeId uint256
 * @param data bytes
 *//**
 * DisputeModuleIsWhitelistedDisputeTagRequest
 *
 * @param tag bytes32
 *//**
 * DisputeModuleIsWhitelistedDisputeTagResponse
 *
 * @param allowed bool
 *//**
 * DisputeModuleCancelDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 *//**
 * DisputeModuleRaiseDisputeRequest
 *
 * @param targetIpId address
 * @param disputeEvidenceHash bytes32
 * @param targetTag bytes32
 * @param data bytes
 *//**
 * DisputeModuleResolveDisputeRequest
 *
 * @param disputeId uint256
 * @param data bytes
 *//**
 * DisputeModuleTagIfRelatedIpInfringedRequest
 *
 * @param ipIdToTag address
 * @param infringerDisputeId uint256
 *//**
 * contract DisputeModule event
 */var DisputeModuleEventClient=/*#__PURE__*/function(){function DisputeModuleEventClient(rpcClient,address){var _rpcClient$chain5;_classCallCheck(this,DisputeModuleEventClient);this.address=address||getAddress(disputeModuleAddress,(_rpcClient$chain5=rpcClient.chain)===null||_rpcClient$chain5===void 0?void 0:_rpcClient$chain5.id);this.rpcClient=rpcClient;}/**
   * event DisputeCancelled for contract DisputeModule
   */return _createClass(DisputeModuleEventClient,[{key:"watchDisputeCancelledEvent",value:function watchDisputeCancelledEvent(_onLogs8){return this.rpcClient.watchContractEvent({abi:disputeModuleAbi,address:this.address,eventName:"DisputeCancelled",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs8(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DisputeCancelled for contract DisputeModule
   */},{key:"parseTxDisputeCancelledEvent",value:function parseTxDisputeCancelledEvent(txReceipt){var targetLogs=[];var _iterator8=_createForOfIteratorHelper(txReceipt.logs),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var log=_step8.value;try{var event=viem.decodeEventLog({abi:disputeModuleAbi,eventName:"DisputeCancelled",data:log.data,topics:log.topics});if(event.eventName==="DisputeCancelled"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}return targetLogs;}/**
   * event DisputeRaised for contract DisputeModule
   */},{key:"watchDisputeRaisedEvent",value:function watchDisputeRaisedEvent(_onLogs9){return this.rpcClient.watchContractEvent({abi:disputeModuleAbi,address:this.address,eventName:"DisputeRaised",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs9(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DisputeRaised for contract DisputeModule
   */},{key:"parseTxDisputeRaisedEvent",value:function parseTxDisputeRaisedEvent(txReceipt){var targetLogs=[];var _iterator9=_createForOfIteratorHelper(txReceipt.logs),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var log=_step9.value;try{var event=viem.decodeEventLog({abi:disputeModuleAbi,eventName:"DisputeRaised",data:log.data,topics:log.topics});if(event.eventName==="DisputeRaised"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}return targetLogs;}/**
   * event DisputeResolved for contract DisputeModule
   */},{key:"watchDisputeResolvedEvent",value:function watchDisputeResolvedEvent(_onLogs0){return this.rpcClient.watchContractEvent({abi:disputeModuleAbi,address:this.address,eventName:"DisputeResolved",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs0(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DisputeResolved for contract DisputeModule
   */},{key:"parseTxDisputeResolvedEvent",value:function parseTxDisputeResolvedEvent(txReceipt){var targetLogs=[];var _iterator0=_createForOfIteratorHelper(txReceipt.logs),_step0;try{for(_iterator0.s();!(_step0=_iterator0.n()).done;){var log=_step0.value;try{var event=viem.decodeEventLog({abi:disputeModuleAbi,eventName:"DisputeResolved",data:log.data,topics:log.topics});if(event.eventName==="DisputeResolved"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator0.e(err);}finally{_iterator0.f();}return targetLogs;}}]);}();/**
 * contract DisputeModule readonly method
 */var DisputeModuleReadOnlyClient=/*#__PURE__*/function(_DisputeModuleEventCl){function DisputeModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,DisputeModuleReadOnlyClient);return _callSuper(this,DisputeModuleReadOnlyClient,[rpcClient,address]);}/**
   * method isWhitelistedDisputeTag for contract DisputeModule
   *
   * @param request DisputeModuleIsWhitelistedDisputeTagRequest
   * @return Promise<DisputeModuleIsWhitelistedDisputeTagResponse>
   */_inherits(DisputeModuleReadOnlyClient,_DisputeModuleEventCl);return _createClass(DisputeModuleReadOnlyClient,[{key:"isWhitelistedDisputeTag",value:(function(){var _isWhitelistedDisputeTag=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee29(request){var result;return _regenerator().w(function(_context29){while(1)switch(_context29.n){case 0:_context29.n=1;return this.rpcClient.readContract({abi:disputeModuleAbi,address:this.address,functionName:"isWhitelistedDisputeTag",args:[request.tag]});case 1:result=_context29.v;return _context29.a(2,{allowed:result});}},_callee29,this);}));function isWhitelistedDisputeTag(_x19){return _isWhitelistedDisputeTag.apply(this,arguments);}return isWhitelistedDisputeTag;}())}]);}(DisputeModuleEventClient);/**
 * contract DisputeModule write method
 */var DisputeModuleClient=/*#__PURE__*/function(_DisputeModuleReadOnl){function DisputeModuleClient(rpcClient,wallet,address){var _this4;_classCallCheck(this,DisputeModuleClient);_this4=_callSuper(this,DisputeModuleClient,[rpcClient,address]);_this4.wallet=wallet;return _this4;}/**
   * method cancelDispute for contract DisputeModule
   *
   * @param request DisputeModuleCancelDisputeRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(DisputeModuleClient,_DisputeModuleReadOnl);return _createClass(DisputeModuleClient,[{key:"cancelDispute",value:(function(){var _cancelDispute=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee30(request){var _yield$this$rpcClient15,call;return _regenerator().w(function(_context30){while(1)switch(_context30.n){case 0:_context30.n=1;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"cancelDispute",account:this.wallet.account,args:[request.disputeId,request.data]});case 1:_yield$this$rpcClient15=_context30.v;call=_yield$this$rpcClient15.request;_context30.n=2;return this.wallet.writeContract(call);case 2:return _context30.a(2,_context30.v);}},_callee30,this);}));function cancelDispute(_x20){return _cancelDispute.apply(this,arguments);}return cancelDispute;}()/**
   * method cancelDispute for contract DisputeModule with only encode
   *
   * @param request DisputeModuleCancelDisputeRequest
   * @return EncodedTxData
   */)},{key:"cancelDisputeEncode",value:function cancelDisputeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:disputeModuleAbi,functionName:"cancelDispute",args:[request.disputeId,request.data]})};}/**
   * method raiseDispute for contract DisputeModule
   *
   * @param request DisputeModuleRaiseDisputeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"raiseDispute",value:(function(){var _raiseDispute=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee31(request){var _yield$this$rpcClient16,call;return _regenerator().w(function(_context31){while(1)switch(_context31.n){case 0:_context31.n=1;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"raiseDispute",account:this.wallet.account,args:[request.targetIpId,request.disputeEvidenceHash,request.targetTag,request.data]});case 1:_yield$this$rpcClient16=_context31.v;call=_yield$this$rpcClient16.request;_context31.n=2;return this.wallet.writeContract(call);case 2:return _context31.a(2,_context31.v);}},_callee31,this);}));function raiseDispute(_x21){return _raiseDispute.apply(this,arguments);}return raiseDispute;}()/**
   * method raiseDispute for contract DisputeModule with only encode
   *
   * @param request DisputeModuleRaiseDisputeRequest
   * @return EncodedTxData
   */)},{key:"raiseDisputeEncode",value:function raiseDisputeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:disputeModuleAbi,functionName:"raiseDispute",args:[request.targetIpId,request.disputeEvidenceHash,request.targetTag,request.data]})};}/**
   * method resolveDispute for contract DisputeModule
   *
   * @param request DisputeModuleResolveDisputeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"resolveDispute",value:(function(){var _resolveDispute=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee32(request){var _yield$this$rpcClient17,call;return _regenerator().w(function(_context32){while(1)switch(_context32.n){case 0:_context32.n=1;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"resolveDispute",account:this.wallet.account,args:[request.disputeId,request.data]});case 1:_yield$this$rpcClient17=_context32.v;call=_yield$this$rpcClient17.request;_context32.n=2;return this.wallet.writeContract(call);case 2:return _context32.a(2,_context32.v);}},_callee32,this);}));function resolveDispute(_x22){return _resolveDispute.apply(this,arguments);}return resolveDispute;}()/**
   * method resolveDispute for contract DisputeModule with only encode
   *
   * @param request DisputeModuleResolveDisputeRequest
   * @return EncodedTxData
   */)},{key:"resolveDisputeEncode",value:function resolveDisputeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:disputeModuleAbi,functionName:"resolveDispute",args:[request.disputeId,request.data]})};}/**
   * method tagIfRelatedIpInfringed for contract DisputeModule
   *
   * @param request DisputeModuleTagIfRelatedIpInfringedRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"tagIfRelatedIpInfringed",value:(function(){var _tagIfRelatedIpInfringed=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee33(request){var _yield$this$rpcClient18,call;return _regenerator().w(function(_context33){while(1)switch(_context33.n){case 0:_context33.n=1;return this.rpcClient.simulateContract({abi:disputeModuleAbi,address:this.address,functionName:"tagIfRelatedIpInfringed",account:this.wallet.account,args:[request.ipIdToTag,request.infringerDisputeId]});case 1:_yield$this$rpcClient18=_context33.v;call=_yield$this$rpcClient18.request;_context33.n=2;return this.wallet.writeContract(call);case 2:return _context33.a(2,_context33.v);}},_callee33,this);}));function tagIfRelatedIpInfringed(_x23){return _tagIfRelatedIpInfringed.apply(this,arguments);}return tagIfRelatedIpInfringed;}()/**
   * method tagIfRelatedIpInfringed for contract DisputeModule with only encode
   *
   * @param request DisputeModuleTagIfRelatedIpInfringedRequest
   * @return EncodedTxData
   */)},{key:"tagIfRelatedIpInfringedEncode",value:function tagIfRelatedIpInfringedEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:disputeModuleAbi,functionName:"tagIfRelatedIpInfringed",args:[request.ipIdToTag,request.infringerDisputeId]})};}}]);}(DisputeModuleReadOnlyClient);// Contract ERC20 =============================================================
/**
 * Erc20AllowanceRequest
 *
 * @param owner address
 * @param spender address
 *//**
 * Erc20BalanceOfRequest
 *
 * @param account address
 *//**
 * Erc20ApproveRequest
 *
 * @param spender address
 * @param value uint256
 *//**
 * Erc20MintRequest
 *
 * @param to address
 * @param amount uint256
 *//**
 * Erc20TransferRequest
 *
 * @param to address
 * @param value uint256
 *//**
 * Erc20TransferFromRequest
 *
 * @param from address
 * @param to address
 * @param value uint256
 *//**
 * contract ERC20 readonly method
 */var Erc20ReadOnlyClient=/*#__PURE__*/function(){function Erc20ReadOnlyClient(rpcClient,address){var _rpcClient$chain6;_classCallCheck(this,Erc20ReadOnlyClient);this.address=address||getAddress(erc20Address,(_rpcClient$chain6=rpcClient.chain)===null||_rpcClient$chain6===void 0?void 0:_rpcClient$chain6.id);this.rpcClient=rpcClient;}/**
   * method allowance for contract ERC20
   *
   * @param request Erc20AllowanceRequest
   * @return Promise<Erc20AllowanceResponse>
   */return _createClass(Erc20ReadOnlyClient,[{key:"allowance",value:(function(){var _allowance=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee34(request){return _regenerator().w(function(_context34){while(1)switch(_context34.n){case 0:_context34.n=1;return this.rpcClient.readContract({abi:erc20Abi,address:this.address,functionName:"allowance",args:[request.owner,request.spender]});case 1:return _context34.a(2,_context34.v);}},_callee34,this);}));function allowance(_x24){return _allowance.apply(this,arguments);}return allowance;}()/**
   * method balanceOf for contract ERC20
   *
   * @param request Erc20BalanceOfRequest
   * @return Promise<Erc20BalanceOfResponse>
   */)},{key:"balanceOf",value:(function(){var _balanceOf=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee35(request){return _regenerator().w(function(_context35){while(1)switch(_context35.n){case 0:_context35.n=1;return this.rpcClient.readContract({abi:erc20Abi,address:this.address,functionName:"balanceOf",args:[request.account]});case 1:return _context35.a(2,_context35.v);}},_callee35,this);}));function balanceOf(_x25){return _balanceOf.apply(this,arguments);}return balanceOf;}())}]);}();/**
 * contract ERC20 write method
 */var Erc20Client=/*#__PURE__*/function(_Erc20ReadOnlyClient){function Erc20Client(rpcClient,wallet,address){var _this5;_classCallCheck(this,Erc20Client);_this5=_callSuper(this,Erc20Client,[rpcClient,address]);_this5.wallet=wallet;return _this5;}/**
   * method approve for contract ERC20
   *
   * @param request Erc20ApproveRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(Erc20Client,_Erc20ReadOnlyClient);return _createClass(Erc20Client,[{key:"approve",value:(function(){var _approve=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee36(request){var _yield$this$rpcClient19,call;return _regenerator().w(function(_context36){while(1)switch(_context36.n){case 0:_context36.n=1;return this.rpcClient.simulateContract({abi:erc20Abi,address:this.address,functionName:"approve",account:this.wallet.account,args:[request.spender,request.value]});case 1:_yield$this$rpcClient19=_context36.v;call=_yield$this$rpcClient19.request;_context36.n=2;return this.wallet.writeContract(call);case 2:return _context36.a(2,_context36.v);}},_callee36,this);}));function approve(_x26){return _approve.apply(this,arguments);}return approve;}()/**
   * method approve for contract ERC20 with only encode
   *
   * @param request Erc20ApproveRequest
   * @return EncodedTxData
   */)},{key:"approveEncode",value:function approveEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:erc20Abi,functionName:"approve",args:[request.spender,request.value]})};}/**
   * method mint for contract ERC20
   *
   * @param request Erc20MintRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mint",value:(function(){var _mint=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee37(request){var _yield$this$rpcClient20,call;return _regenerator().w(function(_context37){while(1)switch(_context37.n){case 0:_context37.n=1;return this.rpcClient.simulateContract({abi:erc20Abi,address:this.address,functionName:"mint",account:this.wallet.account,args:[request.to,request.amount]});case 1:_yield$this$rpcClient20=_context37.v;call=_yield$this$rpcClient20.request;_context37.n=2;return this.wallet.writeContract(call);case 2:return _context37.a(2,_context37.v);}},_callee37,this);}));function mint(_x27){return _mint.apply(this,arguments);}return mint;}()/**
   * method mint for contract ERC20 with only encode
   *
   * @param request Erc20MintRequest
   * @return EncodedTxData
   */)},{key:"mintEncode",value:function mintEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:erc20Abi,functionName:"mint",args:[request.to,request.amount]})};}/**
   * method transfer for contract ERC20
   *
   * @param request Erc20TransferRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transfer",value:(function(){var _transfer=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee38(request){var _yield$this$rpcClient21,call;return _regenerator().w(function(_context38){while(1)switch(_context38.n){case 0:_context38.n=1;return this.rpcClient.simulateContract({abi:erc20Abi,address:this.address,functionName:"transfer",account:this.wallet.account,args:[request.to,request.value]});case 1:_yield$this$rpcClient21=_context38.v;call=_yield$this$rpcClient21.request;_context38.n=2;return this.wallet.writeContract(call);case 2:return _context38.a(2,_context38.v);}},_callee38,this);}));function transfer(_x28){return _transfer.apply(this,arguments);}return transfer;}()/**
   * method transfer for contract ERC20 with only encode
   *
   * @param request Erc20TransferRequest
   * @return EncodedTxData
   */)},{key:"transferEncode",value:function transferEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:erc20Abi,functionName:"transfer",args:[request.to,request.value]})};}/**
   * method transferFrom for contract ERC20
   *
   * @param request Erc20TransferFromRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transferFrom",value:(function(){var _transferFrom=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee39(request){var _yield$this$rpcClient22,call;return _regenerator().w(function(_context39){while(1)switch(_context39.n){case 0:_context39.n=1;return this.rpcClient.simulateContract({abi:erc20Abi,address:this.address,functionName:"transferFrom",account:this.wallet.account,args:[request.from,request.to,request.value]});case 1:_yield$this$rpcClient22=_context39.v;call=_yield$this$rpcClient22.request;_context39.n=2;return this.wallet.writeContract(call);case 2:return _context39.a(2,_context39.v);}},_callee39,this);}));function transferFrom(_x29){return _transferFrom.apply(this,arguments);}return transferFrom;}()/**
   * method transferFrom for contract ERC20 with only encode
   *
   * @param request Erc20TransferFromRequest
   * @return EncodedTxData
   */)},{key:"transferFromEncode",value:function transferFromEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:erc20Abi,functionName:"transferFrom",args:[request.from,request.to,request.value]})};}}]);}(Erc20ReadOnlyClient);// Contract EvenSplitGroupPool =============================================================
/**
 * GroupingModuleClaimedRewardEvent
 *
 * @param groupId address
 * @param token address
 * @param ipId address[]
 * @param amount uint256[]
 *//**
 * GroupingModuleCollectedRoyaltiesToGroupPoolEvent
 *
 * @param groupId address
 * @param token address
 * @param pool address
 * @param amount uint256
 *//**
 * GroupingModuleIpGroupRegisteredEvent
 *
 * @param groupId address
 * @param groupPool address
 *//**
 * GroupingModuleGetClaimableRewardRequest
 *
 * @param groupId address
 * @param token address
 * @param ipIds address[]
 *//**
 * GroupingModuleAddIpRequest
 *
 * @param groupIpId address
 * @param ipIds address[]
 * @param maxAllowedRewardShare uint256
 *//**
 * GroupingModuleClaimRewardRequest
 *
 * @param groupId address
 * @param token address
 * @param ipIds address[]
 *//**
 * GroupingModuleCollectRoyaltiesRequest
 *
 * @param groupId address
 * @param token address
 *//**
 * GroupingModuleRegisterGroupRequest
 *
 * @param groupPool address
 *//**
 * GroupingModuleRemoveIpRequest
 *
 * @param groupIpId address
 * @param ipIds address[]
 *//**
 * contract GroupingModule event
 */var GroupingModuleEventClient=/*#__PURE__*/function(){function GroupingModuleEventClient(rpcClient,address){var _rpcClient$chain8;_classCallCheck(this,GroupingModuleEventClient);this.address=address||getAddress(groupingModuleAddress,(_rpcClient$chain8=rpcClient.chain)===null||_rpcClient$chain8===void 0?void 0:_rpcClient$chain8.id);this.rpcClient=rpcClient;}/**
   * event ClaimedReward for contract GroupingModule
   */return _createClass(GroupingModuleEventClient,[{key:"watchClaimedRewardEvent",value:function watchClaimedRewardEvent(_onLogs14){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"ClaimedReward",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs14(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event ClaimedReward for contract GroupingModule
   */},{key:"parseTxClaimedRewardEvent",value:function parseTxClaimedRewardEvent(txReceipt){var targetLogs=[];var _iterator14=_createForOfIteratorHelper(txReceipt.logs),_step14;try{for(_iterator14.s();!(_step14=_iterator14.n()).done;){var log=_step14.value;try{var event=viem.decodeEventLog({abi:groupingModuleAbi,eventName:"ClaimedReward",data:log.data,topics:log.topics});if(event.eventName==="ClaimedReward"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator14.e(err);}finally{_iterator14.f();}return targetLogs;}/**
   * event CollectedRoyaltiesToGroupPool for contract GroupingModule
   */},{key:"watchCollectedRoyaltiesToGroupPoolEvent",value:function watchCollectedRoyaltiesToGroupPoolEvent(_onLogs15){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"CollectedRoyaltiesToGroupPool",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs15(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event CollectedRoyaltiesToGroupPool for contract GroupingModule
   */},{key:"parseTxCollectedRoyaltiesToGroupPoolEvent",value:function parseTxCollectedRoyaltiesToGroupPoolEvent(txReceipt){var targetLogs=[];var _iterator15=_createForOfIteratorHelper(txReceipt.logs),_step15;try{for(_iterator15.s();!(_step15=_iterator15.n()).done;){var log=_step15.value;try{var event=viem.decodeEventLog({abi:groupingModuleAbi,eventName:"CollectedRoyaltiesToGroupPool",data:log.data,topics:log.topics});if(event.eventName==="CollectedRoyaltiesToGroupPool"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator15.e(err);}finally{_iterator15.f();}return targetLogs;}/**
   * event IPGroupRegistered for contract GroupingModule
   */},{key:"watchIpGroupRegisteredEvent",value:function watchIpGroupRegisteredEvent(_onLogs16){return this.rpcClient.watchContractEvent({abi:groupingModuleAbi,address:this.address,eventName:"IPGroupRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs16(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IPGroupRegistered for contract GroupingModule
   */},{key:"parseTxIpGroupRegisteredEvent",value:function parseTxIpGroupRegisteredEvent(txReceipt){var targetLogs=[];var _iterator16=_createForOfIteratorHelper(txReceipt.logs),_step16;try{for(_iterator16.s();!(_step16=_iterator16.n()).done;){var log=_step16.value;try{var event=viem.decodeEventLog({abi:groupingModuleAbi,eventName:"IPGroupRegistered",data:log.data,topics:log.topics});if(event.eventName==="IPGroupRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator16.e(err);}finally{_iterator16.f();}return targetLogs;}}]);}();/**
 * contract GroupingModule readonly method
 */var GroupingModuleReadOnlyClient=/*#__PURE__*/function(_GroupingModuleEventC){function GroupingModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,GroupingModuleReadOnlyClient);return _callSuper(this,GroupingModuleReadOnlyClient,[rpcClient,address]);}/**
   * method getClaimableReward for contract GroupingModule
   *
   * @param request GroupingModuleGetClaimableRewardRequest
   * @return Promise<GroupingModuleGetClaimableRewardResponse>
   */_inherits(GroupingModuleReadOnlyClient,_GroupingModuleEventC);return _createClass(GroupingModuleReadOnlyClient,[{key:"getClaimableReward",value:(function(){var _getClaimableReward=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee66(request){return _regenerator().w(function(_context66){while(1)switch(_context66.n){case 0:_context66.n=1;return this.rpcClient.readContract({abi:groupingModuleAbi,address:this.address,functionName:"getClaimableReward",args:[request.groupId,request.token,request.ipIds]});case 1:return _context66.a(2,_context66.v);}},_callee66,this);}));function getClaimableReward(_x45){return _getClaimableReward.apply(this,arguments);}return getClaimableReward;}())}]);}(GroupingModuleEventClient);/**
 * contract GroupingModule write method
 */var GroupingModuleClient=/*#__PURE__*/function(_GroupingModuleReadOn){function GroupingModuleClient(rpcClient,wallet,address){var _this7;_classCallCheck(this,GroupingModuleClient);_this7=_callSuper(this,GroupingModuleClient,[rpcClient,address]);_this7.wallet=wallet;return _this7;}/**
   * method addIp for contract GroupingModule
   *
   * @param request GroupingModuleAddIpRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(GroupingModuleClient,_GroupingModuleReadOn);return _createClass(GroupingModuleClient,[{key:"addIp",value:(function(){var _addIp2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee67(request){var _yield$this$rpcClient33,call;return _regenerator().w(function(_context67){while(1)switch(_context67.n){case 0:_context67.n=1;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"addIp",account:this.wallet.account,args:[request.groupIpId,request.ipIds,request.maxAllowedRewardShare]});case 1:_yield$this$rpcClient33=_context67.v;call=_yield$this$rpcClient33.request;_context67.n=2;return this.wallet.writeContract(call);case 2:return _context67.a(2,_context67.v);}},_callee67,this);}));function addIp(_x46){return _addIp2.apply(this,arguments);}return addIp;}()/**
   * method addIp for contract GroupingModule with only encode
   *
   * @param request GroupingModuleAddIpRequest
   * @return EncodedTxData
   */)},{key:"addIpEncode",value:function addIpEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingModuleAbi,functionName:"addIp",args:[request.groupIpId,request.ipIds,request.maxAllowedRewardShare]})};}/**
   * method claimReward for contract GroupingModule
   *
   * @param request GroupingModuleClaimRewardRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"claimReward",value:(function(){var _claimReward=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee68(request){var _yield$this$rpcClient34,call;return _regenerator().w(function(_context68){while(1)switch(_context68.n){case 0:_context68.n=1;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"claimReward",account:this.wallet.account,args:[request.groupId,request.token,request.ipIds]});case 1:_yield$this$rpcClient34=_context68.v;call=_yield$this$rpcClient34.request;_context68.n=2;return this.wallet.writeContract(call);case 2:return _context68.a(2,_context68.v);}},_callee68,this);}));function claimReward(_x47){return _claimReward.apply(this,arguments);}return claimReward;}()/**
   * method claimReward for contract GroupingModule with only encode
   *
   * @param request GroupingModuleClaimRewardRequest
   * @return EncodedTxData
   */)},{key:"claimRewardEncode",value:function claimRewardEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingModuleAbi,functionName:"claimReward",args:[request.groupId,request.token,request.ipIds]})};}/**
   * method collectRoyalties for contract GroupingModule
   *
   * @param request GroupingModuleCollectRoyaltiesRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"collectRoyalties",value:(function(){var _collectRoyalties=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee69(request){var _yield$this$rpcClient35,call;return _regenerator().w(function(_context69){while(1)switch(_context69.n){case 0:_context69.n=1;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"collectRoyalties",account:this.wallet.account,args:[request.groupId,request.token]});case 1:_yield$this$rpcClient35=_context69.v;call=_yield$this$rpcClient35.request;_context69.n=2;return this.wallet.writeContract(call);case 2:return _context69.a(2,_context69.v);}},_callee69,this);}));function collectRoyalties(_x48){return _collectRoyalties.apply(this,arguments);}return collectRoyalties;}()/**
   * method collectRoyalties for contract GroupingModule with only encode
   *
   * @param request GroupingModuleCollectRoyaltiesRequest
   * @return EncodedTxData
   */)},{key:"collectRoyaltiesEncode",value:function collectRoyaltiesEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingModuleAbi,functionName:"collectRoyalties",args:[request.groupId,request.token]})};}/**
   * method registerGroup for contract GroupingModule
   *
   * @param request GroupingModuleRegisterGroupRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerGroup",value:(function(){var _registerGroup=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee70(request){var _yield$this$rpcClient36,call;return _regenerator().w(function(_context70){while(1)switch(_context70.n){case 0:_context70.n=1;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"registerGroup",account:this.wallet.account,args:[request.groupPool]});case 1:_yield$this$rpcClient36=_context70.v;call=_yield$this$rpcClient36.request;_context70.n=2;return this.wallet.writeContract(call);case 2:return _context70.a(2,_context70.v);}},_callee70,this);}));function registerGroup(_x49){return _registerGroup.apply(this,arguments);}return registerGroup;}()/**
   * method registerGroup for contract GroupingModule with only encode
   *
   * @param request GroupingModuleRegisterGroupRequest
   * @return EncodedTxData
   */)},{key:"registerGroupEncode",value:function registerGroupEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingModuleAbi,functionName:"registerGroup",args:[request.groupPool]})};}/**
   * method removeIp for contract GroupingModule
   *
   * @param request GroupingModuleRemoveIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"removeIp",value:(function(){var _removeIp2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee71(request){var _yield$this$rpcClient37,call;return _regenerator().w(function(_context71){while(1)switch(_context71.n){case 0:_context71.n=1;return this.rpcClient.simulateContract({abi:groupingModuleAbi,address:this.address,functionName:"removeIp",account:this.wallet.account,args:[request.groupIpId,request.ipIds]});case 1:_yield$this$rpcClient37=_context71.v;call=_yield$this$rpcClient37.request;_context71.n=2;return this.wallet.writeContract(call);case 2:return _context71.a(2,_context71.v);}},_callee71,this);}));function removeIp(_x50){return _removeIp2.apply(this,arguments);}return removeIp;}()/**
   * method removeIp for contract GroupingModule with only encode
   *
   * @param request GroupingModuleRemoveIpRequest
   * @return EncodedTxData
   */)},{key:"removeIpEncode",value:function removeIpEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingModuleAbi,functionName:"removeIp",args:[request.groupIpId,request.ipIds]})};}}]);}(GroupingModuleReadOnlyClient);// Contract GroupingWorkflows =============================================================
/**
 * GroupingWorkflowsCollectRoyaltiesAndClaimRewardRequest
 *
 * @param groupIpId address
 * @param currencyTokens address[]
 * @param memberIpIds address[]
 *//**
 * GroupingWorkflowsMintAndRegisterIpAndAttachLicenseAndAddToGroupRequest
 *
 * @param spgNftContract address
 * @param groupId address
 * @param recipient address
 * @param maxAllowedRewardShare uint256
 * @param licensesData tuple[]
 * @param ipMetadata tuple
 * @param sigAddToGroup tuple
 * @param allowDuplicates bool
 *//**
 * GroupingWorkflowsRegisterGroupAndAttachLicenseRequest
 *
 * @param groupPool address
 * @param licenseData tuple
 *//**
 * GroupingWorkflowsRegisterGroupAndAttachLicenseAndAddIpsRequest
 *
 * @param groupPool address
 * @param ipIds address[]
 * @param maxAllowedRewardShare uint256
 * @param licenseData tuple
 *//**
 * GroupingWorkflowsRegisterIpAndAttachLicenseAndAddToGroupRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param groupId address
 * @param maxAllowedRewardShare uint256
 * @param licensesData tuple[]
 * @param ipMetadata tuple
 * @param sigMetadataAndAttachAndConfig tuple
 * @param sigAddToGroup tuple
 *//**
 * contract GroupingWorkflows write method
 */var GroupingWorkflowsClient=/*#__PURE__*/function(){function GroupingWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain9;_classCallCheck(this,GroupingWorkflowsClient);this.address=address||getAddress(groupingWorkflowsAddress,(_rpcClient$chain9=rpcClient.chain)===null||_rpcClient$chain9===void 0?void 0:_rpcClient$chain9.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method collectRoyaltiesAndClaimReward for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsCollectRoyaltiesAndClaimRewardRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(GroupingWorkflowsClient,[{key:"collectRoyaltiesAndClaimReward",value:(function(){var _collectRoyaltiesAndClaimReward=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee72(request){var _yield$this$rpcClient38,call;return _regenerator().w(function(_context72){while(1)switch(_context72.n){case 0:_context72.n=1;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"collectRoyaltiesAndClaimReward",account:this.wallet.account,args:[request.groupIpId,request.currencyTokens,request.memberIpIds]});case 1:_yield$this$rpcClient38=_context72.v;call=_yield$this$rpcClient38.request;_context72.n=2;return this.wallet.writeContract(call);case 2:return _context72.a(2,_context72.v);}},_callee72,this);}));function collectRoyaltiesAndClaimReward(_x51){return _collectRoyaltiesAndClaimReward.apply(this,arguments);}return collectRoyaltiesAndClaimReward;}()/**
   * method collectRoyaltiesAndClaimReward for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsCollectRoyaltiesAndClaimRewardRequest
   * @return EncodedTxData
   */)},{key:"collectRoyaltiesAndClaimRewardEncode",value:function collectRoyaltiesAndClaimRewardEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"collectRoyaltiesAndClaimReward",args:[request.groupIpId,request.currencyTokens,request.memberIpIds]})};}/**
   * method mintAndRegisterIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsMintAndRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",value:(function(){var _mintAndRegisterIpAndAttachLicenseAndAddToGroup=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee73(request){var _yield$this$rpcClient39,call;return _regenerator().w(function(_context73){while(1)switch(_context73.n){case 0:_context73.n=1;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",account:this.wallet.account,args:[request.spgNftContract,request.groupId,request.recipient,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigAddToGroup,request.allowDuplicates]});case 1:_yield$this$rpcClient39=_context73.v;call=_yield$this$rpcClient39.request;_context73.n=2;return this.wallet.writeContract(call);case 2:return _context73.a(2,_context73.v);}},_callee73,this);}));function mintAndRegisterIpAndAttachLicenseAndAddToGroup(_x52){return _mintAndRegisterIpAndAttachLicenseAndAddToGroup.apply(this,arguments);}return mintAndRegisterIpAndAttachLicenseAndAddToGroup;}()/**
   * method mintAndRegisterIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsMintAndRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndAttachLicenseAndAddToGroupEncode",value:function mintAndRegisterIpAndAttachLicenseAndAddToGroupEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"mintAndRegisterIpAndAttachLicenseAndAddToGroup",args:[request.spgNftContract,request.groupId,request.recipient,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigAddToGroup,request.allowDuplicates]})};}/**
   * method registerGroupAndAttachLicense for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerGroupAndAttachLicense",value:(function(){var _registerGroupAndAttachLicense=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee74(request){var _yield$this$rpcClient40,call;return _regenerator().w(function(_context74){while(1)switch(_context74.n){case 0:_context74.n=1;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"registerGroupAndAttachLicense",account:this.wallet.account,args:[request.groupPool,request.licenseData]});case 1:_yield$this$rpcClient40=_context74.v;call=_yield$this$rpcClient40.request;_context74.n=2;return this.wallet.writeContract(call);case 2:return _context74.a(2,_context74.v);}},_callee74,this);}));function registerGroupAndAttachLicense(_x53){return _registerGroupAndAttachLicense.apply(this,arguments);}return registerGroupAndAttachLicense;}()/**
   * method registerGroupAndAttachLicense for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseRequest
   * @return EncodedTxData
   */)},{key:"registerGroupAndAttachLicenseEncode",value:function registerGroupAndAttachLicenseEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"registerGroupAndAttachLicense",args:[request.groupPool,request.licenseData]})};}/**
   * method registerGroupAndAttachLicenseAndAddIps for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseAndAddIpsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerGroupAndAttachLicenseAndAddIps",value:(function(){var _registerGroupAndAttachLicenseAndAddIps=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee75(request){var _yield$this$rpcClient41,call;return _regenerator().w(function(_context75){while(1)switch(_context75.n){case 0:_context75.n=1;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"registerGroupAndAttachLicenseAndAddIps",account:this.wallet.account,args:[request.groupPool,request.ipIds,request.maxAllowedRewardShare,request.licenseData]});case 1:_yield$this$rpcClient41=_context75.v;call=_yield$this$rpcClient41.request;_context75.n=2;return this.wallet.writeContract(call);case 2:return _context75.a(2,_context75.v);}},_callee75,this);}));function registerGroupAndAttachLicenseAndAddIps(_x54){return _registerGroupAndAttachLicenseAndAddIps.apply(this,arguments);}return registerGroupAndAttachLicenseAndAddIps;}()/**
   * method registerGroupAndAttachLicenseAndAddIps for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsRegisterGroupAndAttachLicenseAndAddIpsRequest
   * @return EncodedTxData
   */)},{key:"registerGroupAndAttachLicenseAndAddIpsEncode",value:function registerGroupAndAttachLicenseAndAddIpsEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"registerGroupAndAttachLicenseAndAddIps",args:[request.groupPool,request.ipIds,request.maxAllowedRewardShare,request.licenseData]})};}/**
   * method registerIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows
   *
   * @param request GroupingWorkflowsRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndAttachLicenseAndAddToGroup",value:(function(){var _registerIpAndAttachLicenseAndAddToGroup=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee76(request){var _yield$this$rpcClient42,call;return _regenerator().w(function(_context76){while(1)switch(_context76.n){case 0:_context76.n=1;return this.rpcClient.simulateContract({abi:groupingWorkflowsAbi,address:this.address,functionName:"registerIpAndAttachLicenseAndAddToGroup",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.groupId,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigMetadataAndAttachAndConfig,request.sigAddToGroup]});case 1:_yield$this$rpcClient42=_context76.v;call=_yield$this$rpcClient42.request;_context76.n=2;return this.wallet.writeContract(call);case 2:return _context76.a(2,_context76.v);}},_callee76,this);}));function registerIpAndAttachLicenseAndAddToGroup(_x55){return _registerIpAndAttachLicenseAndAddToGroup.apply(this,arguments);}return registerIpAndAttachLicenseAndAddToGroup;}()/**
   * method registerIpAndAttachLicenseAndAddToGroup for contract GroupingWorkflows with only encode
   *
   * @param request GroupingWorkflowsRegisterIpAndAttachLicenseAndAddToGroupRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndAttachLicenseAndAddToGroupEncode",value:function registerIpAndAttachLicenseAndAddToGroupEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:groupingWorkflowsAbi,functionName:"registerIpAndAttachLicenseAndAddToGroup",args:[request.nftContract,request.tokenId,request.groupId,request.maxAllowedRewardShare,request.licensesData,request.ipMetadata,request.sigMetadataAndAttachAndConfig,request.sigAddToGroup]})};}}]);}();// Contract IPAccountImpl =============================================================
/**
 * IpAccountImplStateResponse
 *
 * @param result bytes32
 *//**
 * IpAccountImplTokenResponse
 *
 * @param 0 uint256
 * @param 1 address
 * @param 2 uint256
 *//**
 * IpAccountImplExecuteRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 * @param operation uint8
 *//**
 * IpAccountImplExecute2Request
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 *//**
 * IpAccountImplExecuteBatchRequest
 *
 * @param calls tuple[]
 * @param operation uint8
 *//**
 * IpAccountImplExecuteWithSigRequest
 *
 * @param to address
 * @param value uint256
 * @param data bytes
 * @param signer address
 * @param deadline uint256
 * @param signature bytes
 *//**
 * contract IPAccountImpl readonly method
 */var IpAccountImplReadOnlyClient=/*#__PURE__*/function(){function IpAccountImplReadOnlyClient(rpcClient,address){var _rpcClient$chain0;_classCallCheck(this,IpAccountImplReadOnlyClient);this.address=address||getAddress(ipAccountImplAddress,(_rpcClient$chain0=rpcClient.chain)===null||_rpcClient$chain0===void 0?void 0:_rpcClient$chain0.id);this.rpcClient=rpcClient;}/**
   * method owner for contract IPAccountImpl
   *
   * @param request IpAccountImplOwnerRequest
   * @return Promise<IpAccountImplOwnerResponse>
   */return _createClass(IpAccountImplReadOnlyClient,[{key:"owner",value:(function(){var _owner=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee77(){return _regenerator().w(function(_context77){while(1)switch(_context77.n){case 0:_context77.n=1;return this.rpcClient.readContract({abi:ipAccountImplAbi,address:this.address,functionName:"owner"});case 1:return _context77.a(2,_context77.v);}},_callee77,this);}));function owner(){return _owner.apply(this,arguments);}return owner;}()/**
   * method state for contract IPAccountImpl
   *
   * @param request IpAccountImplStateRequest
   * @return Promise<IpAccountImplStateResponse>
   */)},{key:"state",value:(function(){var _state=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee78(){var result;return _regenerator().w(function(_context78){while(1)switch(_context78.n){case 0:_context78.n=1;return this.rpcClient.readContract({abi:ipAccountImplAbi,address:this.address,functionName:"state"});case 1:result=_context78.v;return _context78.a(2,{result:result});}},_callee78,this);}));function state(){return _state.apply(this,arguments);}return state;}()/**
   * method token for contract IPAccountImpl
   *
   * @param request IpAccountImplTokenRequest
   * @return Promise<IpAccountImplTokenResponse>
   */)},{key:"token",value:(function(){var _token=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee79(){return _regenerator().w(function(_context79){while(1)switch(_context79.n){case 0:_context79.n=1;return this.rpcClient.readContract({abi:ipAccountImplAbi,address:this.address,functionName:"token"});case 1:return _context79.a(2,_context79.v);}},_callee79,this);}));function token(){return _token.apply(this,arguments);}return token;}())}]);}();/**
 * contract IPAccountImpl write method
 */var IpAccountImplClient=/*#__PURE__*/function(_IpAccountImplReadOnl){function IpAccountImplClient(rpcClient,wallet,address){var _this8;_classCallCheck(this,IpAccountImplClient);_this8=_callSuper(this,IpAccountImplClient,[rpcClient,address]);_this8.wallet=wallet;return _this8;}/**
   * method execute for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(IpAccountImplClient,_IpAccountImplReadOnl);return _createClass(IpAccountImplClient,[{key:"execute",value:(function(){var _execute=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee80(request){var _yield$this$rpcClient43,call;return _regenerator().w(function(_context80){while(1)switch(_context80.n){case 0:_context80.n=1;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"execute",account:this.wallet.account,args:[request.to,request.value,request.data,request.operation]});case 1:_yield$this$rpcClient43=_context80.v;call=_yield$this$rpcClient43.request;_context80.n=2;return this.wallet.writeContract(call);case 2:return _context80.a(2,_context80.v);}},_callee80,this);}));function execute(_x56){return _execute.apply(this,arguments);}return execute;}()/**
   * method execute for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecuteRequest
   * @return EncodedTxData
   */)},{key:"executeEncode",value:function executeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:ipAccountImplAbi,functionName:"execute",args:[request.to,request.value,request.data,request.operation]})};}/**
   * method execute for contract IPAccountImpl
   *
   * @param request IpAccountImplExecute2Request
   * @return Promise<WriteContractReturnType>
   */},{key:"execute2",value:(function(){var _execute2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee81(request){var _yield$this$rpcClient44,call;return _regenerator().w(function(_context81){while(1)switch(_context81.n){case 0:_context81.n=1;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"execute",account:this.wallet.account,args:[request.to,request.value,request.data]});case 1:_yield$this$rpcClient44=_context81.v;call=_yield$this$rpcClient44.request;_context81.n=2;return this.wallet.writeContract(call);case 2:return _context81.a(2,_context81.v);}},_callee81,this);}));function execute2(_x57){return _execute2.apply(this,arguments);}return execute2;}()/**
   * method execute for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecute2Request
   * @return EncodedTxData
   */)},{key:"execute2Encode",value:function execute2Encode(request){return {to:this.address,data:viem.encodeFunctionData({abi:ipAccountImplAbi,functionName:"execute",args:[request.to,request.value,request.data]})};}/**
   * method executeBatch for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteBatchRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"executeBatch",value:(function(){var _executeBatch=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee82(request){var _yield$this$rpcClient45,call;return _regenerator().w(function(_context82){while(1)switch(_context82.n){case 0:_context82.n=1;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"executeBatch",account:this.wallet.account,args:[request.calls,request.operation]});case 1:_yield$this$rpcClient45=_context82.v;call=_yield$this$rpcClient45.request;_context82.n=2;return this.wallet.writeContract(call);case 2:return _context82.a(2,_context82.v);}},_callee82,this);}));function executeBatch(_x58){return _executeBatch.apply(this,arguments);}return executeBatch;}()/**
   * method executeBatch for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecuteBatchRequest
   * @return EncodedTxData
   */)},{key:"executeBatchEncode",value:function executeBatchEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:ipAccountImplAbi,functionName:"executeBatch",args:[request.calls,request.operation]})};}/**
   * method executeWithSig for contract IPAccountImpl
   *
   * @param request IpAccountImplExecuteWithSigRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"executeWithSig",value:(function(){var _executeWithSig=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee83(request){var _yield$this$rpcClient46,call;return _regenerator().w(function(_context83){while(1)switch(_context83.n){case 0:_context83.n=1;return this.rpcClient.simulateContract({abi:ipAccountImplAbi,address:this.address,functionName:"executeWithSig",account:this.wallet.account,args:[request.to,request.value,request.data,request.signer,request.deadline,request.signature]});case 1:_yield$this$rpcClient46=_context83.v;call=_yield$this$rpcClient46.request;_context83.n=2;return this.wallet.writeContract(call);case 2:return _context83.a(2,_context83.v);}},_callee83,this);}));function executeWithSig(_x59){return _executeWithSig.apply(this,arguments);}return executeWithSig;}()/**
   * method executeWithSig for contract IPAccountImpl with only encode
   *
   * @param request IpAccountImplExecuteWithSigRequest
   * @return EncodedTxData
   */)},{key:"executeWithSigEncode",value:function executeWithSigEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:ipAccountImplAbi,functionName:"executeWithSig",args:[request.to,request.value,request.data,request.signer,request.deadline,request.signature]})};}}]);}(IpAccountImplReadOnlyClient);// Contract IPAssetRegistry =============================================================
/**
 * IpAssetRegistryIpAccountRegisteredEvent
 *
 * @param account address
 * @param implementation address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 *//**
 * IpAssetRegistryIpRegisteredEvent
 *
 * @param ipId address
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 * @param name string
 * @param uri string
 * @param registrationDate uint256
 *//**
 * IpAssetRegistryIpIdRequest
 *
 * @param chainId uint256
 * @param tokenContract address
 * @param tokenId uint256
 *//**
 * IpAssetRegistryIsRegisteredRequest
 *
 * @param id address
 *//**
 * IpAssetRegistryRegisterRequest
 *
 * @param chainid uint256
 * @param tokenContract address
 * @param tokenId uint256
 *//**
 * contract IPAssetRegistry event
 */var IpAssetRegistryEventClient=/*#__PURE__*/function(){function IpAssetRegistryEventClient(rpcClient,address){var _rpcClient$chain1;_classCallCheck(this,IpAssetRegistryEventClient);this.address=address||getAddress(ipAssetRegistryAddress,(_rpcClient$chain1=rpcClient.chain)===null||_rpcClient$chain1===void 0?void 0:_rpcClient$chain1.id);this.rpcClient=rpcClient;}/**
   * event IPAccountRegistered for contract IPAssetRegistry
   */return _createClass(IpAssetRegistryEventClient,[{key:"watchIpAccountRegisteredEvent",value:function watchIpAccountRegisteredEvent(_onLogs17){return this.rpcClient.watchContractEvent({abi:ipAssetRegistryAbi,address:this.address,eventName:"IPAccountRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs17(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IPAccountRegistered for contract IPAssetRegistry
   */},{key:"parseTxIpAccountRegisteredEvent",value:function parseTxIpAccountRegisteredEvent(txReceipt){var targetLogs=[];var _iterator17=_createForOfIteratorHelper(txReceipt.logs),_step17;try{for(_iterator17.s();!(_step17=_iterator17.n()).done;){var log=_step17.value;try{var event=viem.decodeEventLog({abi:ipAssetRegistryAbi,eventName:"IPAccountRegistered",data:log.data,topics:log.topics});if(event.eventName==="IPAccountRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator17.e(err);}finally{_iterator17.f();}return targetLogs;}/**
   * event IPRegistered for contract IPAssetRegistry
   */},{key:"watchIpRegisteredEvent",value:function watchIpRegisteredEvent(_onLogs18){return this.rpcClient.watchContractEvent({abi:ipAssetRegistryAbi,address:this.address,eventName:"IPRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs18(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IPRegistered for contract IPAssetRegistry
   */},{key:"parseTxIpRegisteredEvent",value:function parseTxIpRegisteredEvent(txReceipt){var targetLogs=[];var _iterator18=_createForOfIteratorHelper(txReceipt.logs),_step18;try{for(_iterator18.s();!(_step18=_iterator18.n()).done;){var log=_step18.value;try{var event=viem.decodeEventLog({abi:ipAssetRegistryAbi,eventName:"IPRegistered",data:log.data,topics:log.topics});if(event.eventName==="IPRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator18.e(err);}finally{_iterator18.f();}return targetLogs;}}]);}();/**
 * contract IPAssetRegistry readonly method
 */var IpAssetRegistryReadOnlyClient=/*#__PURE__*/function(_IpAssetRegistryEvent){function IpAssetRegistryReadOnlyClient(rpcClient,address){_classCallCheck(this,IpAssetRegistryReadOnlyClient);return _callSuper(this,IpAssetRegistryReadOnlyClient,[rpcClient,address]);}/**
   * method ipId for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryIpIdRequest
   * @return Promise<IpAssetRegistryIpIdResponse>
   */_inherits(IpAssetRegistryReadOnlyClient,_IpAssetRegistryEvent);return _createClass(IpAssetRegistryReadOnlyClient,[{key:"ipId",value:(function(){var _ipId=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee84(request){return _regenerator().w(function(_context84){while(1)switch(_context84.n){case 0:_context84.n=1;return this.rpcClient.readContract({abi:ipAssetRegistryAbi,address:this.address,functionName:"ipId",args:[request.chainId,request.tokenContract,request.tokenId]});case 1:return _context84.a(2,_context84.v);}},_callee84,this);}));function ipId(_x60){return _ipId.apply(this,arguments);}return ipId;}()/**
   * method isRegistered for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryIsRegisteredRequest
   * @return Promise<IpAssetRegistryIsRegisteredResponse>
   */)},{key:"isRegistered",value:(function(){var _isRegistered=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee85(request){return _regenerator().w(function(_context85){while(1)switch(_context85.n){case 0:_context85.n=1;return this.rpcClient.readContract({abi:ipAssetRegistryAbi,address:this.address,functionName:"isRegistered",args:[request.id]});case 1:return _context85.a(2,_context85.v);}},_callee85,this);}));function isRegistered(_x61){return _isRegistered.apply(this,arguments);}return isRegistered;}())}]);}(IpAssetRegistryEventClient);/**
 * contract IPAssetRegistry write method
 */var IpAssetRegistryClient=/*#__PURE__*/function(_IpAssetRegistryReadO){function IpAssetRegistryClient(rpcClient,wallet,address){var _this9;_classCallCheck(this,IpAssetRegistryClient);_this9=_callSuper(this,IpAssetRegistryClient,[rpcClient,address]);_this9.wallet=wallet;return _this9;}/**
   * method register for contract IPAssetRegistry
   *
   * @param request IpAssetRegistryRegisterRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(IpAssetRegistryClient,_IpAssetRegistryReadO);return _createClass(IpAssetRegistryClient,[{key:"register",value:(function(){var _register=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee86(request){var _yield$this$rpcClient47,call;return _regenerator().w(function(_context86){while(1)switch(_context86.n){case 0:_context86.n=1;return this.rpcClient.simulateContract({abi:ipAssetRegistryAbi,address:this.address,functionName:"register",account:this.wallet.account,args:[request.chainid,request.tokenContract,request.tokenId]});case 1:_yield$this$rpcClient47=_context86.v;call=_yield$this$rpcClient47.request;_context86.n=2;return this.wallet.writeContract(call);case 2:return _context86.a(2,_context86.v);}},_callee86,this);}));function register(_x62){return _register.apply(this,arguments);}return register;}()/**
   * method register for contract IPAssetRegistry with only encode
   *
   * @param request IpAssetRegistryRegisterRequest
   * @return EncodedTxData
   */)},{key:"registerEncode",value:function registerEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:ipAssetRegistryAbi,functionName:"register",args:[request.chainid,request.tokenContract,request.tokenId]})};}}]);}(IpAssetRegistryReadOnlyClient);// Contract IpRoyaltyVaultImpl =============================================================
/**
 * IpRoyaltyVaultImplRevenueTokenClaimedEvent
 *
 * @param claimer address
 * @param token address
 * @param amount uint256
 *//**
 * IpRoyaltyVaultImplBalanceOfRequest
 *
 * @param account address
 *//**
 * IpRoyaltyVaultImplClaimableRevenueRequest
 *
 * @param claimer address
 * @param token address
 *//**
 * contract IpRoyaltyVaultImpl event
 */var IpRoyaltyVaultImplEventClient=/*#__PURE__*/function(){function IpRoyaltyVaultImplEventClient(rpcClient,address){var _rpcClient$chain10;_classCallCheck(this,IpRoyaltyVaultImplEventClient);this.address=address||getAddress(ipRoyaltyVaultImplAddress,(_rpcClient$chain10=rpcClient.chain)===null||_rpcClient$chain10===void 0?void 0:_rpcClient$chain10.id);this.rpcClient=rpcClient;}/**
   * event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
   */return _createClass(IpRoyaltyVaultImplEventClient,[{key:"watchRevenueTokenClaimedEvent",value:function watchRevenueTokenClaimedEvent(_onLogs19){return this.rpcClient.watchContractEvent({abi:ipRoyaltyVaultImplAbi,address:this.address,eventName:"RevenueTokenClaimed",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs19(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event RevenueTokenClaimed for contract IpRoyaltyVaultImpl
   */},{key:"parseTxRevenueTokenClaimedEvent",value:function parseTxRevenueTokenClaimedEvent(txReceipt){var targetLogs=[];var _iterator19=_createForOfIteratorHelper(txReceipt.logs),_step19;try{for(_iterator19.s();!(_step19=_iterator19.n()).done;){var log=_step19.value;try{var event=viem.decodeEventLog({abi:ipRoyaltyVaultImplAbi,eventName:"RevenueTokenClaimed",data:log.data,topics:log.topics});if(event.eventName==="RevenueTokenClaimed"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator19.e(err);}finally{_iterator19.f();}return targetLogs;}}]);}();/**
 * contract IpRoyaltyVaultImpl readonly method
 */var IpRoyaltyVaultImplReadOnlyClient=/*#__PURE__*/function(_IpRoyaltyVaultImplEv){function IpRoyaltyVaultImplReadOnlyClient(rpcClient,address){_classCallCheck(this,IpRoyaltyVaultImplReadOnlyClient);return _callSuper(this,IpRoyaltyVaultImplReadOnlyClient,[rpcClient,address]);}/**
   * method balanceOf for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplBalanceOfRequest
   * @return Promise<IpRoyaltyVaultImplBalanceOfResponse>
   */_inherits(IpRoyaltyVaultImplReadOnlyClient,_IpRoyaltyVaultImplEv);return _createClass(IpRoyaltyVaultImplReadOnlyClient,[{key:"balanceOf",value:(function(){var _balanceOf2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee87(request){return _regenerator().w(function(_context87){while(1)switch(_context87.n){case 0:_context87.n=1;return this.rpcClient.readContract({abi:ipRoyaltyVaultImplAbi,address:this.address,functionName:"balanceOf",args:[request.account]});case 1:return _context87.a(2,_context87.v);}},_callee87,this);}));function balanceOf(_x63){return _balanceOf2.apply(this,arguments);}return balanceOf;}()/**
   * method claimableRevenue for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplClaimableRevenueRequest
   * @return Promise<IpRoyaltyVaultImplClaimableRevenueResponse>
   */)},{key:"claimableRevenue",value:(function(){var _claimableRevenue=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee88(request){return _regenerator().w(function(_context88){while(1)switch(_context88.n){case 0:_context88.n=1;return this.rpcClient.readContract({abi:ipRoyaltyVaultImplAbi,address:this.address,functionName:"claimableRevenue",args:[request.claimer,request.token]});case 1:return _context88.a(2,_context88.v);}},_callee88,this);}));function claimableRevenue(_x64){return _claimableRevenue.apply(this,arguments);}return claimableRevenue;}()/**
   * method ipId for contract IpRoyaltyVaultImpl
   *
   * @param request IpRoyaltyVaultImplIpIdRequest
   * @return Promise<IpRoyaltyVaultImplIpIdResponse>
   */)},{key:"ipId",value:(function(){var _ipId2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee89(){return _regenerator().w(function(_context89){while(1)switch(_context89.n){case 0:_context89.n=1;return this.rpcClient.readContract({abi:ipRoyaltyVaultImplAbi,address:this.address,functionName:"ipId"});case 1:return _context89.a(2,_context89.v);}},_callee89,this);}));function ipId(){return _ipId2.apply(this,arguments);}return ipId;}())}]);}(IpRoyaltyVaultImplEventClient);// Contract LicenseAttachmentWorkflows =============================================================
/**
 * LicenseAttachmentWorkflowsMintAndRegisterIpAndAttachPilTermsRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param allowDuplicates bool
 *//**
 * LicenseAttachmentWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * LicenseAttachmentWorkflowsRegisterIpAndAttachPilTermsRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param sigMetadataAndAttachAndConfig tuple
 *//**
 * LicenseAttachmentWorkflowsRegisterPilTermsAndAttachRequest
 *
 * @param ipId address
 * @param licenseTermsData tuple[]
 * @param sigAttachAndConfig tuple
 *//**
 * contract LicenseAttachmentWorkflows write method
 */var LicenseAttachmentWorkflowsClient=/*#__PURE__*/function(){function LicenseAttachmentWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain11;_classCallCheck(this,LicenseAttachmentWorkflowsClient);this.address=address||getAddress(licenseAttachmentWorkflowsAddress,(_rpcClient$chain11=rpcClient.chain)===null||_rpcClient$chain11===void 0?void 0:_rpcClient$chain11.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method mintAndRegisterIpAndAttachPILTerms for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsMintAndRegisterIpAndAttachPilTermsRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(LicenseAttachmentWorkflowsClient,[{key:"mintAndRegisterIpAndAttachPilTerms",value:(function(){var _mintAndRegisterIpAndAttachPilTerms=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee90(request){var _yield$this$rpcClient48,call;return _regenerator().w(function(_context90){while(1)switch(_context90.n){case 0:_context90.n=1;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndAttachPILTerms",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.allowDuplicates]});case 1:_yield$this$rpcClient48=_context90.v;call=_yield$this$rpcClient48.request;_context90.n=2;return this.wallet.writeContract(call);case 2:return _context90.a(2,_context90.v);}},_callee90,this);}));function mintAndRegisterIpAndAttachPilTerms(_x65){return _mintAndRegisterIpAndAttachPilTerms.apply(this,arguments);}return mintAndRegisterIpAndAttachPilTerms;}()/**
   * method mintAndRegisterIpAndAttachPILTerms for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsMintAndRegisterIpAndAttachPilTermsRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndAttachPilTermsEncode",value:function mintAndRegisterIpAndAttachPilTermsEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"mintAndRegisterIpAndAttachPILTerms",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.allowDuplicates]})};}/**
   * method multicall for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee91(request){var _yield$this$rpcClient49,call;return _regenerator().w(function(_context91){while(1)switch(_context91.n){case 0:_context91.n=1;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 1:_yield$this$rpcClient49=_context91.v;call=_yield$this$rpcClient49.request;_context91.n=2;return this.wallet.writeContract(call);case 2:return _context91.a(2,_context91.v);}},_callee91,this);}));function multicall(_x66){return _multicall2.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIpAndAttachPILTerms for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsRegisterIpAndAttachPilTermsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndAttachPilTerms",value:(function(){var _registerIpAndAttachPilTerms=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee92(request){var _yield$this$rpcClient50,call;return _regenerator().w(function(_context92){while(1)switch(_context92.n){case 0:_context92.n=1;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"registerIpAndAttachPILTerms",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]});case 1:_yield$this$rpcClient50=_context92.v;call=_yield$this$rpcClient50.request;_context92.n=2;return this.wallet.writeContract(call);case 2:return _context92.a(2,_context92.v);}},_callee92,this);}));function registerIpAndAttachPilTerms(_x67){return _registerIpAndAttachPilTerms.apply(this,arguments);}return registerIpAndAttachPilTerms;}()/**
   * method registerIpAndAttachPILTerms for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsRegisterIpAndAttachPilTermsRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndAttachPilTermsEncode",value:function registerIpAndAttachPilTermsEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"registerIpAndAttachPILTerms",args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]})};}/**
   * method registerPILTermsAndAttach for contract LicenseAttachmentWorkflows
   *
   * @param request LicenseAttachmentWorkflowsRegisterPilTermsAndAttachRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerPilTermsAndAttach",value:(function(){var _registerPilTermsAndAttach=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee93(request){var _yield$this$rpcClient51,call;return _regenerator().w(function(_context93){while(1)switch(_context93.n){case 0:_context93.n=1;return this.rpcClient.simulateContract({abi:licenseAttachmentWorkflowsAbi,address:this.address,functionName:"registerPILTermsAndAttach",account:this.wallet.account,args:[request.ipId,request.licenseTermsData,request.sigAttachAndConfig]});case 1:_yield$this$rpcClient51=_context93.v;call=_yield$this$rpcClient51.request;_context93.n=2;return this.wallet.writeContract(call);case 2:return _context93.a(2,_context93.v);}},_callee93,this);}));function registerPilTermsAndAttach(_x68){return _registerPilTermsAndAttach.apply(this,arguments);}return registerPilTermsAndAttach;}()/**
   * method registerPILTermsAndAttach for contract LicenseAttachmentWorkflows with only encode
   *
   * @param request LicenseAttachmentWorkflowsRegisterPilTermsAndAttachRequest
   * @return EncodedTxData
   */)},{key:"registerPilTermsAndAttachEncode",value:function registerPilTermsAndAttachEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licenseAttachmentWorkflowsAbi,functionName:"registerPILTermsAndAttach",args:[request.ipId,request.licenseTermsData,request.sigAttachAndConfig]})};}}]);}();// Contract LicenseRegistry =============================================================
/**
 * LicenseRegistryGetDefaultLicenseTermsResponse
 *
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicenseRegistryGetLicensingConfigRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicenseRegistryGetRoyaltyPercentRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicenseRegistryGetRoyaltyPercentResponse
 *
 * @param royaltyPercent uint32
 *//**
 * LicenseRegistryHasIpAttachedLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * contract LicenseRegistry readonly method
 */var LicenseRegistryReadOnlyClient=/*#__PURE__*/function(){function LicenseRegistryReadOnlyClient(rpcClient,address){var _rpcClient$chain12;_classCallCheck(this,LicenseRegistryReadOnlyClient);this.address=address||getAddress(licenseRegistryAddress,(_rpcClient$chain12=rpcClient.chain)===null||_rpcClient$chain12===void 0?void 0:_rpcClient$chain12.id);this.rpcClient=rpcClient;}/**
   * method getDefaultLicenseTerms for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetDefaultLicenseTermsRequest
   * @return Promise<LicenseRegistryGetDefaultLicenseTermsResponse>
   */return _createClass(LicenseRegistryReadOnlyClient,[{key:"getDefaultLicenseTerms",value:(function(){var _getDefaultLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee94(){var result;return _regenerator().w(function(_context94){while(1)switch(_context94.n){case 0:_context94.n=1;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getDefaultLicenseTerms"});case 1:result=_context94.v;return _context94.a(2,{licenseTemplate:result[0],licenseTermsId:result[1]});}},_callee94,this);}));function getDefaultLicenseTerms(){return _getDefaultLicenseTerms.apply(this,arguments);}return getDefaultLicenseTerms;}()/**
   * method getLicensingConfig for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetLicensingConfigRequest
   * @return Promise<LicenseRegistryGetLicensingConfigResponse>
   */)},{key:"getLicensingConfig",value:(function(){var _getLicensingConfig=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee95(request){return _regenerator().w(function(_context95){while(1)switch(_context95.n){case 0:_context95.n=1;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getLicensingConfig",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 1:return _context95.a(2,_context95.v);}},_callee95,this);}));function getLicensingConfig(_x69){return _getLicensingConfig.apply(this,arguments);}return getLicensingConfig;}()/**
   * method getRoyaltyPercent for contract LicenseRegistry
   *
   * @param request LicenseRegistryGetRoyaltyPercentRequest
   * @return Promise<LicenseRegistryGetRoyaltyPercentResponse>
   */)},{key:"getRoyaltyPercent",value:(function(){var _getRoyaltyPercent=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee96(request){var result;return _regenerator().w(function(_context96){while(1)switch(_context96.n){case 0:_context96.n=1;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"getRoyaltyPercent",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 1:result=_context96.v;return _context96.a(2,{royaltyPercent:result});}},_callee96,this);}));function getRoyaltyPercent(_x70){return _getRoyaltyPercent.apply(this,arguments);}return getRoyaltyPercent;}()/**
   * method hasIpAttachedLicenseTerms for contract LicenseRegistry
   *
   * @param request LicenseRegistryHasIpAttachedLicenseTermsRequest
   * @return Promise<LicenseRegistryHasIpAttachedLicenseTermsResponse>
   */)},{key:"hasIpAttachedLicenseTerms",value:(function(){var _hasIpAttachedLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee97(request){return _regenerator().w(function(_context97){while(1)switch(_context97.n){case 0:_context97.n=1;return this.rpcClient.readContract({abi:licenseRegistryAbi,address:this.address,functionName:"hasIpAttachedLicenseTerms",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 1:return _context97.a(2,_context97.v);}},_callee97,this);}));function hasIpAttachedLicenseTerms(_x71){return _hasIpAttachedLicenseTerms.apply(this,arguments);}return hasIpAttachedLicenseTerms;}())}]);}();// Contract LicenseToken =============================================================
/**
 * LicenseTokenOwnerOfRequest
 *
 * @param tokenId uint256
 *//**
 * LicenseTokenApproveRequest
 *
 * @param to address
 * @param tokenId uint256
 *//**
 * contract LicenseToken readonly method
 */var LicenseTokenReadOnlyClient=/*#__PURE__*/function(){function LicenseTokenReadOnlyClient(rpcClient,address){var _rpcClient$chain13;_classCallCheck(this,LicenseTokenReadOnlyClient);this.address=address||getAddress(licenseTokenAddress,(_rpcClient$chain13=rpcClient.chain)===null||_rpcClient$chain13===void 0?void 0:_rpcClient$chain13.id);this.rpcClient=rpcClient;}/**
   * method ownerOf for contract LicenseToken
   *
   * @param request LicenseTokenOwnerOfRequest
   * @return Promise<LicenseTokenOwnerOfResponse>
   */return _createClass(LicenseTokenReadOnlyClient,[{key:"ownerOf",value:(function(){var _ownerOf=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee98(request){return _regenerator().w(function(_context98){while(1)switch(_context98.n){case 0:_context98.n=1;return this.rpcClient.readContract({abi:licenseTokenAbi,address:this.address,functionName:"ownerOf",args:[request.tokenId]});case 1:return _context98.a(2,_context98.v);}},_callee98,this);}));function ownerOf(_x72){return _ownerOf.apply(this,arguments);}return ownerOf;}())}]);}();/**
 * contract LicenseToken write method
 */var LicenseTokenClient=/*#__PURE__*/function(_LicenseTokenReadOnly){function LicenseTokenClient(rpcClient,wallet,address){var _this0;_classCallCheck(this,LicenseTokenClient);_this0=_callSuper(this,LicenseTokenClient,[rpcClient,address]);_this0.wallet=wallet;return _this0;}/**
   * method approve for contract LicenseToken
   *
   * @param request LicenseTokenApproveRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(LicenseTokenClient,_LicenseTokenReadOnly);return _createClass(LicenseTokenClient,[{key:"approve",value:(function(){var _approve2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee99(request){var _yield$this$rpcClient52,call;return _regenerator().w(function(_context99){while(1)switch(_context99.n){case 0:_context99.n=1;return this.rpcClient.simulateContract({abi:licenseTokenAbi,address:this.address,functionName:"approve",account:this.wallet.account,args:[request.to,request.tokenId]});case 1:_yield$this$rpcClient52=_context99.v;call=_yield$this$rpcClient52.request;_context99.n=2;return this.wallet.writeContract(call);case 2:return _context99.a(2,_context99.v);}},_callee99,this);}));function approve(_x73){return _approve2.apply(this,arguments);}return approve;}()/**
   * method approve for contract LicenseToken with only encode
   *
   * @param request LicenseTokenApproveRequest
   * @return EncodedTxData
   */)},{key:"approveEncode",value:function approveEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licenseTokenAbi,functionName:"approve",args:[request.to,request.tokenId]})};}}]);}(LicenseTokenReadOnlyClient);// Contract LicensingModule =============================================================
/**
 * LicensingModuleLicenseTermsAttachedEvent
 *
 * @param caller address
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicensingModuleLicenseTokensMintedEvent
 *
 * @param caller address
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param startLicenseTokenId uint256
 *//**
 * LicensingModulePredictMintingLicenseFeeRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param royaltyContext bytes
 *//**
 * LicensingModulePredictMintingLicenseFeeResponse
 *
 * @param currencyToken address
 * @param tokenAmount uint256
 *//**
 * LicensingModuleAttachLicenseTermsRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 *//**
 * LicensingModuleMintLicenseTokensRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param amount uint256
 * @param receiver address
 * @param royaltyContext bytes
 * @param maxMintingFee uint256
 * @param maxRevenueShare uint32
 *//**
 * LicensingModuleRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param licenseTemplate address
 * @param royaltyContext bytes
 * @param maxMintingFee uint256
 * @param maxRts uint32
 * @param maxRevenueShare uint32
 *//**
 * LicensingModuleRegisterDerivativeWithLicenseTokensRequest
 *
 * @param childIpId address
 * @param licenseTokenIds uint256[]
 * @param royaltyContext bytes
 * @param maxRts uint32
 *//**
 * LicensingModuleSetLicensingConfigRequest
 *
 * @param ipId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param licensingConfig tuple
 *//**
 * contract LicensingModule event
 */var LicensingModuleEventClient=/*#__PURE__*/function(){function LicensingModuleEventClient(rpcClient,address){var _rpcClient$chain14;_classCallCheck(this,LicensingModuleEventClient);this.address=address||getAddress(licensingModuleAddress,(_rpcClient$chain14=rpcClient.chain)===null||_rpcClient$chain14===void 0?void 0:_rpcClient$chain14.id);this.rpcClient=rpcClient;}/**
   * event LicenseTermsAttached for contract LicensingModule
   */return _createClass(LicensingModuleEventClient,[{key:"watchLicenseTermsAttachedEvent",value:function watchLicenseTermsAttachedEvent(_onLogs20){return this.rpcClient.watchContractEvent({abi:licensingModuleAbi,address:this.address,eventName:"LicenseTermsAttached",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs20(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTermsAttached for contract LicensingModule
   */},{key:"parseTxLicenseTermsAttachedEvent",value:function parseTxLicenseTermsAttachedEvent(txReceipt){var targetLogs=[];var _iterator20=_createForOfIteratorHelper(txReceipt.logs),_step20;try{for(_iterator20.s();!(_step20=_iterator20.n()).done;){var log=_step20.value;try{var event=viem.decodeEventLog({abi:licensingModuleAbi,eventName:"LicenseTermsAttached",data:log.data,topics:log.topics});if(event.eventName==="LicenseTermsAttached"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator20.e(err);}finally{_iterator20.f();}return targetLogs;}/**
   * event LicenseTokensMinted for contract LicensingModule
   */},{key:"watchLicenseTokensMintedEvent",value:function watchLicenseTokensMintedEvent(_onLogs21){return this.rpcClient.watchContractEvent({abi:licensingModuleAbi,address:this.address,eventName:"LicenseTokensMinted",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs21(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTokensMinted for contract LicensingModule
   */},{key:"parseTxLicenseTokensMintedEvent",value:function parseTxLicenseTokensMintedEvent(txReceipt){var targetLogs=[];var _iterator21=_createForOfIteratorHelper(txReceipt.logs),_step21;try{for(_iterator21.s();!(_step21=_iterator21.n()).done;){var log=_step21.value;try{var event=viem.decodeEventLog({abi:licensingModuleAbi,eventName:"LicenseTokensMinted",data:log.data,topics:log.topics});if(event.eventName==="LicenseTokensMinted"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator21.e(err);}finally{_iterator21.f();}return targetLogs;}}]);}();/**
 * contract LicensingModule readonly method
 */var LicensingModuleReadOnlyClient=/*#__PURE__*/function(_LicensingModuleEvent){function LicensingModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,LicensingModuleReadOnlyClient);return _callSuper(this,LicensingModuleReadOnlyClient,[rpcClient,address]);}/**
   * method predictMintingLicenseFee for contract LicensingModule
   *
   * @param request LicensingModulePredictMintingLicenseFeeRequest
   * @return Promise<LicensingModulePredictMintingLicenseFeeResponse>
   */_inherits(LicensingModuleReadOnlyClient,_LicensingModuleEvent);return _createClass(LicensingModuleReadOnlyClient,[{key:"predictMintingLicenseFee",value:(function(){var _predictMintingLicenseFee=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee100(request){var result;return _regenerator().w(function(_context100){while(1)switch(_context100.n){case 0:_context100.n=1;return this.rpcClient.readContract({abi:licensingModuleAbi,address:this.address,functionName:"predictMintingLicenseFee",args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.amount,request.receiver,request.royaltyContext]});case 1:result=_context100.v;return _context100.a(2,{currencyToken:result[0],tokenAmount:result[1]});}},_callee100,this);}));function predictMintingLicenseFee(_x74){return _predictMintingLicenseFee.apply(this,arguments);}return predictMintingLicenseFee;}())}]);}(LicensingModuleEventClient);/**
 * contract LicensingModule write method
 */var LicensingModuleClient=/*#__PURE__*/function(_LicensingModuleReadO){function LicensingModuleClient(rpcClient,wallet,address){var _this1;_classCallCheck(this,LicensingModuleClient);_this1=_callSuper(this,LicensingModuleClient,[rpcClient,address]);_this1.wallet=wallet;return _this1;}/**
   * method attachLicenseTerms for contract LicensingModule
   *
   * @param request LicensingModuleAttachLicenseTermsRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(LicensingModuleClient,_LicensingModuleReadO);return _createClass(LicensingModuleClient,[{key:"attachLicenseTerms",value:(function(){var _attachLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee101(request){var _yield$this$rpcClient53,call;return _regenerator().w(function(_context101){while(1)switch(_context101.n){case 0:_context101.n=1;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"attachLicenseTerms",account:this.wallet.account,args:[request.ipId,request.licenseTemplate,request.licenseTermsId]});case 1:_yield$this$rpcClient53=_context101.v;call=_yield$this$rpcClient53.request;_context101.n=2;return this.wallet.writeContract(call);case 2:return _context101.a(2,_context101.v);}},_callee101,this);}));function attachLicenseTerms(_x75){return _attachLicenseTerms.apply(this,arguments);}return attachLicenseTerms;}()/**
   * method attachLicenseTerms for contract LicensingModule with only encode
   *
   * @param request LicensingModuleAttachLicenseTermsRequest
   * @return EncodedTxData
   */)},{key:"attachLicenseTermsEncode",value:function attachLicenseTermsEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licensingModuleAbi,functionName:"attachLicenseTerms",args:[request.ipId,request.licenseTemplate,request.licenseTermsId]})};}/**
   * method mintLicenseTokens for contract LicensingModule
   *
   * @param request LicensingModuleMintLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintLicenseTokens",value:(function(){var _mintLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee102(request){var _yield$this$rpcClient54,call;return _regenerator().w(function(_context102){while(1)switch(_context102.n){case 0:_context102.n=1;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"mintLicenseTokens",account:this.wallet.account,args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.amount,request.receiver,request.royaltyContext,request.maxMintingFee,request.maxRevenueShare]});case 1:_yield$this$rpcClient54=_context102.v;call=_yield$this$rpcClient54.request;_context102.n=2;return this.wallet.writeContract(call);case 2:return _context102.a(2,_context102.v);}},_callee102,this);}));function mintLicenseTokens(_x76){return _mintLicenseTokens.apply(this,arguments);}return mintLicenseTokens;}()/**
   * method mintLicenseTokens for contract LicensingModule with only encode
   *
   * @param request LicensingModuleMintLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"mintLicenseTokensEncode",value:function mintLicenseTokensEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licensingModuleAbi,functionName:"mintLicenseTokens",args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.amount,request.receiver,request.royaltyContext,request.maxMintingFee,request.maxRevenueShare]})};}/**
   * method registerDerivative for contract LicensingModule
   *
   * @param request LicensingModuleRegisterDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerDerivative",value:(function(){var _registerDerivative=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee103(request){var _yield$this$rpcClient55,call;return _regenerator().w(function(_context103){while(1)switch(_context103.n){case 0:_context103.n=1;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"registerDerivative",account:this.wallet.account,args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.licenseTemplate,request.royaltyContext,request.maxMintingFee,request.maxRts,request.maxRevenueShare]});case 1:_yield$this$rpcClient55=_context103.v;call=_yield$this$rpcClient55.request;_context103.n=2;return this.wallet.writeContract(call);case 2:return _context103.a(2,_context103.v);}},_callee103,this);}));function registerDerivative(_x77){return _registerDerivative.apply(this,arguments);}return registerDerivative;}()/**
   * method registerDerivative for contract LicensingModule with only encode
   *
   * @param request LicensingModuleRegisterDerivativeRequest
   * @return EncodedTxData
   */)},{key:"registerDerivativeEncode",value:function registerDerivativeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licensingModuleAbi,functionName:"registerDerivative",args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.licenseTemplate,request.royaltyContext,request.maxMintingFee,request.maxRts,request.maxRevenueShare]})};}/**
   * method registerDerivativeWithLicenseTokens for contract LicensingModule
   *
   * @param request LicensingModuleRegisterDerivativeWithLicenseTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerDerivativeWithLicenseTokens",value:(function(){var _registerDerivativeWithLicenseTokens=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee104(request){var _yield$this$rpcClient56,call;return _regenerator().w(function(_context104){while(1)switch(_context104.n){case 0:_context104.n=1;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"registerDerivativeWithLicenseTokens",account:this.wallet.account,args:[request.childIpId,request.licenseTokenIds,request.royaltyContext,request.maxRts]});case 1:_yield$this$rpcClient56=_context104.v;call=_yield$this$rpcClient56.request;_context104.n=2;return this.wallet.writeContract(call);case 2:return _context104.a(2,_context104.v);}},_callee104,this);}));function registerDerivativeWithLicenseTokens(_x78){return _registerDerivativeWithLicenseTokens.apply(this,arguments);}return registerDerivativeWithLicenseTokens;}()/**
   * method registerDerivativeWithLicenseTokens for contract LicensingModule with only encode
   *
   * @param request LicensingModuleRegisterDerivativeWithLicenseTokensRequest
   * @return EncodedTxData
   */)},{key:"registerDerivativeWithLicenseTokensEncode",value:function registerDerivativeWithLicenseTokensEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licensingModuleAbi,functionName:"registerDerivativeWithLicenseTokens",args:[request.childIpId,request.licenseTokenIds,request.royaltyContext,request.maxRts]})};}/**
   * method setLicensingConfig for contract LicensingModule
   *
   * @param request LicensingModuleSetLicensingConfigRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setLicensingConfig",value:(function(){var _setLicensingConfig=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee105(request){var _yield$this$rpcClient57,call;return _regenerator().w(function(_context105){while(1)switch(_context105.n){case 0:_context105.n=1;return this.rpcClient.simulateContract({abi:licensingModuleAbi,address:this.address,functionName:"setLicensingConfig",account:this.wallet.account,args:[request.ipId,request.licenseTemplate,request.licenseTermsId,request.licensingConfig]});case 1:_yield$this$rpcClient57=_context105.v;call=_yield$this$rpcClient57.request;_context105.n=2;return this.wallet.writeContract(call);case 2:return _context105.a(2,_context105.v);}},_callee105,this);}));function setLicensingConfig(_x79){return _setLicensingConfig.apply(this,arguments);}return setLicensingConfig;}()/**
   * method setLicensingConfig for contract LicensingModule with only encode
   *
   * @param request LicensingModuleSetLicensingConfigRequest
   * @return EncodedTxData
   */)},{key:"setLicensingConfigEncode",value:function setLicensingConfigEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:licensingModuleAbi,functionName:"setLicensingConfig",args:[request.ipId,request.licenseTemplate,request.licenseTermsId,request.licensingConfig]})};}}]);}(LicensingModuleReadOnlyClient);// Contract ModuleRegistry =============================================================
/**
 * ModuleRegistryIsRegisteredRequest
 *
 * @param moduleAddress address
 *//**
 * contract ModuleRegistry readonly method
 */var ModuleRegistryReadOnlyClient=/*#__PURE__*/function(){function ModuleRegistryReadOnlyClient(rpcClient,address){var _rpcClient$chain15;_classCallCheck(this,ModuleRegistryReadOnlyClient);this.address=address||getAddress(moduleRegistryAddress,(_rpcClient$chain15=rpcClient.chain)===null||_rpcClient$chain15===void 0?void 0:_rpcClient$chain15.id);this.rpcClient=rpcClient;}/**
   * method isRegistered for contract ModuleRegistry
   *
   * @param request ModuleRegistryIsRegisteredRequest
   * @return Promise<ModuleRegistryIsRegisteredResponse>
   */return _createClass(ModuleRegistryReadOnlyClient,[{key:"isRegistered",value:(function(){var _isRegistered2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee106(request){return _regenerator().w(function(_context106){while(1)switch(_context106.n){case 0:_context106.n=1;return this.rpcClient.readContract({abi:moduleRegistryAbi,address:this.address,functionName:"isRegistered",args:[request.moduleAddress]});case 1:return _context106.a(2,_context106.v);}},_callee106,this);}));function isRegistered(_x80){return _isRegistered2.apply(this,arguments);}return isRegistered;}())}]);}();// Contract Multicall3 =============================================================
/**
 * Multicall3Aggregate3Request
 *
 * @param calls tuple[]
 *//**
 * contract Multicall3 write method
 */var Multicall3Client=/*#__PURE__*/function(){function Multicall3Client(rpcClient,wallet,address){var _rpcClient$chain16;_classCallCheck(this,Multicall3Client);this.address=address||getAddress(multicall3Address,(_rpcClient$chain16=rpcClient.chain)===null||_rpcClient$chain16===void 0?void 0:_rpcClient$chain16.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method aggregate3 for contract Multicall3
   *
   * @param request Multicall3Aggregate3Request
   * @return Promise<WriteContractReturnType>
   */return _createClass(Multicall3Client,[{key:"aggregate3",value:(function(){var _aggregate=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee107(request){var _yield$this$rpcClient58,call;return _regenerator().w(function(_context107){while(1)switch(_context107.n){case 0:_context107.n=1;return this.rpcClient.simulateContract({abi:multicall3Abi,address:this.address,functionName:"aggregate3",account:this.wallet.account,args:[request.calls]});case 1:_yield$this$rpcClient58=_context107.v;call=_yield$this$rpcClient58.request;_context107.n=2;return this.wallet.writeContract(call);case 2:return _context107.a(2,_context107.v);}},_callee107,this);}));function aggregate3(_x81){return _aggregate.apply(this,arguments);}return aggregate3;}()/**
   * method aggregate3 for contract Multicall3 with only encode
   *
   * @param request Multicall3Aggregate3Request
   * @return EncodedTxData
   */)},{key:"aggregate3Encode",value:function aggregate3Encode(request){return {to:this.address,data:viem.encodeFunctionData({abi:multicall3Abi,functionName:"aggregate3",args:[request.calls]})};}}]);}();// Contract PILicenseTemplate =============================================================
/**
 * PiLicenseTemplateAuthorityUpdatedEvent
 *
 * @param authority address
 *//**
 * PiLicenseTemplateDerivativeApprovedEvent
 *
 * @param licenseTermsId uint256
 * @param ipId address
 * @param caller address
 * @param approved bool
 *//**
 * PiLicenseTemplateInitializedEvent
 *
 * @param version uint64
 *//**
 * PiLicenseTemplateLicenseTermsRegisteredEvent
 *
 * @param licenseTermsId uint256
 * @param licenseTemplate address
 * @param licenseTerms bytes
 *//**
 * PiLicenseTemplateUpgradedEvent
 *
 * @param implementation address
 *//**
 * PiLicenseTemplateAllowDerivativeRegistrationRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateCanAttachToGroupIpRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateCanOverrideRoyaltyPercentRequest
 *
 * @param licenseTermsId uint256
 * @param newRoyaltyPercent uint32
 *//**
 * PiLicenseTemplateExistsRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateGetEarlierExpireTimeRequest
 *
 * @param licenseTermsIds uint256[]
 * @param start uint256
 *//**
 * PiLicenseTemplateGetExpireTimeRequest
 *
 * @param licenseTermsId uint256
 * @param start uint256
 *//**
 * PiLicenseTemplateGetLicenseTermsRequest
 *
 * @param selectedLicenseTermsId uint256
 *//**
 * PiLicenseTemplateGetLicenseTermsResponse
 *
 * @param terms tuple
 *//**
 * PiLicenseTemplateGetLicenseTermsIdRequest
 *
 * @param terms tuple
 *//**
 * PiLicenseTemplateGetLicenseTermsIdResponse
 *
 * @param selectedLicenseTermsId uint256
 *//**
 * PiLicenseTemplateGetLicenseTermsUriRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateGetRoyaltyPolicyRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateGetRoyaltyPolicyResponse
 *
 * @param royaltyPolicy address
 * @param royaltyPercent uint32
 * @param mintingFee uint256
 * @param currency address
 *//**
 * PiLicenseTemplateIsDerivativeApprovedRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 *//**
 * PiLicenseTemplateIsLicenseTransferableRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateSupportsInterfaceRequest
 *
 * @param interfaceId bytes4
 *//**
 * PiLicenseTemplateToJsonRequest
 *
 * @param licenseTermsId uint256
 *//**
 * PiLicenseTemplateVerifyCompatibleLicensesRequest
 *
 * @param licenseTermsIds uint256[]
 *//**
 * PiLicenseTemplateInitializeRequest
 *
 * @param accessManager address
 * @param name string
 * @param metadataURI string
 *//**
 * PiLicenseTemplateRegisterLicenseTermsRequest
 *
 * @param terms tuple
 *//**
 * PiLicenseTemplateSetApprovalRequest
 *
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param childIpId address
 * @param approved bool
 *//**
 * PiLicenseTemplateSetAuthorityRequest
 *
 * @param newAuthority address
 *//**
 * PiLicenseTemplateUpgradeToAndCallRequest
 *
 * @param newImplementation address
 * @param data bytes
 *//**
 * PiLicenseTemplateVerifyMintLicenseTokenRequest
 *
 * @param 0 uint256
 * @param 1 address
 * @param 2 address
 * @param 3 uint256
 *//**
 * PiLicenseTemplateVerifyRegisterDerivativeRequest
 *
 * @param childIpId address
 * @param parentIpId address
 * @param licenseTermsId uint256
 * @param licensee address
 *//**
 * PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
 *
 * @param childIpId address
 * @param parentIpIds address[]
 * @param licenseTermsIds uint256[]
 * @param caller address
 *//**
 * contract PILicenseTemplate event
 */var PiLicenseTemplateEventClient=/*#__PURE__*/function(){function PiLicenseTemplateEventClient(rpcClient,address){var _rpcClient$chain17;_classCallCheck(this,PiLicenseTemplateEventClient);this.address=address||getAddress(piLicenseTemplateAddress,(_rpcClient$chain17=rpcClient.chain)===null||_rpcClient$chain17===void 0?void 0:_rpcClient$chain17.id);this.rpcClient=rpcClient;}/**
   * event AuthorityUpdated for contract PILicenseTemplate
   */return _createClass(PiLicenseTemplateEventClient,[{key:"watchAuthorityUpdatedEvent",value:function watchAuthorityUpdatedEvent(_onLogs22){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"AuthorityUpdated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs22(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event AuthorityUpdated for contract PILicenseTemplate
   */},{key:"parseTxAuthorityUpdatedEvent",value:function parseTxAuthorityUpdatedEvent(txReceipt){var targetLogs=[];var _iterator22=_createForOfIteratorHelper(txReceipt.logs),_step22;try{for(_iterator22.s();!(_step22=_iterator22.n()).done;){var log=_step22.value;try{var event=viem.decodeEventLog({abi:piLicenseTemplateAbi,eventName:"AuthorityUpdated",data:log.data,topics:log.topics});if(event.eventName==="AuthorityUpdated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator22.e(err);}finally{_iterator22.f();}return targetLogs;}/**
   * event DerivativeApproved for contract PILicenseTemplate
   */},{key:"watchDerivativeApprovedEvent",value:function watchDerivativeApprovedEvent(_onLogs23){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"DerivativeApproved",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs23(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event DerivativeApproved for contract PILicenseTemplate
   */},{key:"parseTxDerivativeApprovedEvent",value:function parseTxDerivativeApprovedEvent(txReceipt){var targetLogs=[];var _iterator23=_createForOfIteratorHelper(txReceipt.logs),_step23;try{for(_iterator23.s();!(_step23=_iterator23.n()).done;){var log=_step23.value;try{var event=viem.decodeEventLog({abi:piLicenseTemplateAbi,eventName:"DerivativeApproved",data:log.data,topics:log.topics});if(event.eventName==="DerivativeApproved"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator23.e(err);}finally{_iterator23.f();}return targetLogs;}/**
   * event Initialized for contract PILicenseTemplate
   */},{key:"watchInitializedEvent",value:function watchInitializedEvent(_onLogs24){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"Initialized",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs24(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Initialized for contract PILicenseTemplate
   */},{key:"parseTxInitializedEvent",value:function parseTxInitializedEvent(txReceipt){var targetLogs=[];var _iterator24=_createForOfIteratorHelper(txReceipt.logs),_step24;try{for(_iterator24.s();!(_step24=_iterator24.n()).done;){var log=_step24.value;try{var event=viem.decodeEventLog({abi:piLicenseTemplateAbi,eventName:"Initialized",data:log.data,topics:log.topics});if(event.eventName==="Initialized"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator24.e(err);}finally{_iterator24.f();}return targetLogs;}/**
   * event LicenseTermsRegistered for contract PILicenseTemplate
   */},{key:"watchLicenseTermsRegisteredEvent",value:function watchLicenseTermsRegisteredEvent(_onLogs25){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"LicenseTermsRegistered",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs25(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event LicenseTermsRegistered for contract PILicenseTemplate
   */},{key:"parseTxLicenseTermsRegisteredEvent",value:function parseTxLicenseTermsRegisteredEvent(txReceipt){var targetLogs=[];var _iterator25=_createForOfIteratorHelper(txReceipt.logs),_step25;try{for(_iterator25.s();!(_step25=_iterator25.n()).done;){var log=_step25.value;try{var event=viem.decodeEventLog({abi:piLicenseTemplateAbi,eventName:"LicenseTermsRegistered",data:log.data,topics:log.topics});if(event.eventName==="LicenseTermsRegistered"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator25.e(err);}finally{_iterator25.f();}return targetLogs;}/**
   * event Upgraded for contract PILicenseTemplate
   */},{key:"watchUpgradedEvent",value:function watchUpgradedEvent(_onLogs26){return this.rpcClient.watchContractEvent({abi:piLicenseTemplateAbi,address:this.address,eventName:"Upgraded",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs26(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Upgraded for contract PILicenseTemplate
   */},{key:"parseTxUpgradedEvent",value:function parseTxUpgradedEvent(txReceipt){var targetLogs=[];var _iterator26=_createForOfIteratorHelper(txReceipt.logs),_step26;try{for(_iterator26.s();!(_step26=_iterator26.n()).done;){var log=_step26.value;try{var event=viem.decodeEventLog({abi:piLicenseTemplateAbi,eventName:"Upgraded",data:log.data,topics:log.topics});if(event.eventName==="Upgraded"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator26.e(err);}finally{_iterator26.f();}return targetLogs;}}]);}();/**
 * contract PILicenseTemplate readonly method
 */var PiLicenseTemplateReadOnlyClient=/*#__PURE__*/function(_PiLicenseTemplateEve){function PiLicenseTemplateReadOnlyClient(rpcClient,address){_classCallCheck(this,PiLicenseTemplateReadOnlyClient);return _callSuper(this,PiLicenseTemplateReadOnlyClient,[rpcClient,address]);}/**
   * method ACCESS_CONTROLLER for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAccessControllerRequest
   * @return Promise<PiLicenseTemplateAccessControllerResponse>
   */_inherits(PiLicenseTemplateReadOnlyClient,_PiLicenseTemplateEve);return _createClass(PiLicenseTemplateReadOnlyClient,[{key:"accessController",value:(function(){var _accessController2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee108(){return _regenerator().w(function(_context108){while(1)switch(_context108.n){case 0:_context108.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"ACCESS_CONTROLLER"});case 1:return _context108.a(2,_context108.v);}},_callee108,this);}));function accessController(){return _accessController2.apply(this,arguments);}return accessController;}()/**
   * method IP_ASSET_REGISTRY for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIpAssetRegistryRequest
   * @return Promise<PiLicenseTemplateIpAssetRegistryResponse>
   */)},{key:"ipAssetRegistry",value:(function(){var _ipAssetRegistry2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee109(){return _regenerator().w(function(_context109){while(1)switch(_context109.n){case 0:_context109.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"IP_ASSET_REGISTRY"});case 1:return _context109.a(2,_context109.v);}},_callee109,this);}));function ipAssetRegistry(){return _ipAssetRegistry2.apply(this,arguments);}return ipAssetRegistry;}()/**
   * method LICENSE_REGISTRY for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateLicenseRegistryRequest
   * @return Promise<PiLicenseTemplateLicenseRegistryResponse>
   */)},{key:"licenseRegistry",value:(function(){var _licenseRegistry=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee110(){return _regenerator().w(function(_context110){while(1)switch(_context110.n){case 0:_context110.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"LICENSE_REGISTRY"});case 1:return _context110.a(2,_context110.v);}},_callee110,this);}));function licenseRegistry(){return _licenseRegistry.apply(this,arguments);}return licenseRegistry;}()/**
   * method MODULE_REGISTRY for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateModuleRegistryRequest
   * @return Promise<PiLicenseTemplateModuleRegistryResponse>
   */)},{key:"moduleRegistry",value:(function(){var _moduleRegistry=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee111(){return _regenerator().w(function(_context111){while(1)switch(_context111.n){case 0:_context111.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"MODULE_REGISTRY"});case 1:return _context111.a(2,_context111.v);}},_callee111,this);}));function moduleRegistry(){return _moduleRegistry.apply(this,arguments);}return moduleRegistry;}()/**
   * method ROYALTY_MODULE for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateRoyaltyModuleRequest
   * @return Promise<PiLicenseTemplateRoyaltyModuleResponse>
   */)},{key:"royaltyModule",value:(function(){var _royaltyModule2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee112(){return _regenerator().w(function(_context112){while(1)switch(_context112.n){case 0:_context112.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"ROYALTY_MODULE"});case 1:return _context112.a(2,_context112.v);}},_callee112,this);}));function royaltyModule(){return _royaltyModule2.apply(this,arguments);}return royaltyModule;}()/**
   * method TERMS_RENDERER for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateTermsRendererRequest
   * @return Promise<PiLicenseTemplateTermsRendererResponse>
   */)},{key:"termsRenderer",value:(function(){var _termsRenderer=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee113(){return _regenerator().w(function(_context113){while(1)switch(_context113.n){case 0:_context113.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"TERMS_RENDERER"});case 1:return _context113.a(2,_context113.v);}},_callee113,this);}));function termsRenderer(){return _termsRenderer.apply(this,arguments);}return termsRenderer;}()/**
   * method UPGRADE_INTERFACE_VERSION for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateUpgradeInterfaceVersionRequest
   * @return Promise<PiLicenseTemplateUpgradeInterfaceVersionResponse>
   */)},{key:"upgradeInterfaceVersion",value:(function(){var _upgradeInterfaceVersion3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee114(){return _regenerator().w(function(_context114){while(1)switch(_context114.n){case 0:_context114.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"UPGRADE_INTERFACE_VERSION"});case 1:return _context114.a(2,_context114.v);}},_callee114,this);}));function upgradeInterfaceVersion(){return _upgradeInterfaceVersion3.apply(this,arguments);}return upgradeInterfaceVersion;}()/**
   * method allowDerivativeRegistration for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAllowDerivativeRegistrationRequest
   * @return Promise<PiLicenseTemplateAllowDerivativeRegistrationResponse>
   */)},{key:"allowDerivativeRegistration",value:(function(){var _allowDerivativeRegistration=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee115(request){return _regenerator().w(function(_context115){while(1)switch(_context115.n){case 0:_context115.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"allowDerivativeRegistration",args:[request.licenseTermsId]});case 1:return _context115.a(2,_context115.v);}},_callee115,this);}));function allowDerivativeRegistration(_x82){return _allowDerivativeRegistration.apply(this,arguments);}return allowDerivativeRegistration;}()/**
   * method authority for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateAuthorityRequest
   * @return Promise<PiLicenseTemplateAuthorityResponse>
   */)},{key:"authority",value:(function(){var _authority3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee116(){return _regenerator().w(function(_context116){while(1)switch(_context116.n){case 0:_context116.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"authority"});case 1:return _context116.a(2,_context116.v);}},_callee116,this);}));function authority(){return _authority3.apply(this,arguments);}return authority;}()/**
   * method canAttachToGroupIp for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateCanAttachToGroupIpRequest
   * @return Promise<PiLicenseTemplateCanAttachToGroupIpResponse>
   */)},{key:"canAttachToGroupIp",value:(function(){var _canAttachToGroupIp=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee117(request){return _regenerator().w(function(_context117){while(1)switch(_context117.n){case 0:_context117.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"canAttachToGroupIp",args:[request.licenseTermsId]});case 1:return _context117.a(2,_context117.v);}},_callee117,this);}));function canAttachToGroupIp(_x83){return _canAttachToGroupIp.apply(this,arguments);}return canAttachToGroupIp;}()/**
   * method canOverrideRoyaltyPercent for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateCanOverrideRoyaltyPercentRequest
   * @return Promise<PiLicenseTemplateCanOverrideRoyaltyPercentResponse>
   */)},{key:"canOverrideRoyaltyPercent",value:(function(){var _canOverrideRoyaltyPercent=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee118(request){return _regenerator().w(function(_context118){while(1)switch(_context118.n){case 0:_context118.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"canOverrideRoyaltyPercent",args:[request.licenseTermsId,request.newRoyaltyPercent]});case 1:return _context118.a(2,_context118.v);}},_callee118,this);}));function canOverrideRoyaltyPercent(_x84){return _canOverrideRoyaltyPercent.apply(this,arguments);}return canOverrideRoyaltyPercent;}()/**
   * method exists for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateExistsRequest
   * @return Promise<PiLicenseTemplateExistsResponse>
   */)},{key:"exists",value:(function(){var _exists=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee119(request){return _regenerator().w(function(_context119){while(1)switch(_context119.n){case 0:_context119.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"exists",args:[request.licenseTermsId]});case 1:return _context119.a(2,_context119.v);}},_callee119,this);}));function exists(_x85){return _exists.apply(this,arguments);}return exists;}()/**
   * method getEarlierExpireTime for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetEarlierExpireTimeRequest
   * @return Promise<PiLicenseTemplateGetEarlierExpireTimeResponse>
   */)},{key:"getEarlierExpireTime",value:(function(){var _getEarlierExpireTime=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee120(request){return _regenerator().w(function(_context120){while(1)switch(_context120.n){case 0:_context120.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getEarlierExpireTime",args:[request.licenseTermsIds,request.start]});case 1:return _context120.a(2,_context120.v);}},_callee120,this);}));function getEarlierExpireTime(_x86){return _getEarlierExpireTime.apply(this,arguments);}return getEarlierExpireTime;}()/**
   * method getExpireTime for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetExpireTimeRequest
   * @return Promise<PiLicenseTemplateGetExpireTimeResponse>
   */)},{key:"getExpireTime",value:(function(){var _getExpireTime=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee121(request){return _regenerator().w(function(_context121){while(1)switch(_context121.n){case 0:_context121.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getExpireTime",args:[request.licenseTermsId,request.start]});case 1:return _context121.a(2,_context121.v);}},_callee121,this);}));function getExpireTime(_x87){return _getExpireTime.apply(this,arguments);}return getExpireTime;}()/**
   * method getLicenseTerms for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetLicenseTermsRequest
   * @return Promise<PiLicenseTemplateGetLicenseTermsResponse>
   */)},{key:"getLicenseTerms",value:(function(){var _getLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee122(request){var result;return _regenerator().w(function(_context122){while(1)switch(_context122.n){case 0:_context122.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getLicenseTerms",args:[request.selectedLicenseTermsId]});case 1:result=_context122.v;return _context122.a(2,{terms:result});}},_callee122,this);}));function getLicenseTerms(_x88){return _getLicenseTerms.apply(this,arguments);}return getLicenseTerms;}()/**
   * method getLicenseTermsId for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetLicenseTermsIdRequest
   * @return Promise<PiLicenseTemplateGetLicenseTermsIdResponse>
   */)},{key:"getLicenseTermsId",value:(function(){var _getLicenseTermsId=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee123(request){var result;return _regenerator().w(function(_context123){while(1)switch(_context123.n){case 0:_context123.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getLicenseTermsId",args:[request.terms]});case 1:result=_context123.v;return _context123.a(2,{selectedLicenseTermsId:result});}},_callee123,this);}));function getLicenseTermsId(_x89){return _getLicenseTermsId.apply(this,arguments);}return getLicenseTermsId;}()/**
   * method getLicenseTermsURI for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetLicenseTermsUriRequest
   * @return Promise<PiLicenseTemplateGetLicenseTermsUriResponse>
   */)},{key:"getLicenseTermsUri",value:(function(){var _getLicenseTermsUri=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee124(request){return _regenerator().w(function(_context124){while(1)switch(_context124.n){case 0:_context124.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getLicenseTermsURI",args:[request.licenseTermsId]});case 1:return _context124.a(2,_context124.v);}},_callee124,this);}));function getLicenseTermsUri(_x90){return _getLicenseTermsUri.apply(this,arguments);}return getLicenseTermsUri;}()/**
   * method getMetadataURI for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetMetadataUriRequest
   * @return Promise<PiLicenseTemplateGetMetadataUriResponse>
   */)},{key:"getMetadataUri",value:(function(){var _getMetadataUri=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee125(){return _regenerator().w(function(_context125){while(1)switch(_context125.n){case 0:_context125.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getMetadataURI"});case 1:return _context125.a(2,_context125.v);}},_callee125,this);}));function getMetadataUri(){return _getMetadataUri.apply(this,arguments);}return getMetadataUri;}()/**
   * method getRoyaltyPolicy for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateGetRoyaltyPolicyRequest
   * @return Promise<PiLicenseTemplateGetRoyaltyPolicyResponse>
   */)},{key:"getRoyaltyPolicy",value:(function(){var _getRoyaltyPolicy=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee126(request){var result;return _regenerator().w(function(_context126){while(1)switch(_context126.n){case 0:_context126.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"getRoyaltyPolicy",args:[request.licenseTermsId]});case 1:result=_context126.v;return _context126.a(2,{royaltyPolicy:result[0],royaltyPercent:result[1],mintingFee:result[2],currency:result[3]});}},_callee126,this);}));function getRoyaltyPolicy(_x91){return _getRoyaltyPolicy.apply(this,arguments);}return getRoyaltyPolicy;}()/**
   * method isConsumingScheduledOp for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIsConsumingScheduledOpRequest
   * @return Promise<PiLicenseTemplateIsConsumingScheduledOpResponse>
   */)},{key:"isConsumingScheduledOp",value:(function(){var _isConsumingScheduledOp3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee127(){return _regenerator().w(function(_context127){while(1)switch(_context127.n){case 0:_context127.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"isConsumingScheduledOp"});case 1:return _context127.a(2,_context127.v);}},_callee127,this);}));function isConsumingScheduledOp(){return _isConsumingScheduledOp3.apply(this,arguments);}return isConsumingScheduledOp;}()/**
   * method isDerivativeApproved for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIsDerivativeApprovedRequest
   * @return Promise<PiLicenseTemplateIsDerivativeApprovedResponse>
   */)},{key:"isDerivativeApproved",value:(function(){var _isDerivativeApproved=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee128(request){return _regenerator().w(function(_context128){while(1)switch(_context128.n){case 0:_context128.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"isDerivativeApproved",args:[request.parentIpId,request.licenseTermsId,request.childIpId]});case 1:return _context128.a(2,_context128.v);}},_callee128,this);}));function isDerivativeApproved(_x92){return _isDerivativeApproved.apply(this,arguments);}return isDerivativeApproved;}()/**
   * method isLicenseTransferable for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateIsLicenseTransferableRequest
   * @return Promise<PiLicenseTemplateIsLicenseTransferableResponse>
   */)},{key:"isLicenseTransferable",value:(function(){var _isLicenseTransferable=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee129(request){return _regenerator().w(function(_context129){while(1)switch(_context129.n){case 0:_context129.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"isLicenseTransferable",args:[request.licenseTermsId]});case 1:return _context129.a(2,_context129.v);}},_callee129,this);}));function isLicenseTransferable(_x93){return _isLicenseTransferable.apply(this,arguments);}return isLicenseTransferable;}()/**
   * method name for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateNameRequest
   * @return Promise<PiLicenseTemplateNameResponse>
   */)},{key:"name",value:(function(){var _name2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee130(){return _regenerator().w(function(_context130){while(1)switch(_context130.n){case 0:_context130.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"name"});case 1:return _context130.a(2,_context130.v);}},_callee130,this);}));function name(){return _name2.apply(this,arguments);}return name;}()/**
   * method proxiableUUID for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateProxiableUuidRequest
   * @return Promise<PiLicenseTemplateProxiableUuidResponse>
   */)},{key:"proxiableUuid",value:(function(){var _proxiableUuid3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee131(){return _regenerator().w(function(_context131){while(1)switch(_context131.n){case 0:_context131.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"proxiableUUID"});case 1:return _context131.a(2,_context131.v);}},_callee131,this);}));function proxiableUuid(){return _proxiableUuid3.apply(this,arguments);}return proxiableUuid;}()/**
   * method supportsInterface for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateSupportsInterfaceRequest
   * @return Promise<PiLicenseTemplateSupportsInterfaceResponse>
   */)},{key:"supportsInterface",value:(function(){var _supportsInterface2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee132(request){return _regenerator().w(function(_context132){while(1)switch(_context132.n){case 0:_context132.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"supportsInterface",args:[request.interfaceId]});case 1:return _context132.a(2,_context132.v);}},_callee132,this);}));function supportsInterface(_x94){return _supportsInterface2.apply(this,arguments);}return supportsInterface;}()/**
   * method toJson for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateToJsonRequest
   * @return Promise<PiLicenseTemplateToJsonResponse>
   */)},{key:"toJson",value:(function(){var _toJson=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee133(request){return _regenerator().w(function(_context133){while(1)switch(_context133.n){case 0:_context133.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"toJson",args:[request.licenseTermsId]});case 1:return _context133.a(2,_context133.v);}},_callee133,this);}));function toJson(_x95){return _toJson.apply(this,arguments);}return toJson;}()/**
   * method totalRegisteredLicenseTerms for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateTotalRegisteredLicenseTermsRequest
   * @return Promise<PiLicenseTemplateTotalRegisteredLicenseTermsResponse>
   */)},{key:"totalRegisteredLicenseTerms",value:(function(){var _totalRegisteredLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee134(){return _regenerator().w(function(_context134){while(1)switch(_context134.n){case 0:_context134.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"totalRegisteredLicenseTerms"});case 1:return _context134.a(2,_context134.v);}},_callee134,this);}));function totalRegisteredLicenseTerms(){return _totalRegisteredLicenseTerms.apply(this,arguments);}return totalRegisteredLicenseTerms;}()/**
   * method verifyCompatibleLicenses for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyCompatibleLicensesRequest
   * @return Promise<PiLicenseTemplateVerifyCompatibleLicensesResponse>
   */)},{key:"verifyCompatibleLicenses",value:(function(){var _verifyCompatibleLicenses=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee135(request){return _regenerator().w(function(_context135){while(1)switch(_context135.n){case 0:_context135.n=1;return this.rpcClient.readContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyCompatibleLicenses",args:[request.licenseTermsIds]});case 1:return _context135.a(2,_context135.v);}},_callee135,this);}));function verifyCompatibleLicenses(_x96){return _verifyCompatibleLicenses.apply(this,arguments);}return verifyCompatibleLicenses;}())}]);}(PiLicenseTemplateEventClient);/**
 * contract PILicenseTemplate write method
 */var PiLicenseTemplateClient=/*#__PURE__*/function(_PiLicenseTemplateRea){function PiLicenseTemplateClient(rpcClient,wallet,address){var _this10;_classCallCheck(this,PiLicenseTemplateClient);_this10=_callSuper(this,PiLicenseTemplateClient,[rpcClient,address]);_this10.wallet=wallet;return _this10;}/**
   * method initialize for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateInitializeRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(PiLicenseTemplateClient,_PiLicenseTemplateRea);return _createClass(PiLicenseTemplateClient,[{key:"initialize",value:(function(){var _initialize3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee136(request){var _yield$this$rpcClient59,call;return _regenerator().w(function(_context136){while(1)switch(_context136.n){case 0:_context136.n=1;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"initialize",account:this.wallet.account,args:[request.accessManager,request.name,request.metadataURI]});case 1:_yield$this$rpcClient59=_context136.v;call=_yield$this$rpcClient59.request;_context136.n=2;return this.wallet.writeContract(call);case 2:return _context136.a(2,_context136.v);}},_callee136,this);}));function initialize(_x97){return _initialize3.apply(this,arguments);}return initialize;}()/**
   * method initialize for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateInitializeRequest
   * @return EncodedTxData
   */)},{key:"initializeEncode",value:function initializeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"initialize",args:[request.accessManager,request.name,request.metadataURI]})};}/**
   * method registerLicenseTerms for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateRegisterLicenseTermsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerLicenseTerms",value:(function(){var _registerLicenseTerms=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee137(request){var _yield$this$rpcClient60,call;return _regenerator().w(function(_context137){while(1)switch(_context137.n){case 0:_context137.n=1;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"registerLicenseTerms",account:this.wallet.account,args:[request.terms]});case 1:_yield$this$rpcClient60=_context137.v;call=_yield$this$rpcClient60.request;_context137.n=2;return this.wallet.writeContract(call);case 2:return _context137.a(2,_context137.v);}},_callee137,this);}));function registerLicenseTerms(_x98){return _registerLicenseTerms.apply(this,arguments);}return registerLicenseTerms;}()/**
   * method registerLicenseTerms for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateRegisterLicenseTermsRequest
   * @return EncodedTxData
   */)},{key:"registerLicenseTermsEncode",value:function registerLicenseTermsEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"registerLicenseTerms",args:[request.terms]})};}/**
   * method setApproval for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateSetApprovalRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setApproval",value:(function(){var _setApproval=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee138(request){var _yield$this$rpcClient61,call;return _regenerator().w(function(_context138){while(1)switch(_context138.n){case 0:_context138.n=1;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"setApproval",account:this.wallet.account,args:[request.parentIpId,request.licenseTermsId,request.childIpId,request.approved]});case 1:_yield$this$rpcClient61=_context138.v;call=_yield$this$rpcClient61.request;_context138.n=2;return this.wallet.writeContract(call);case 2:return _context138.a(2,_context138.v);}},_callee138,this);}));function setApproval(_x99){return _setApproval.apply(this,arguments);}return setApproval;}()/**
   * method setApproval for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateSetApprovalRequest
   * @return EncodedTxData
   */)},{key:"setApprovalEncode",value:function setApprovalEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"setApproval",args:[request.parentIpId,request.licenseTermsId,request.childIpId,request.approved]})};}/**
   * method setAuthority for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateSetAuthorityRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"setAuthority",value:(function(){var _setAuthority3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee139(request){var _yield$this$rpcClient62,call;return _regenerator().w(function(_context139){while(1)switch(_context139.n){case 0:_context139.n=1;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"setAuthority",account:this.wallet.account,args:[request.newAuthority]});case 1:_yield$this$rpcClient62=_context139.v;call=_yield$this$rpcClient62.request;_context139.n=2;return this.wallet.writeContract(call);case 2:return _context139.a(2,_context139.v);}},_callee139,this);}));function setAuthority(_x100){return _setAuthority3.apply(this,arguments);}return setAuthority;}()/**
   * method setAuthority for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateSetAuthorityRequest
   * @return EncodedTxData
   */)},{key:"setAuthorityEncode",value:function setAuthorityEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"setAuthority",args:[request.newAuthority]})};}/**
   * method upgradeToAndCall for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateUpgradeToAndCallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"upgradeToAndCall",value:(function(){var _upgradeToAndCall3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee140(request){var _yield$this$rpcClient63,call;return _regenerator().w(function(_context140){while(1)switch(_context140.n){case 0:_context140.n=1;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"upgradeToAndCall",account:this.wallet.account,args:[request.newImplementation,request.data]});case 1:_yield$this$rpcClient63=_context140.v;call=_yield$this$rpcClient63.request;_context140.n=2;return this.wallet.writeContract(call);case 2:return _context140.a(2,_context140.v);}},_callee140,this);}));function upgradeToAndCall(_x101){return _upgradeToAndCall3.apply(this,arguments);}return upgradeToAndCall;}()/**
   * method upgradeToAndCall for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateUpgradeToAndCallRequest
   * @return EncodedTxData
   */)},{key:"upgradeToAndCallEncode",value:function upgradeToAndCallEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"upgradeToAndCall",args:[request.newImplementation,request.data]})};}/**
   * method verifyMintLicenseToken for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyMintLicenseTokenRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"verifyMintLicenseToken",value:(function(){var _verifyMintLicenseToken=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee141(request){var _yield$this$rpcClient64,call;return _regenerator().w(function(_context141){while(1)switch(_context141.n){case 0:_context141.n=1;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyMintLicenseToken",account:this.wallet.account,args:[request[0],request[1],request[2],request[3]]});case 1:_yield$this$rpcClient64=_context141.v;call=_yield$this$rpcClient64.request;_context141.n=2;return this.wallet.writeContract(call);case 2:return _context141.a(2,_context141.v);}},_callee141,this);}));function verifyMintLicenseToken(_x102){return _verifyMintLicenseToken.apply(this,arguments);}return verifyMintLicenseToken;}()/**
   * method verifyMintLicenseToken for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateVerifyMintLicenseTokenRequest
   * @return EncodedTxData
   */)},{key:"verifyMintLicenseTokenEncode",value:function verifyMintLicenseTokenEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"verifyMintLicenseToken",args:[request[0],request[1],request[2],request[3]]})};}/**
   * method verifyRegisterDerivative for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"verifyRegisterDerivative",value:(function(){var _verifyRegisterDerivative=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee142(request){var _yield$this$rpcClient65,call;return _regenerator().w(function(_context142){while(1)switch(_context142.n){case 0:_context142.n=1;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyRegisterDerivative",account:this.wallet.account,args:[request.childIpId,request.parentIpId,request.licenseTermsId,request.licensee]});case 1:_yield$this$rpcClient65=_context142.v;call=_yield$this$rpcClient65.request;_context142.n=2;return this.wallet.writeContract(call);case 2:return _context142.a(2,_context142.v);}},_callee142,this);}));function verifyRegisterDerivative(_x103){return _verifyRegisterDerivative.apply(this,arguments);}return verifyRegisterDerivative;}()/**
   * method verifyRegisterDerivative for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeRequest
   * @return EncodedTxData
   */)},{key:"verifyRegisterDerivativeEncode",value:function verifyRegisterDerivativeEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"verifyRegisterDerivative",args:[request.childIpId,request.parentIpId,request.licenseTermsId,request.licensee]})};}/**
   * method verifyRegisterDerivativeForAllParents for contract PILicenseTemplate
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"verifyRegisterDerivativeForAllParents",value:(function(){var _verifyRegisterDerivativeForAllParents=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee143(request){var _yield$this$rpcClient66,call;return _regenerator().w(function(_context143){while(1)switch(_context143.n){case 0:_context143.n=1;return this.rpcClient.simulateContract({abi:piLicenseTemplateAbi,address:this.address,functionName:"verifyRegisterDerivativeForAllParents",account:this.wallet.account,args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.caller]});case 1:_yield$this$rpcClient66=_context143.v;call=_yield$this$rpcClient66.request;_context143.n=2;return this.wallet.writeContract(call);case 2:return _context143.a(2,_context143.v);}},_callee143,this);}));function verifyRegisterDerivativeForAllParents(_x104){return _verifyRegisterDerivativeForAllParents.apply(this,arguments);}return verifyRegisterDerivativeForAllParents;}()/**
   * method verifyRegisterDerivativeForAllParents for contract PILicenseTemplate with only encode
   *
   * @param request PiLicenseTemplateVerifyRegisterDerivativeForAllParentsRequest
   * @return EncodedTxData
   */)},{key:"verifyRegisterDerivativeForAllParentsEncode",value:function verifyRegisterDerivativeForAllParentsEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:piLicenseTemplateAbi,functionName:"verifyRegisterDerivativeForAllParents",args:[request.childIpId,request.parentIpIds,request.licenseTermsIds,request.caller]})};}}]);}(PiLicenseTemplateReadOnlyClient);// Contract RegistrationWorkflows =============================================================
/**
 * RegistrationWorkflowsCollectionCreatedEvent
 *
 * @param spgNftContract address
 *//**
 * RegistrationWorkflowsCreateCollectionRequest
 *
 * @param spgNftInitParams tuple
 *//**
 * RegistrationWorkflowsMintAndRegisterIpRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param allowDuplicates bool
 *//**
 * RegistrationWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * RegistrationWorkflowsRegisterIpRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param sigMetadata tuple
 *//**
 * contract RegistrationWorkflows event
 */var RegistrationWorkflowsEventClient=/*#__PURE__*/function(){function RegistrationWorkflowsEventClient(rpcClient,address){var _rpcClient$chain18;_classCallCheck(this,RegistrationWorkflowsEventClient);this.address=address||getAddress(registrationWorkflowsAddress,(_rpcClient$chain18=rpcClient.chain)===null||_rpcClient$chain18===void 0?void 0:_rpcClient$chain18.id);this.rpcClient=rpcClient;}/**
   * event CollectionCreated for contract RegistrationWorkflows
   */return _createClass(RegistrationWorkflowsEventClient,[{key:"watchCollectionCreatedEvent",value:function watchCollectionCreatedEvent(_onLogs27){return this.rpcClient.watchContractEvent({abi:registrationWorkflowsAbi,address:this.address,eventName:"CollectionCreated",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs27(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event CollectionCreated for contract RegistrationWorkflows
   */},{key:"parseTxCollectionCreatedEvent",value:function parseTxCollectionCreatedEvent(txReceipt){var targetLogs=[];var _iterator27=_createForOfIteratorHelper(txReceipt.logs),_step27;try{for(_iterator27.s();!(_step27=_iterator27.n()).done;){var log=_step27.value;try{var event=viem.decodeEventLog({abi:registrationWorkflowsAbi,eventName:"CollectionCreated",data:log.data,topics:log.topics});if(event.eventName==="CollectionCreated"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator27.e(err);}finally{_iterator27.f();}return targetLogs;}}]);}();/**
 * contract RegistrationWorkflows write method
 */var RegistrationWorkflowsClient=/*#__PURE__*/function(_RegistrationWorkflow){function RegistrationWorkflowsClient(rpcClient,wallet,address){var _this11;_classCallCheck(this,RegistrationWorkflowsClient);_this11=_callSuper(this,RegistrationWorkflowsClient,[rpcClient,address]);_this11.wallet=wallet;return _this11;}/**
   * method createCollection for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsCreateCollectionRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(RegistrationWorkflowsClient,_RegistrationWorkflow);return _createClass(RegistrationWorkflowsClient,[{key:"createCollection",value:(function(){var _createCollection=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee144(request){var _yield$this$rpcClient67,call;return _regenerator().w(function(_context144){while(1)switch(_context144.n){case 0:_context144.n=1;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"createCollection",account:this.wallet.account,args:[request.spgNftInitParams]});case 1:_yield$this$rpcClient67=_context144.v;call=_yield$this$rpcClient67.request;_context144.n=2;return this.wallet.writeContract(call);case 2:return _context144.a(2,_context144.v);}},_callee144,this);}));function createCollection(_x105){return _createCollection.apply(this,arguments);}return createCollection;}()/**
   * method createCollection for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsCreateCollectionRequest
   * @return EncodedTxData
   */)},{key:"createCollectionEncode",value:function createCollectionEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"createCollection",args:[request.spgNftInitParams]})};}/**
   * method mintAndRegisterIp for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsMintAndRegisterIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIp",value:(function(){var _mintAndRegisterIp=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee145(request){var _yield$this$rpcClient68,call;return _regenerator().w(function(_context145){while(1)switch(_context145.n){case 0:_context145.n=1;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIp",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.allowDuplicates]});case 1:_yield$this$rpcClient68=_context145.v;call=_yield$this$rpcClient68.request;_context145.n=2;return this.wallet.writeContract(call);case 2:return _context145.a(2,_context145.v);}},_callee145,this);}));function mintAndRegisterIp(_x106){return _mintAndRegisterIp.apply(this,arguments);}return mintAndRegisterIp;}()/**
   * method mintAndRegisterIp for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsMintAndRegisterIpRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpEncode",value:function mintAndRegisterIpEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"mintAndRegisterIp",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.allowDuplicates]})};}/**
   * method multicall for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee146(request){var _yield$this$rpcClient69,call;return _regenerator().w(function(_context146){while(1)switch(_context146.n){case 0:_context146.n=1;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 1:_yield$this$rpcClient69=_context146.v;call=_yield$this$rpcClient69.request;_context146.n=2;return this.wallet.writeContract(call);case 2:return _context146.a(2,_context146.v);}},_callee146,this);}));function multicall(_x107){return _multicall3.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIp for contract RegistrationWorkflows
   *
   * @param request RegistrationWorkflowsRegisterIpRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIp",value:(function(){var _registerIp=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee147(request){var _yield$this$rpcClient70,call;return _regenerator().w(function(_context147){while(1)switch(_context147.n){case 0:_context147.n=1;return this.rpcClient.simulateContract({abi:registrationWorkflowsAbi,address:this.address,functionName:"registerIp",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.sigMetadata]});case 1:_yield$this$rpcClient70=_context147.v;call=_yield$this$rpcClient70.request;_context147.n=2;return this.wallet.writeContract(call);case 2:return _context147.a(2,_context147.v);}},_callee147,this);}));function registerIp(_x108){return _registerIp.apply(this,arguments);}return registerIp;}()/**
   * method registerIp for contract RegistrationWorkflows with only encode
   *
   * @param request RegistrationWorkflowsRegisterIpRequest
   * @return EncodedTxData
   */)},{key:"registerIpEncode",value:function registerIpEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:registrationWorkflowsAbi,functionName:"registerIp",args:[request.nftContract,request.tokenId,request.ipMetadata,request.sigMetadata]})};}}]);}(RegistrationWorkflowsEventClient);// Contract RoyaltyModule =============================================================
/**
 * RoyaltyModuleIpRoyaltyVaultDeployedEvent
 *
 * @param ipId address
 * @param ipRoyaltyVault address
 *//**
 * RoyaltyModuleRoyaltyPaidEvent
 *
 * @param receiverIpId address
 * @param payerIpId address
 * @param sender address
 * @param token address
 * @param amount uint256
 * @param amountAfterFee uint256
 *//**
 * RoyaltyModuleIpRoyaltyVaultsRequest
 *
 * @param ipId address
 *//**
 * RoyaltyModuleIsWhitelistedRoyaltyPolicyRequest
 *
 * @param royaltyPolicy address
 *//**
 * RoyaltyModuleIsWhitelistedRoyaltyTokenRequest
 *
 * @param token address
 *//**
 * RoyaltyModulePayRoyaltyOnBehalfRequest
 *
 * @param receiverIpId address
 * @param payerIpId address
 * @param token address
 * @param amount uint256
 *//**
 * contract RoyaltyModule event
 */var RoyaltyModuleEventClient=/*#__PURE__*/function(){function RoyaltyModuleEventClient(rpcClient,address){var _rpcClient$chain19;_classCallCheck(this,RoyaltyModuleEventClient);this.address=address||getAddress(royaltyModuleAddress,(_rpcClient$chain19=rpcClient.chain)===null||_rpcClient$chain19===void 0?void 0:_rpcClient$chain19.id);this.rpcClient=rpcClient;}/**
   * event IpRoyaltyVaultDeployed for contract RoyaltyModule
   */return _createClass(RoyaltyModuleEventClient,[{key:"watchIpRoyaltyVaultDeployedEvent",value:function watchIpRoyaltyVaultDeployedEvent(_onLogs28){return this.rpcClient.watchContractEvent({abi:royaltyModuleAbi,address:this.address,eventName:"IpRoyaltyVaultDeployed",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs28(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event IpRoyaltyVaultDeployed for contract RoyaltyModule
   */},{key:"parseTxIpRoyaltyVaultDeployedEvent",value:function parseTxIpRoyaltyVaultDeployedEvent(txReceipt){var targetLogs=[];var _iterator28=_createForOfIteratorHelper(txReceipt.logs),_step28;try{for(_iterator28.s();!(_step28=_iterator28.n()).done;){var log=_step28.value;try{var event=viem.decodeEventLog({abi:royaltyModuleAbi,eventName:"IpRoyaltyVaultDeployed",data:log.data,topics:log.topics});if(event.eventName==="IpRoyaltyVaultDeployed"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator28.e(err);}finally{_iterator28.f();}return targetLogs;}/**
   * event RoyaltyPaid for contract RoyaltyModule
   */},{key:"watchRoyaltyPaidEvent",value:function watchRoyaltyPaidEvent(_onLogs29){return this.rpcClient.watchContractEvent({abi:royaltyModuleAbi,address:this.address,eventName:"RoyaltyPaid",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs29(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event RoyaltyPaid for contract RoyaltyModule
   */},{key:"parseTxRoyaltyPaidEvent",value:function parseTxRoyaltyPaidEvent(txReceipt){var targetLogs=[];var _iterator29=_createForOfIteratorHelper(txReceipt.logs),_step29;try{for(_iterator29.s();!(_step29=_iterator29.n()).done;){var log=_step29.value;try{var event=viem.decodeEventLog({abi:royaltyModuleAbi,eventName:"RoyaltyPaid",data:log.data,topics:log.topics});if(event.eventName==="RoyaltyPaid"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator29.e(err);}finally{_iterator29.f();}return targetLogs;}}]);}();/**
 * contract RoyaltyModule readonly method
 */var RoyaltyModuleReadOnlyClient=/*#__PURE__*/function(_RoyaltyModuleEventCl){function RoyaltyModuleReadOnlyClient(rpcClient,address){_classCallCheck(this,RoyaltyModuleReadOnlyClient);return _callSuper(this,RoyaltyModuleReadOnlyClient,[rpcClient,address]);}/**
   * method ipRoyaltyVaults for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIpRoyaltyVaultsRequest
   * @return Promise<RoyaltyModuleIpRoyaltyVaultsResponse>
   */_inherits(RoyaltyModuleReadOnlyClient,_RoyaltyModuleEventCl);return _createClass(RoyaltyModuleReadOnlyClient,[{key:"ipRoyaltyVaults",value:(function(){var _ipRoyaltyVaults=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee148(request){return _regenerator().w(function(_context148){while(1)switch(_context148.n){case 0:_context148.n=1;return this.rpcClient.readContract({abi:royaltyModuleAbi,address:this.address,functionName:"ipRoyaltyVaults",args:[request.ipId]});case 1:return _context148.a(2,_context148.v);}},_callee148,this);}));function ipRoyaltyVaults(_x109){return _ipRoyaltyVaults.apply(this,arguments);}return ipRoyaltyVaults;}()/**
   * method isWhitelistedRoyaltyPolicy for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIsWhitelistedRoyaltyPolicyRequest
   * @return Promise<RoyaltyModuleIsWhitelistedRoyaltyPolicyResponse>
   */)},{key:"isWhitelistedRoyaltyPolicy",value:(function(){var _isWhitelistedRoyaltyPolicy=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee149(request){return _regenerator().w(function(_context149){while(1)switch(_context149.n){case 0:_context149.n=1;return this.rpcClient.readContract({abi:royaltyModuleAbi,address:this.address,functionName:"isWhitelistedRoyaltyPolicy",args:[request.royaltyPolicy]});case 1:return _context149.a(2,_context149.v);}},_callee149,this);}));function isWhitelistedRoyaltyPolicy(_x110){return _isWhitelistedRoyaltyPolicy.apply(this,arguments);}return isWhitelistedRoyaltyPolicy;}()/**
   * method isWhitelistedRoyaltyToken for contract RoyaltyModule
   *
   * @param request RoyaltyModuleIsWhitelistedRoyaltyTokenRequest
   * @return Promise<RoyaltyModuleIsWhitelistedRoyaltyTokenResponse>
   */)},{key:"isWhitelistedRoyaltyToken",value:(function(){var _isWhitelistedRoyaltyToken=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee150(request){return _regenerator().w(function(_context150){while(1)switch(_context150.n){case 0:_context150.n=1;return this.rpcClient.readContract({abi:royaltyModuleAbi,address:this.address,functionName:"isWhitelistedRoyaltyToken",args:[request.token]});case 1:return _context150.a(2,_context150.v);}},_callee150,this);}));function isWhitelistedRoyaltyToken(_x111){return _isWhitelistedRoyaltyToken.apply(this,arguments);}return isWhitelistedRoyaltyToken;}())}]);}(RoyaltyModuleEventClient);/**
 * contract RoyaltyModule write method
 */var RoyaltyModuleClient=/*#__PURE__*/function(_RoyaltyModuleReadOnl){function RoyaltyModuleClient(rpcClient,wallet,address){var _this12;_classCallCheck(this,RoyaltyModuleClient);_this12=_callSuper(this,RoyaltyModuleClient,[rpcClient,address]);_this12.wallet=wallet;return _this12;}/**
   * method payRoyaltyOnBehalf for contract RoyaltyModule
   *
   * @param request RoyaltyModulePayRoyaltyOnBehalfRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(RoyaltyModuleClient,_RoyaltyModuleReadOnl);return _createClass(RoyaltyModuleClient,[{key:"payRoyaltyOnBehalf",value:(function(){var _payRoyaltyOnBehalf=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee151(request){var _yield$this$rpcClient71,call;return _regenerator().w(function(_context151){while(1)switch(_context151.n){case 0:_context151.n=1;return this.rpcClient.simulateContract({abi:royaltyModuleAbi,address:this.address,functionName:"payRoyaltyOnBehalf",account:this.wallet.account,args:[request.receiverIpId,request.payerIpId,request.token,request.amount]});case 1:_yield$this$rpcClient71=_context151.v;call=_yield$this$rpcClient71.request;_context151.n=2;return this.wallet.writeContract(call);case 2:return _context151.a(2,_context151.v);}},_callee151,this);}));function payRoyaltyOnBehalf(_x112){return _payRoyaltyOnBehalf.apply(this,arguments);}return payRoyaltyOnBehalf;}()/**
   * method payRoyaltyOnBehalf for contract RoyaltyModule with only encode
   *
   * @param request RoyaltyModulePayRoyaltyOnBehalfRequest
   * @return EncodedTxData
   */)},{key:"payRoyaltyOnBehalfEncode",value:function payRoyaltyOnBehalfEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:royaltyModuleAbi,functionName:"payRoyaltyOnBehalf",args:[request.receiverIpId,request.payerIpId,request.token,request.amount]})};}}]);}(RoyaltyModuleReadOnlyClient);// Contract RoyaltyPolicyLAP =============================================================
/**
 * RoyaltyTokenDistributionWorkflowsDistributeRoyaltyTokensRequest
 *
 * @param ipId address
 * @param royaltyShares tuple[]
 * @param sigApproveRoyaltyTokens tuple
 *//**
 * RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param royaltyShares tuple[]
 * @param allowDuplicates bool
 *//**
 * RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest
 *
 * @param spgNftContract address
 * @param recipient address
 * @param ipMetadata tuple
 * @param derivData tuple
 * @param royaltyShares tuple[]
 * @param allowDuplicates bool
 *//**
 * RoyaltyTokenDistributionWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * RoyaltyTokenDistributionWorkflowsRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param licenseTermsData tuple[]
 * @param sigMetadataAndAttachAndConfig tuple
 *//**
 * RoyaltyTokenDistributionWorkflowsRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest
 *
 * @param nftContract address
 * @param tokenId uint256
 * @param ipMetadata tuple
 * @param derivData tuple
 * @param sigMetadataAndRegister tuple
 *//**
 * contract RoyaltyTokenDistributionWorkflows write method
 */var RoyaltyTokenDistributionWorkflowsClient=/*#__PURE__*/function(){function RoyaltyTokenDistributionWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain21;_classCallCheck(this,RoyaltyTokenDistributionWorkflowsClient);this.address=address||getAddress(royaltyTokenDistributionWorkflowsAddress,(_rpcClient$chain21=rpcClient.chain)===null||_rpcClient$chain21===void 0?void 0:_rpcClient$chain21.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method distributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsDistributeRoyaltyTokensRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(RoyaltyTokenDistributionWorkflowsClient,[{key:"distributeRoyaltyTokens",value:(function(){var _distributeRoyaltyTokens=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee175(request){var _yield$this$rpcClient82,call;return _regenerator().w(function(_context175){while(1)switch(_context175.n){case 0:_context175.n=1;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"distributeRoyaltyTokens",account:this.wallet.account,args:[request.ipId,request.royaltyShares,request.sigApproveRoyaltyTokens]});case 1:_yield$this$rpcClient82=_context175.v;call=_yield$this$rpcClient82.request;_context175.n=2;return this.wallet.writeContract(call);case 2:return _context175.a(2,_context175.v);}},_callee175,this);}));function distributeRoyaltyTokens(_x124){return _distributeRoyaltyTokens.apply(this,arguments);}return distributeRoyaltyTokens;}()/**
   * method distributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsDistributeRoyaltyTokensRequest
   * @return EncodedTxData
   */)},{key:"distributeRoyaltyTokensEncode",value:function distributeRoyaltyTokensEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"distributeRoyaltyTokens",args:[request.ipId,request.royaltyShares,request.sigApproveRoyaltyTokens]})};}/**
   * method mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens",value:(function(){var _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee176(request){var _yield$this$rpcClient83,call;return _regenerator().w(function(_context176){while(1)switch(_context176.n){case 0:_context176.n=1;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.royaltyShares,request.allowDuplicates]});case 1:_yield$this$rpcClient83=_context176.v;call=_yield$this$rpcClient83.request;_context176.n=2;return this.wallet.writeContract(call);case 2:return _context176.a(2,_context176.v);}},_callee176,this);}));function mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_x125){return _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens.apply(this,arguments);}return mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens;}()/**
   * method mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensEncode",value:function mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.licenseTermsData,request.royaltyShares,request.allowDuplicates]})};}/**
   * method mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",value:(function(){var _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee177(request){var _yield$this$rpcClient84,call;return _regenerator().w(function(_context177){while(1)switch(_context177.n){case 0:_context177.n=1;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",account:this.wallet.account,args:[request.spgNftContract,request.recipient,request.ipMetadata,request.derivData,request.royaltyShares,request.allowDuplicates]});case 1:_yield$this$rpcClient84=_context177.v;call=_yield$this$rpcClient84.request;_context177.n=2;return this.wallet.writeContract(call);case 2:return _context177.a(2,_context177.v);}},_callee177,this);}));function mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_x126){return _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens.apply(this,arguments);}return mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens;}()/**
   * method mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest
   * @return EncodedTxData
   */)},{key:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensEncode",value:function mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",args:[request.spgNftContract,request.recipient,request.ipMetadata,request.derivData,request.royaltyShares,request.allowDuplicates]})};}/**
   * method multicall for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall4=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee178(request){var _yield$this$rpcClient85,call;return _regenerator().w(function(_context178){while(1)switch(_context178.n){case 0:_context178.n=1;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 1:_yield$this$rpcClient85=_context178.v;call=_yield$this$rpcClient85.request;_context178.n=2;return this.wallet.writeContract(call);case 2:return _context178.a(2,_context178.v);}},_callee178,this);}));function multicall(_x127){return _multicall4.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"multicall",args:[request.data]})};}/**
   * method registerIpAndAttachPILTermsAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndAttachPilTermsAndDeployRoyaltyVault",value:(function(){var _registerIpAndAttachPilTermsAndDeployRoyaltyVault=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee179(request){var _yield$this$rpcClient86,call;return _regenerator().w(function(_context179){while(1)switch(_context179.n){case 0:_context179.n=1;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"registerIpAndAttachPILTermsAndDeployRoyaltyVault",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]});case 1:_yield$this$rpcClient86=_context179.v;call=_yield$this$rpcClient86.request;_context179.n=2;return this.wallet.writeContract(call);case 2:return _context179.a(2,_context179.v);}},_callee179,this);}));function registerIpAndAttachPilTermsAndDeployRoyaltyVault(_x128){return _registerIpAndAttachPilTermsAndDeployRoyaltyVault.apply(this,arguments);}return registerIpAndAttachPilTermsAndDeployRoyaltyVault;}()/**
   * method registerIpAndAttachPILTermsAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndAttachPilTermsAndDeployRoyaltyVaultEncode",value:function registerIpAndAttachPilTermsAndDeployRoyaltyVaultEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"registerIpAndAttachPILTermsAndDeployRoyaltyVault",args:[request.nftContract,request.tokenId,request.ipMetadata,request.licenseTermsData,request.sigMetadataAndAttachAndConfig]})};}/**
   * method registerIpAndMakeDerivativeAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",value:(function(){var _registerIpAndMakeDerivativeAndDeployRoyaltyVault=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee180(request){var _yield$this$rpcClient87,call;return _regenerator().w(function(_context180){while(1)switch(_context180.n){case 0:_context180.n=1;return this.rpcClient.simulateContract({abi:royaltyTokenDistributionWorkflowsAbi,address:this.address,functionName:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",account:this.wallet.account,args:[request.nftContract,request.tokenId,request.ipMetadata,request.derivData,request.sigMetadataAndRegister]});case 1:_yield$this$rpcClient87=_context180.v;call=_yield$this$rpcClient87.request;_context180.n=2;return this.wallet.writeContract(call);case 2:return _context180.a(2,_context180.v);}},_callee180,this);}));function registerIpAndMakeDerivativeAndDeployRoyaltyVault(_x129){return _registerIpAndMakeDerivativeAndDeployRoyaltyVault.apply(this,arguments);}return registerIpAndMakeDerivativeAndDeployRoyaltyVault;}()/**
   * method registerIpAndMakeDerivativeAndDeployRoyaltyVault for contract RoyaltyTokenDistributionWorkflows with only encode
   *
   * @param request RoyaltyTokenDistributionWorkflowsRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest
   * @return EncodedTxData
   */)},{key:"registerIpAndMakeDerivativeAndDeployRoyaltyVaultEncode",value:function registerIpAndMakeDerivativeAndDeployRoyaltyVaultEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:royaltyTokenDistributionWorkflowsAbi,functionName:"registerIpAndMakeDerivativeAndDeployRoyaltyVault",args:[request.nftContract,request.tokenId,request.ipMetadata,request.derivData,request.sigMetadataAndRegister]})};}}]);}();// Contract RoyaltyWorkflows =============================================================
/**
 * RoyaltyWorkflowsClaimAllRevenueRequest
 *
 * @param ancestorIpId address
 * @param claimer address
 * @param childIpIds address[]
 * @param royaltyPolicies address[]
 * @param currencyTokens address[]
 *//**
 * RoyaltyWorkflowsMulticallRequest
 *
 * @param data bytes[]
 *//**
 * contract RoyaltyWorkflows write method
 */var RoyaltyWorkflowsClient=/*#__PURE__*/function(){function RoyaltyWorkflowsClient(rpcClient,wallet,address){var _rpcClient$chain22;_classCallCheck(this,RoyaltyWorkflowsClient);this.address=address||getAddress(royaltyWorkflowsAddress,(_rpcClient$chain22=rpcClient.chain)===null||_rpcClient$chain22===void 0?void 0:_rpcClient$chain22.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method claimAllRevenue for contract RoyaltyWorkflows
   *
   * @param request RoyaltyWorkflowsClaimAllRevenueRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(RoyaltyWorkflowsClient,[{key:"claimAllRevenue",value:(function(){var _claimAllRevenue=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee181(request){var _yield$this$rpcClient88,call;return _regenerator().w(function(_context181){while(1)switch(_context181.n){case 0:_context181.n=1;return this.rpcClient.simulateContract({abi:royaltyWorkflowsAbi,address:this.address,functionName:"claimAllRevenue",account:this.wallet.account,args:[request.ancestorIpId,request.claimer,request.childIpIds,request.royaltyPolicies,request.currencyTokens]});case 1:_yield$this$rpcClient88=_context181.v;call=_yield$this$rpcClient88.request;_context181.n=2;return this.wallet.writeContract(call);case 2:return _context181.a(2,_context181.v);}},_callee181,this);}));function claimAllRevenue(_x130){return _claimAllRevenue.apply(this,arguments);}return claimAllRevenue;}()/**
   * method claimAllRevenue for contract RoyaltyWorkflows with only encode
   *
   * @param request RoyaltyWorkflowsClaimAllRevenueRequest
   * @return EncodedTxData
   */)},{key:"claimAllRevenueEncode",value:function claimAllRevenueEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:royaltyWorkflowsAbi,functionName:"claimAllRevenue",args:[request.ancestorIpId,request.claimer,request.childIpIds,request.royaltyPolicies,request.currencyTokens]})};}/**
   * method multicall for contract RoyaltyWorkflows
   *
   * @param request RoyaltyWorkflowsMulticallRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"multicall",value:(function(){var _multicall5=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee182(request){var _yield$this$rpcClient89,call;return _regenerator().w(function(_context182){while(1)switch(_context182.n){case 0:_context182.n=1;return this.rpcClient.simulateContract({abi:royaltyWorkflowsAbi,address:this.address,functionName:"multicall",account:this.wallet.account,args:[request.data]});case 1:_yield$this$rpcClient89=_context182.v;call=_yield$this$rpcClient89.request;_context182.n=2;return this.wallet.writeContract(call);case 2:return _context182.a(2,_context182.v);}},_callee182,this);}));function multicall(_x131){return _multicall5.apply(this,arguments);}return multicall;}()/**
   * method multicall for contract RoyaltyWorkflows with only encode
   *
   * @param request RoyaltyWorkflowsMulticallRequest
   * @return EncodedTxData
   */)},{key:"multicallEncode",value:function multicallEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:royaltyWorkflowsAbi,functionName:"multicall",args:[request.data]})};}}]);}();// Contract SPGNFTBeacon =============================================================
/**
 * SpgnftImplTransferEvent
 *
 * @param from address
 * @param to address
 * @param tokenId uint256
 *//**
 * SpgnftImplHasRoleRequest
 *
 * @param role bytes32
 * @param account address
 *//**
 * SpgnftImplTokenUriRequest
 *
 * @param tokenId uint256
 *//**
 * SpgnftImplSetTokenUriRequest
 *
 * @param tokenId uint256
 * @param tokenUri string
 *//**
 * contract SPGNFTImpl event
 */var SpgnftImplEventClient=/*#__PURE__*/function(){function SpgnftImplEventClient(rpcClient,address){var _rpcClient$chain24;_classCallCheck(this,SpgnftImplEventClient);this.address=address||getAddress(spgnftImplAddress,(_rpcClient$chain24=rpcClient.chain)===null||_rpcClient$chain24===void 0?void 0:_rpcClient$chain24.id);this.rpcClient=rpcClient;}/**
   * event Transfer for contract SPGNFTImpl
   */return _createClass(SpgnftImplEventClient,[{key:"watchTransferEvent",value:function watchTransferEvent(_onLogs38){return this.rpcClient.watchContractEvent({abi:spgnftImplAbi,address:this.address,eventName:"Transfer",onLogs:function onLogs(evs){evs.forEach(function(it){return _onLogs38(it.transactionHash,it.args);});}});}/**
   * parse tx receipt event Transfer for contract SPGNFTImpl
   */},{key:"parseTxTransferEvent",value:function parseTxTransferEvent(txReceipt){var targetLogs=[];var _iterator38=_createForOfIteratorHelper(txReceipt.logs),_step38;try{for(_iterator38.s();!(_step38=_iterator38.n()).done;){var log=_step38.value;try{var event=viem.decodeEventLog({abi:spgnftImplAbi,eventName:"Transfer",data:log.data,topics:log.topics});if(event.eventName==="Transfer"){targetLogs.push(event.args);}}catch(e){/* empty */}}}catch(err){_iterator38.e(err);}finally{_iterator38.f();}return targetLogs;}}]);}();/**
 * contract SPGNFTImpl readonly method
 */var SpgnftImplReadOnlyClient=/*#__PURE__*/function(_SpgnftImplEventClien){function SpgnftImplReadOnlyClient(rpcClient,address){_classCallCheck(this,SpgnftImplReadOnlyClient);return _callSuper(this,SpgnftImplReadOnlyClient,[rpcClient,address]);}/**
   * method hasRole for contract SPGNFTImpl
   *
   * @param request SpgnftImplHasRoleRequest
   * @return Promise<SpgnftImplHasRoleResponse>
   */_inherits(SpgnftImplReadOnlyClient,_SpgnftImplEventClien);return _createClass(SpgnftImplReadOnlyClient,[{key:"hasRole",value:(function(){var _hasRole=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee188(request){return _regenerator().w(function(_context188){while(1)switch(_context188.n){case 0:_context188.n=1;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"hasRole",args:[request.role,request.account]});case 1:return _context188.a(2,_context188.v);}},_callee188,this);}));function hasRole(_x134){return _hasRole.apply(this,arguments);}return hasRole;}()/**
   * method mintFee for contract SPGNFTImpl
   *
   * @param request SpgnftImplMintFeeRequest
   * @return Promise<SpgnftImplMintFeeResponse>
   */)},{key:"mintFee",value:(function(){var _mintFee=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee189(){return _regenerator().w(function(_context189){while(1)switch(_context189.n){case 0:_context189.n=1;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"mintFee"});case 1:return _context189.a(2,_context189.v);}},_callee189,this);}));function mintFee(){return _mintFee.apply(this,arguments);}return mintFee;}()/**
   * method mintFeeToken for contract SPGNFTImpl
   *
   * @param request SpgnftImplMintFeeTokenRequest
   * @return Promise<SpgnftImplMintFeeTokenResponse>
   */)},{key:"mintFeeToken",value:(function(){var _mintFeeToken=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee190(){return _regenerator().w(function(_context190){while(1)switch(_context190.n){case 0:_context190.n=1;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"mintFeeToken"});case 1:return _context190.a(2,_context190.v);}},_callee190,this);}));function mintFeeToken(){return _mintFeeToken.apply(this,arguments);}return mintFeeToken;}()/**
   * method publicMinting for contract SPGNFTImpl
   *
   * @param request SpgnftImplPublicMintingRequest
   * @return Promise<SpgnftImplPublicMintingResponse>
   */)},{key:"publicMinting",value:(function(){var _publicMinting=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee191(){return _regenerator().w(function(_context191){while(1)switch(_context191.n){case 0:_context191.n=1;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"publicMinting"});case 1:return _context191.a(2,_context191.v);}},_callee191,this);}));function publicMinting(){return _publicMinting.apply(this,arguments);}return publicMinting;}()/**
   * method tokenURI for contract SPGNFTImpl
   *
   * @param request SpgnftImplTokenUriRequest
   * @return Promise<SpgnftImplTokenUriResponse>
   */)},{key:"tokenUri",value:(function(){var _tokenUri=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee192(request){return _regenerator().w(function(_context192){while(1)switch(_context192.n){case 0:_context192.n=1;return this.rpcClient.readContract({abi:spgnftImplAbi,address:this.address,functionName:"tokenURI",args:[request.tokenId]});case 1:return _context192.a(2,_context192.v);}},_callee192,this);}));function tokenUri(_x135){return _tokenUri.apply(this,arguments);}return tokenUri;}())}]);}(SpgnftImplEventClient);/**
 * contract SPGNFTImpl write method
 */var SpgnftImplClient=/*#__PURE__*/function(_SpgnftImplReadOnlyCl){function SpgnftImplClient(rpcClient,wallet,address){var _this15;_classCallCheck(this,SpgnftImplClient);_this15=_callSuper(this,SpgnftImplClient,[rpcClient,address]);_this15.wallet=wallet;return _this15;}/**
   * method setTokenURI for contract SPGNFTImpl
   *
   * @param request SpgnftImplSetTokenUriRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(SpgnftImplClient,_SpgnftImplReadOnlyCl);return _createClass(SpgnftImplClient,[{key:"setTokenUri",value:(function(){var _setTokenUri=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee193(request){var _yield$this$rpcClient93,call;return _regenerator().w(function(_context193){while(1)switch(_context193.n){case 0:_context193.n=1;return this.rpcClient.simulateContract({abi:spgnftImplAbi,address:this.address,functionName:"setTokenURI",account:this.wallet.account,args:[request.tokenId,request.tokenUri]});case 1:_yield$this$rpcClient93=_context193.v;call=_yield$this$rpcClient93.request;_context193.n=2;return this.wallet.writeContract(call);case 2:return _context193.a(2,_context193.v);}},_callee193,this);}));function setTokenUri(_x136){return _setTokenUri.apply(this,arguments);}return setTokenUri;}()/**
   * method setTokenURI for contract SPGNFTImpl with only encode
   *
   * @param request SpgnftImplSetTokenUriRequest
   * @return EncodedTxData
   */)},{key:"setTokenUriEncode",value:function setTokenUriEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:spgnftImplAbi,functionName:"setTokenURI",args:[request.tokenId,request.tokenUri]})};}}]);}(SpgnftImplReadOnlyClient);// Contract TotalLicenseTokenLimitHook =============================================================
/**
 * TotalLicenseTokenLimitHookSetTotalLicenseTokenLimitRequest
 *
 * @param licensorIpId address
 * @param licenseTemplate address
 * @param licenseTermsId uint256
 * @param limit uint256
 *//**
 * contract TotalLicenseTokenLimitHook write method
 */var TotalLicenseTokenLimitHookClient=/*#__PURE__*/function(){function TotalLicenseTokenLimitHookClient(rpcClient,wallet,address){var _rpcClient$chain25;_classCallCheck(this,TotalLicenseTokenLimitHookClient);this.address=address||getAddress(totalLicenseTokenLimitHookAddress,(_rpcClient$chain25=rpcClient.chain)===null||_rpcClient$chain25===void 0?void 0:_rpcClient$chain25.id);this.rpcClient=rpcClient;this.wallet=wallet;}/**
   * method setTotalLicenseTokenLimit for contract TotalLicenseTokenLimitHook
   *
   * @param request TotalLicenseTokenLimitHookSetTotalLicenseTokenLimitRequest
   * @return Promise<WriteContractReturnType>
   */return _createClass(TotalLicenseTokenLimitHookClient,[{key:"setTotalLicenseTokenLimit",value:(function(){var _setTotalLicenseTokenLimit=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee194(request){var _yield$this$rpcClient94,call;return _regenerator().w(function(_context194){while(1)switch(_context194.n){case 0:_context194.n=1;return this.rpcClient.simulateContract({abi:totalLicenseTokenLimitHookAbi,address:this.address,functionName:"setTotalLicenseTokenLimit",account:this.wallet.account,args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.limit]});case 1:_yield$this$rpcClient94=_context194.v;call=_yield$this$rpcClient94.request;_context194.n=2;return this.wallet.writeContract(call);case 2:return _context194.a(2,_context194.v);}},_callee194,this);}));function setTotalLicenseTokenLimit(_x137){return _setTotalLicenseTokenLimit.apply(this,arguments);}return setTotalLicenseTokenLimit;}()/**
   * method setTotalLicenseTokenLimit for contract TotalLicenseTokenLimitHook with only encode
   *
   * @param request TotalLicenseTokenLimitHookSetTotalLicenseTokenLimitRequest
   * @return EncodedTxData
   */)},{key:"setTotalLicenseTokenLimitEncode",value:function setTotalLicenseTokenLimitEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:totalLicenseTokenLimitHookAbi,functionName:"setTotalLicenseTokenLimit",args:[request.licensorIpId,request.licenseTemplate,request.licenseTermsId,request.limit]})};}}]);}();// Contract WrappedIP =============================================================
/**
 * WrappedIpAllowanceRequest
 *
 * @param owner address
 * @param spender address
 *//**
 * WrappedIpAllowanceResponse
 *
 * @param result uint256
 *//**
 * WrappedIpBalanceOfRequest
 *
 * @param owner address
 *//**
 * WrappedIpBalanceOfResponse
 *
 * @param result uint256
 *//**
 * WrappedIpApproveRequest
 *
 * @param spender address
 * @param amount uint256
 *//**
 * WrappedIpTransferRequest
 *
 * @param to address
 * @param amount uint256
 *//**
 * WrappedIpTransferFromRequest
 *
 * @param from address
 * @param to address
 * @param amount uint256
 *//**
 * WrappedIpWithdrawRequest
 *
 * @param value uint256
 *//**
 * contract WrappedIP readonly method
 */var WrappedIpReadOnlyClient=/*#__PURE__*/function(){function WrappedIpReadOnlyClient(rpcClient,address){var _rpcClient$chain26;_classCallCheck(this,WrappedIpReadOnlyClient);this.address=address||getAddress(wrappedIpAddress,(_rpcClient$chain26=rpcClient.chain)===null||_rpcClient$chain26===void 0?void 0:_rpcClient$chain26.id);this.rpcClient=rpcClient;}/**
   * method allowance for contract WrappedIP
   *
   * @param request WrappedIpAllowanceRequest
   * @return Promise<WrappedIpAllowanceResponse>
   */return _createClass(WrappedIpReadOnlyClient,[{key:"allowance",value:(function(){var _allowance2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee195(request){var result;return _regenerator().w(function(_context195){while(1)switch(_context195.n){case 0:_context195.n=1;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"allowance",args:[request.owner,request.spender]});case 1:result=_context195.v;return _context195.a(2,{result:result});}},_callee195,this);}));function allowance(_x138){return _allowance2.apply(this,arguments);}return allowance;}()/**
   * method balanceOf for contract WrappedIP
   *
   * @param request WrappedIpBalanceOfRequest
   * @return Promise<WrappedIpBalanceOfResponse>
   */)},{key:"balanceOf",value:(function(){var _balanceOf3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee196(request){var result;return _regenerator().w(function(_context196){while(1)switch(_context196.n){case 0:_context196.n=1;return this.rpcClient.readContract({abi:wrappedIpAbi,address:this.address,functionName:"balanceOf",args:[request.owner]});case 1:result=_context196.v;return _context196.a(2,{result:result});}},_callee196,this);}));function balanceOf(_x139){return _balanceOf3.apply(this,arguments);}return balanceOf;}())}]);}();/**
 * contract WrappedIP write method
 */var WrappedIpClient=/*#__PURE__*/function(_WrappedIpReadOnlyCli){function WrappedIpClient(rpcClient,wallet,address){var _this16;_classCallCheck(this,WrappedIpClient);_this16=_callSuper(this,WrappedIpClient,[rpcClient,address]);_this16.wallet=wallet;return _this16;}/**
   * method approve for contract WrappedIP
   *
   * @param request WrappedIpApproveRequest
   * @return Promise<WriteContractReturnType>
   */_inherits(WrappedIpClient,_WrappedIpReadOnlyCli);return _createClass(WrappedIpClient,[{key:"approve",value:(function(){var _approve3=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee197(request){var _yield$this$rpcClient95,call;return _regenerator().w(function(_context197){while(1)switch(_context197.n){case 0:_context197.n=1;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"approve",account:this.wallet.account,args:[request.spender,request.amount]});case 1:_yield$this$rpcClient95=_context197.v;call=_yield$this$rpcClient95.request;_context197.n=2;return this.wallet.writeContract(call);case 2:return _context197.a(2,_context197.v);}},_callee197,this);}));function approve(_x140){return _approve3.apply(this,arguments);}return approve;}()/**
   * method approve for contract WrappedIP with only encode
   *
   * @param request WrappedIpApproveRequest
   * @return EncodedTxData
   */)},{key:"approveEncode",value:function approveEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:wrappedIpAbi,functionName:"approve",args:[request.spender,request.amount]})};}/**
   * method deposit for contract WrappedIP
   *
   * @param request WrappedIpDepositRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"deposit",value:(function(){var _deposit=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee198(){var _yield$this$rpcClient96,call;return _regenerator().w(function(_context198){while(1)switch(_context198.n){case 0:_context198.n=1;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"deposit",account:this.wallet.account});case 1:_yield$this$rpcClient96=_context198.v;call=_yield$this$rpcClient96.request;_context198.n=2;return this.wallet.writeContract(call);case 2:return _context198.a(2,_context198.v);}},_callee198,this);}));function deposit(){return _deposit.apply(this,arguments);}return deposit;}()/**
   * method deposit for contract WrappedIP with only encode
   *
   * @param request WrappedIpDepositRequest
   * @return EncodedTxData
   */)},{key:"depositEncode",value:function depositEncode(){return {to:this.address,data:viem.encodeFunctionData({abi:wrappedIpAbi,functionName:"deposit"})};}/**
   * method transfer for contract WrappedIP
   *
   * @param request WrappedIpTransferRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transfer",value:(function(){var _transfer2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee199(request){var _yield$this$rpcClient97,call;return _regenerator().w(function(_context199){while(1)switch(_context199.n){case 0:_context199.n=1;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"transfer",account:this.wallet.account,args:[request.to,request.amount]});case 1:_yield$this$rpcClient97=_context199.v;call=_yield$this$rpcClient97.request;_context199.n=2;return this.wallet.writeContract(call);case 2:return _context199.a(2,_context199.v);}},_callee199,this);}));function transfer(_x141){return _transfer2.apply(this,arguments);}return transfer;}()/**
   * method transfer for contract WrappedIP with only encode
   *
   * @param request WrappedIpTransferRequest
   * @return EncodedTxData
   */)},{key:"transferEncode",value:function transferEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:wrappedIpAbi,functionName:"transfer",args:[request.to,request.amount]})};}/**
   * method transferFrom for contract WrappedIP
   *
   * @param request WrappedIpTransferFromRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"transferFrom",value:(function(){var _transferFrom2=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee200(request){var _yield$this$rpcClient98,call;return _regenerator().w(function(_context200){while(1)switch(_context200.n){case 0:_context200.n=1;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"transferFrom",account:this.wallet.account,args:[request.from,request.to,request.amount]});case 1:_yield$this$rpcClient98=_context200.v;call=_yield$this$rpcClient98.request;_context200.n=2;return this.wallet.writeContract(call);case 2:return _context200.a(2,_context200.v);}},_callee200,this);}));function transferFrom(_x142){return _transferFrom2.apply(this,arguments);}return transferFrom;}()/**
   * method transferFrom for contract WrappedIP with only encode
   *
   * @param request WrappedIpTransferFromRequest
   * @return EncodedTxData
   */)},{key:"transferFromEncode",value:function transferFromEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:wrappedIpAbi,functionName:"transferFrom",args:[request.from,request.to,request.amount]})};}/**
   * method withdraw for contract WrappedIP
   *
   * @param request WrappedIpWithdrawRequest
   * @return Promise<WriteContractReturnType>
   */},{key:"withdraw",value:(function(){var _withdraw=_asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee201(request){var _yield$this$rpcClient99,call;return _regenerator().w(function(_context201){while(1)switch(_context201.n){case 0:_context201.n=1;return this.rpcClient.simulateContract({abi:wrappedIpAbi,address:this.address,functionName:"withdraw",account:this.wallet.account,args:[request.value]});case 1:_yield$this$rpcClient99=_context201.v;call=_yield$this$rpcClient99.request;_context201.n=2;return this.wallet.writeContract(call);case 2:return _context201.a(2,_context201.v);}},_callee201,this);}));function withdraw(_x143){return _withdraw.apply(this,arguments);}return withdraw;}()/**
   * method withdraw for contract WrappedIP with only encode
   *
   * @param request WrappedIpWithdrawRequest
   * @return EncodedTxData
   */)},{key:"withdrawEncode",value:function withdrawEncode(request){return {to:this.address,data:viem.encodeFunctionData({abi:wrappedIpAbi,functionName:"withdraw",args:[request.value]})};}}]);}(WrappedIpReadOnlyClient);

var aeneid = utils.defineChain({
  id: 1315,
  name: "aeneid",
  nativeCurrency: {
    name: "IP",
    symbol: "IP",
    decimals: 18
  },
  rpcUrls: {
    "default": {
      http: ["https://aeneid.storyrpc.io/"]
    }
  },
  blockExplorers: {
    "default": {
      name: "Explorer",
      url: "https://aeneid.storyscan.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1792
    }
  },
  testnet: true
});
var mainnet = utils.defineChain({
  id: 1514,
  name: "mainnet",
  nativeCurrency: {
    name: "IP",
    symbol: "IP",
    decimals: 18
  },
  rpcUrls: {
    "default": {
      http: ["https://mainnet.storyrpc.io/"]
    }
  },
  blockExplorers: {
    "default": {
      name: "Explorer",
      url: "https://dev-mainnet.storyscan.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 340998
    }
  },
  testnet: false
});

var defaultFunctionSelector = "0x00000000";
var MAX_ROYALTY_TOKEN = 100000000;
var WIP_TOKEN_ADDRESS = wrappedIpAddress[mainnet.id];

function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n) {
    return "function" == typeof t;
  }
}

function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p, r.prototype), p;
}

function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? new Map() : void 0;
  return _wrapNativeSuper = function (t) {
    if (null === t || !_isNativeFunction(t)) return t;
    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t)) return r.get(t);
      r.set(t, Wrapper);
    }
    function Wrapper() {
      return _construct(t, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t);
  }, _wrapNativeSuper(t);
}

var handleError = function handleError(error, msg) {
  if (error instanceof Error) {
    var newError = new Error("".concat(msg, ": ").concat(error.message));
    newError.stack = error.stack;
    throw newError;
  }
  throw new Error("".concat(msg, ": Unknown error type"));
};
var PILFlavorError = /*#__PURE__*/function (_Error) {
  function PILFlavorError(message) {
    var _this;
    _classCallCheck(this, PILFlavorError);
    _this = _callSuper(this, PILFlavorError, [message]);
    _this.name = "PILFlavorError";
    return _this;
  }
  _inherits(PILFlavorError, _Error);
  return _createClass(PILFlavorError);
}(/*#__PURE__*/_wrapNativeSuper(Error));

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}

var simulateAndWriteContract = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(_ref) {
    var rpcClient, wallet, data, _yield$rpcClient$simu, request, txHash, receipt;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          rpcClient = _ref.rpcClient, wallet = _ref.wallet, data = _ref.data;
          _context.n = 1;
          return rpcClient.simulateContract(_objectSpread2(_objectSpread2({}, data), {}, {
            account: wallet.account
          }));
        case 1:
          _yield$rpcClient$simu = _context.v;
          request = _yield$rpcClient$simu.request;
          _context.n = 2;
          return wallet.writeContract(request);
        case 2:
          txHash = _context.v;
          _context.n = 3;
          return rpcClient.waitForTransactionReceipt({
            hash: txHash
          });
        case 3:
          receipt = _context.v;
          return _context.a(2, {
            txHash: txHash,
            receipt: receipt
          });
      }
    }, _callee);
  }));
  return function simulateAndWriteContract(_x) {
    return _ref2.apply(this, arguments);
  };
}();

var ERC20Client = /*#__PURE__*/function () {
  function ERC20Client(rpcClient, wallet, address) {
    _classCallCheck(this, ERC20Client);
    this.ercClient = new Erc20Client(rpcClient, wallet, address);
  }
  return _createClass(ERC20Client, [{
    key: "balanceOf",
    value: function () {
      var _balanceOf = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(account) {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              _context.n = 1;
              return this.ercClient.balanceOf({
                account: account
              });
            case 1:
              return _context.a(2, _context.v);
          }
        }, _callee, this);
      }));
      function balanceOf(_x) {
        return _balanceOf.apply(this, arguments);
      }
      return balanceOf;
    }()
  }, {
    key: "allowance",
    value: function () {
      var _allowance = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(owner, spender) {
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              _context2.n = 1;
              return this.ercClient.allowance({
                owner: owner,
                spender: spender
              });
            case 1:
              return _context2.a(2, _context2.v);
          }
        }, _callee2, this);
      }));
      function allowance(_x2, _x3) {
        return _allowance.apply(this, arguments);
      }
      return allowance;
    }()
  }, {
    key: "approve",
    value: function () {
      var _approve = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(spender, value) {
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              _context3.n = 1;
              return this.ercClient.approve({
                spender: spender,
                value: value
              });
            case 1:
              return _context3.a(2, _context3.v);
          }
        }, _callee3, this);
      }));
      function approve(_x4, _x5) {
        return _approve.apply(this, arguments);
      }
      return approve;
    }()
  }, {
    key: "approveEncode",
    value: function approveEncode(spender, value) {
      return this.ercClient.approveEncode({
        spender: spender,
        value: value
      });
    }

    // The method only will work in test environment
  }, {
    key: "mint",
    value: function () {
      var _mint = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(to, amount) {
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              _context4.n = 1;
              return this.ercClient.mint({
                to: to,
                amount: amount
              });
            case 1:
              return _context4.a(2, _context4.v);
          }
        }, _callee4, this);
      }));
      function mint(_x6, _x7) {
        return _mint.apply(this, arguments);
      }
      return mint;
    }()
  }]);
}();
var WipTokenClient = /*#__PURE__*/function () {
  function WipTokenClient(rpcClient, wallet) {
    _classCallCheck(this, WipTokenClient);
    this.wipClient = new WrappedIpClient(rpcClient, wallet);
  }
  return _createClass(WipTokenClient, [{
    key: "balanceOf",
    value: function () {
      var _balanceOf2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(account) {
        var _yield$this$wipClient, balance;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              _context5.n = 1;
              return this.wipClient.balanceOf({
                owner: account
              });
            case 1:
              _yield$this$wipClient = _context5.v;
              balance = _yield$this$wipClient.result;
              return _context5.a(2, balance);
          }
        }, _callee5, this);
      }));
      function balanceOf(_x8) {
        return _balanceOf2.apply(this, arguments);
      }
      return balanceOf;
    }()
  }, {
    key: "allowance",
    value: function () {
      var _allowance2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(owner, spender) {
        var _yield$this$wipClient2, allowance;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              _context6.n = 1;
              return this.wipClient.allowance({
                owner: owner,
                spender: spender
              });
            case 1:
              _yield$this$wipClient2 = _context6.v;
              allowance = _yield$this$wipClient2.result;
              return _context6.a(2, allowance);
          }
        }, _callee6, this);
      }));
      function allowance(_x9, _x0) {
        return _allowance2.apply(this, arguments);
      }
      return allowance;
    }()
  }, {
    key: "approve",
    value: function () {
      var _approve2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(spender, value) {
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              _context7.n = 1;
              return this.wipClient.approve({
                spender: spender,
                amount: value
              });
            case 1:
              return _context7.a(2, _context7.v);
          }
        }, _callee7, this);
      }));
      function approve(_x1, _x10) {
        return _approve2.apply(this, arguments);
      }
      return approve;
    }()
  }, {
    key: "approveEncode",
    value: function approveEncode(spender, value) {
      return this.wipClient.approveEncode({
        spender: spender,
        amount: value
      });
    }
  }, {
    key: "depositEncode",
    value: function depositEncode() {
      return this.wipClient.depositEncode();
    }
  }, {
    key: "address",
    get: function get() {
      return this.wipClient.address;
    }
  }]);
}();

var waitForTxReceipt = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(_ref) {
    var txOptions, rpcClient, txHash, receipt;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          txOptions = _ref.txOptions, rpcClient = _ref.rpcClient, txHash = _ref.txHash;
          _context.n = 1;
          return rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
            hash: txHash
          }));
        case 1:
          receipt = _context.v;
          return _context.a(2, {
            txHash: txHash,
            receipt: receipt
          });
      }
    }, _callee);
  }));
  return function waitForTxReceipt(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var waitForTxReceipts = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(_ref3) {
    var txOptions, rpcClient, txHashes, receipts;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          txOptions = _ref3.txOptions, rpcClient = _ref3.rpcClient, txHashes = _ref3.txHashes;
          _context2.n = 1;
          return Promise.all(txHashes.map(function (hash) {
            return rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
              hash: hash
            }));
          }));
        case 1:
          receipts = _context2.v;
          return _context2.a(2, receipts.map(function (receipt) {
            return {
              txHash: receipt.transactionHash,
              receipt: receipt
            };
          }));
      }
    }, _callee2);
  }));
  return function waitForTxReceipts(_x2) {
    return _ref4.apply(this, arguments);
  };
}();

var waitTx = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(client, txHash, params) {
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          _context2.n = 1;
          return client.waitForTransactionReceipt(_objectSpread2({
            hash: txHash
          }, params));
        case 1:
          return _context2.a(2);
      }
    }, _callee2);
  }));
  return function waitTx(_x4, _x5, _x6) {
    return _ref2.apply(this, arguments);
  };
}();
var chainStringToViemChain = function chainStringToViemChain(chainId) {
  switch (chainId) {
    case 1315:
    case "aeneid":
      return aeneid;
    case 1514:
    case "mainnet":
      return mainnet;
    default:
      throw new Error("ChainId ".concat(String(chainId), " not supported"));
  }
};
var chain = {
  aeneid: 1315,
  1315: 1315,
  mainnet: 1514,
  1514: 1514
};
var validateAddress = function validateAddress(address) {
  if (!viem.isAddress(address, {
    strict: false
  })) {
    throw Error("Invalid address: ".concat(address, "."));
  }
  return address;
};
var validateAddresses = function validateAddresses(addresses) {
  return addresses.map(function (address) {
    return validateAddress(address);
  });
};
var getTokenAmountDisplay = function getTokenAmountDisplay(amount) {
  var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "IP";
  return "".concat(viem.formatEther(amount)).concat(unit);
};

/**
 * Merges spenders with the same address by summing their amounts.
 */
var mergeSpenderByAddress = function mergeSpenderByAddress(spenders, newSpender) {
  var existingSpender = spenders.find(function (s) {
    return s.address === newSpender.address && s.token === newSpender.token;
  });
  if (existingSpender) {
    existingSpender.amount = (newSpender.amount || 0n) + (existingSpender.amount || 0n);
  } else {
    spenders.push(_objectSpread2(_objectSpread2({}, newSpender), {}, {
      amount: newSpender.amount || 0n
    }));
  }
};

/**
 * check the allowance of all spenders and call approval if any spender
 * allowance is lower than the amount they are expected to spend.
 * Supports using multicall to return all approve calls in a multicall array.
 */
var approvalAllSpenders = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(_ref) {
    var spenders, client, owner, useMultiCall, rpcClient, multicallAddress, approvals, allCalls, _iterator, _step, approval, hash, _t;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.p = _context2.n) {
        case 0:
          spenders = _ref.spenders, client = _ref.client, owner = _ref.owner, useMultiCall = _ref.useMultiCall, rpcClient = _ref.rpcClient, multicallAddress = _ref.multicallAddress;
          _context2.n = 1;
          return Promise.all(spenders.map(/*#__PURE__*/function () {
            var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(spender) {
              var spenderAmount, allowance;
              return _regenerator().w(function (_context) {
                while (1) switch (_context.n) {
                  case 0:
                    if (!(spender.address === multicallAddress)) {
                      _context.n = 1;
                      break;
                    }
                    return _context.a(2);
                  case 1:
                    spenderAmount = spender.amount || viem.maxUint256;
                    _context.n = 2;
                    return client.allowance(owner, spender.address);
                  case 2:
                    allowance = _context.v;
                    if (!(allowance < spenderAmount)) {
                      _context.n = 3;
                      break;
                    }
                    return _context.a(2, {
                      spender: spender.address,
                      value: viem.maxUint256 // approve max amount to avoid approvals in the future
                    });
                  case 3:
                    return _context.a(2);
                }
              }, _callee);
            }));
            return function (_x2) {
              return _ref3.apply(this, arguments);
            };
          }()));
        case 1:
          approvals = _context2.v;
          if (!useMultiCall) {
            _context2.n = 2;
            break;
          }
          allCalls = [];
          approvals.forEach(function (approval) {
            if (!approval) {
              return;
            }
            var encodedData = client.approveEncode(approval.spender, approval.value);
            allCalls.push({
              target: encodedData.to,
              allowFailure: false,
              value: 0n,
              callData: encodedData.data
            });
          });
          return _context2.a(2, allCalls);
        case 2:
          // make approval calls sequentially
          _iterator = _createForOfIteratorHelper(approvals);
          _context2.p = 3;
          _iterator.s();
        case 4:
          if ((_step = _iterator.n()).done) {
            _context2.n = 8;
            break;
          }
          approval = _step.value;
          if (approval) {
            _context2.n = 5;
            break;
          }
          return _context2.a(3, 7);
        case 5:
          _context2.n = 6;
          return client.approve(approval.spender, approval.value);
        case 6:
          hash = _context2.v;
          _context2.n = 7;
          return rpcClient.waitForTransactionReceipt({
            hash: hash
          });
        case 7:
          _context2.n = 4;
          break;
        case 8:
          _context2.n = 10;
          break;
        case 9:
          _context2.p = 9;
          _t = _context2.v;
          _iterator.e(_t);
        case 10:
          _context2.p = 10;
          _iterator.f();
          return _context2.f(10);
        case 11:
          return _context2.a(2, []);
      }
    }, _callee2, null, [[3, 9, 10, 11]]);
  }));
  return function approvalAllSpenders(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var multiCallWrapIp = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(_ref4) {
    var ipAmountToWrap, wipClient, multicall3Address, wipSpenders, calls, rpcClient, wallet, contractCall, wipOptions, multiCalls, useMultiCall, deposit, autoApprove, approvalCalls, txHash;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          ipAmountToWrap = _ref4.ipAmountToWrap, wipClient = _ref4.wipClient, multicall3Address = _ref4.multicall3Address, wipSpenders = _ref4.wipSpenders, calls = _ref4.calls, rpcClient = _ref4.rpcClient, wallet = _ref4.wallet, contractCall = _ref4.contractCall, wipOptions = _ref4.wipOptions;
          if (!(ipAmountToWrap === 0n)) {
            _context3.n = 1;
            break;
          }
          throw new Error("ipAmountToWrap should be greater than 0");
        case 1:
          multiCalls = [];
          useMultiCall = (wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.useMulticallWhenPossible) !== false;
          if (!useMultiCall) {
            _context3.n = 2;
            break;
          }
          deposit = wipClient.depositEncode();
          multiCalls.push({
            target: deposit.to,
            allowFailure: false,
            value: ipAmountToWrap,
            callData: deposit.data
          });
          _context3.n = 3;
          break;
        case 2:
          _context3.n = 3;
          return simulateAndWriteContract({
            rpcClient: rpcClient,
            wallet: wallet,
            data: {
              abi: wrappedIpAbi,
              address: wipClient.address,
              functionName: "deposit",
              value: ipAmountToWrap
            }
          });
        case 3:
          autoApprove = (wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.enableAutoApprove) !== false;
          if (!autoApprove) {
            _context3.n = 5;
            break;
          }
          _context3.n = 4;
          return approvalAllSpenders({
            spenders: wipSpenders,
            client: wipClient,
            multicallAddress: multicall3Address,
            owner: useMultiCall ? multicall3Address : wallet.account.address,
            rpcClient: rpcClient,
            useMultiCall: useMultiCall
          });
        case 4:
          approvalCalls = _context3.v;
          if (approvalCalls.length > 0 && useMultiCall) {
            multiCalls.push.apply(multiCalls, _toConsumableArray(approvalCalls));
          }
        case 5:
          multiCalls.push.apply(multiCalls, _toConsumableArray(calls));
          if (useMultiCall) {
            _context3.n = 7;
            break;
          }
          _context3.n = 6;
          return contractCall();
        case 6:
          txHash = _context3.v;
          return _context3.a(2, {
            txHash: txHash
          });
        case 7:
          return _context3.a(2, simulateAndWriteContract({
            rpcClient: rpcClient,
            wallet: wallet,
            data: {
              abi: multicall3Abi,
              address: multicall3Address,
              functionName: "aggregate3Value",
              args: [multiCalls],
              value: ipAmountToWrap
            }
          }));
      }
    }, _callee3);
  }));
  return function multiCallWrapIp(_x3) {
    return _ref5.apply(this, arguments);
  };
}();

/**
 * Calculate the total amount needed from spenders.
 */
var calculateTotalAmount = function calculateTotalAmount(spenders) {
  return spenders.reduce(function (acc, spender) {
    return acc + (spender.amount || 0n);
  }, 0n);
};

/**
 * Handle ERC20 token payment with approval and balance check.
 */
var handleErc20Payment = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref6) {
    var _options$erc20Options;
    var tokenSpenders, sender, options, multicall3Address, rpcClient, wallet, contractCall, txOptions, tokenClient, autoApprove, _t2;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          tokenSpenders = _ref6.tokenSpenders, sender = _ref6.sender, options = _ref6.options, multicall3Address = _ref6.multicall3Address, rpcClient = _ref6.rpcClient, wallet = _ref6.wallet, contractCall = _ref6.contractCall, txOptions = _ref6.txOptions;
          tokenClient = new ERC20Client(rpcClient, wallet, tokenSpenders[0].token);
          autoApprove = (options === null || options === void 0 || (_options$erc20Options = options.erc20Options) === null || _options$erc20Options === void 0 ? void 0 : _options$erc20Options.enableAutoApprove) !== false;
          if (!autoApprove) {
            _context4.n = 1;
            break;
          }
          _context4.n = 1;
          return approvalAllSpenders({
            spenders: tokenSpenders,
            client: tokenClient,
            owner: sender,
            multicallAddress: multicall3Address,
            rpcClient: rpcClient,
            useMultiCall: false
          });
        case 1:
          _t2 = handleTransactionResponse;
          _context4.n = 2;
          return contractCall();
        case 2:
          return _context4.a(2, _t2(_context4.v, rpcClient, txOptions));
      }
    }, _callee4);
  }));
  return function handleErc20Payment(_x4) {
    return _ref7.apply(this, arguments);
  };
}();

/**
 * Handle WIP token payment with approval and balance check.
 */
var handleWipPayment = /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(_ref8) {
    var _options$wipOptions;
    var tokenSpenders, sender, options, multicall3Address, rpcClient, contractCall, txOptions, wallet, encodedTxs, wipTokenClient, balance, totalFees, autoApprove, _t3;
    return _regenerator().w(function (_context5) {
      while (1) switch (_context5.n) {
        case 0:
          tokenSpenders = _ref8.tokenSpenders, sender = _ref8.sender, options = _ref8.options, multicall3Address = _ref8.multicall3Address, rpcClient = _ref8.rpcClient, contractCall = _ref8.contractCall, txOptions = _ref8.txOptions, wallet = _ref8.wallet, encodedTxs = _ref8.encodedTxs;
          wipTokenClient = new WipTokenClient(rpcClient, wallet);
          _context5.n = 1;
          return wipTokenClient.balanceOf(sender);
        case 1:
          balance = _context5.v;
          totalFees = calculateTotalAmount(tokenSpenders);
          if (!(balance < totalFees)) {
            _context5.n = 2;
            break;
          }
          return _context5.a(2, handleIpWrapping({
            tokenSpenders: tokenSpenders,
            sender: sender,
            options: options,
            rpcClient: rpcClient,
            multicall3Address: multicall3Address,
            contractCall: contractCall,
            encodedTxs: encodedTxs,
            wallet: wallet,
            txOptions: txOptions
          }));
        case 2:
          autoApprove = (options === null || options === void 0 || (_options$wipOptions = options.wipOptions) === null || _options$wipOptions === void 0 ? void 0 : _options$wipOptions.enableAutoApprove) !== false;
          if (!autoApprove) {
            _context5.n = 3;
            break;
          }
          _context5.n = 3;
          return approvalAllSpenders({
            spenders: tokenSpenders,
            client: wipTokenClient,
            owner: sender,
            multicallAddress: multicall3Address,
            rpcClient: rpcClient,
            useMultiCall: false
          });
        case 3:
          _t3 = handleTransactionResponse;
          _context5.n = 4;
          return contractCall();
        case 4:
          return _context5.a(2, _t3(_context5.v, rpcClient, txOptions));
      }
    }, _callee5);
  }));
  return function handleWipPayment(_x5) {
    return _ref9.apply(this, arguments);
  };
}();

/**
 * Handle IP wrapping to WIP when insufficient WIP balance.
 */
var handleIpWrapping = /*#__PURE__*/function () {
  var _ref1 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref0) {
    var _options$wipOptions2;
    var tokenSpenders, sender, options, rpcClient, multicall3Address, contractCall, encodedTxs, wallet, txOptions, autoWrapIp, ipBalance, wipClient, wipBalance, totalFees, _yield$multiCallWrapI, txHash;
    return _regenerator().w(function (_context6) {
      while (1) switch (_context6.n) {
        case 0:
          tokenSpenders = _ref0.tokenSpenders, sender = _ref0.sender, options = _ref0.options, rpcClient = _ref0.rpcClient, multicall3Address = _ref0.multicall3Address, contractCall = _ref0.contractCall, encodedTxs = _ref0.encodedTxs, wallet = _ref0.wallet, txOptions = _ref0.txOptions;
          autoWrapIp = (options === null || options === void 0 || (_options$wipOptions2 = options.wipOptions) === null || _options$wipOptions2 === void 0 ? void 0 : _options$wipOptions2.enableAutoWrapIp) !== false;
          _context6.n = 1;
          return rpcClient.getBalance({
            address: sender
          });
        case 1:
          ipBalance = _context6.v;
          wipClient = new WipTokenClient(rpcClient, wallet);
          _context6.n = 2;
          return wipClient.balanceOf(sender);
        case 2:
          wipBalance = _context6.v;
          totalFees = calculateTotalAmount(tokenSpenders);
          if (!(ipBalance < totalFees)) {
            _context6.n = 3;
            break;
          }
          throw new Error("Wallet does not have enough IP to wrap to WIP and pay for fees. Total fees: ".concat(getTokenAmountDisplay(totalFees), ", balance: ").concat(getTokenAmountDisplay(ipBalance), "."));
        case 3:
          if (autoWrapIp) {
            _context6.n = 4;
            break;
          }
          throw new Error("Wallet does not have enough WIP to pay for fees. Total fees: ".concat(getTokenAmountDisplay(totalFees), ", balance: ").concat(getTokenAmountDisplay(wipBalance, "WIP"), "."));
        case 4:
          _context6.n = 5;
          return multiCallWrapIp({
            ipAmountToWrap: totalFees,
            multicall3Address: multicall3Address,
            wipClient: wipClient,
            wipOptions: options === null || options === void 0 ? void 0 : options.wipOptions,
            contractCall: contractCall,
            wipSpenders: tokenSpenders,
            rpcClient: rpcClient,
            wallet: wallet,
            calls: encodedTxs.map(function (data) {
              return {
                target: data.to,
                allowFailure: false,
                value: 0n,
                callData: data.data
              };
            })
          });
        case 5:
          _yield$multiCallWrapI = _context6.v;
          txHash = _yield$multiCallWrapI.txHash;
          return _context6.a(2, handleTransactionResponse(txHash, rpcClient, txOptions));
      }
    }, _callee6);
  }));
  return function handleIpWrapping(_x6) {
    return _ref1.apply(this, arguments);
  };
}();

/**
 * Handle contract calls that require token fees.
 * - For fees in `WIP`, it automatically wraps `IP` to `WIP` when insufficient `WIP` balance.
 * - For fees in `ERC20` tokens, it automatically approves if sufficient balance is available.
 * - For fees in `WIP` and `ERC20` tokens, it will first check if the wallet has enough `ERC20` token to pay for fees, if not, it will throw an error.
 *
 * @remarks
 * This function will automatically handle the following logic:
 * - If token is `WIP` and the user does not have enough `WIP` balance, it will wrap `IP` to `WIP`, unless
 * disabled via `disableAutoWrappingIp`.
 * - If the user have enough token, it will check for if approvals are needed
 * for each spender address and approve it, unless disabled via `disableAutoApprove`.
 * - If the fees are in `WIP` and `ERC20` tokens, it will not use disable `useMulticallWhenPossible` to pay for fees.
 */
var contractCallWithFees = /*#__PURE__*/function () {
  var _ref11 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(_ref10) {
    var options, multicall3Address, wallet, tokenSpenders, contractCall, sender, txOptions, encodedTxs, rpcClient, zeroFees, _groupTokenSpenders, wipSpenders, erc20Spenders, baseContractCallArgs, _options$erc20Options2, _erc20Spenders$, autoApproveForErc20, erc20Client, _t4;
    return _regenerator().w(function (_context7) {
      while (1) switch (_context7.n) {
        case 0:
          options = _ref10.options, multicall3Address = _ref10.multicall3Address, wallet = _ref10.wallet, tokenSpenders = _ref10.tokenSpenders, contractCall = _ref10.contractCall, sender = _ref10.sender, txOptions = _ref10.txOptions, encodedTxs = _ref10.encodedTxs, rpcClient = _ref10.rpcClient;
          // Skip fee logic if no fees
          zeroFees = tokenSpenders.every(function (spender) {
            return spender.amount === 0n;
          });
          if (!zeroFees) {
            _context7.n = 2;
            break;
          }
          _t4 = handleTransactionResponse;
          _context7.n = 1;
          return contractCall();
        case 1:
          return _context7.a(2, _t4(_context7.v, rpcClient, txOptions));
        case 2:
          _groupTokenSpenders = groupTokenSpenders(tokenSpenders), wipSpenders = _groupTokenSpenders.wipSpenders, erc20Spenders = _groupTokenSpenders.erc20Spenders;
          baseContractCallArgs = {
            sender: sender,
            options: options,
            multicall3Address: multicall3Address,
            rpcClient: rpcClient,
            contractCall: contractCall,
            encodedTxs: encodedTxs,
            txOptions: txOptions,
            wallet: wallet
          };
          if (!(erc20Spenders.length > 0)) {
            _context7.n = 3;
            break;
          }
          _context7.n = 3;
          return checkErc20BalanceBelowFees(erc20Spenders, rpcClient, wallet, sender);
        case 3:
          if (!(wipSpenders.length > 0 && erc20Spenders.length > 0)) {
            _context7.n = 5;
            break;
          }
          autoApproveForErc20 = (options === null || options === void 0 || (_options$erc20Options2 = options.erc20Options) === null || _options$erc20Options2 === void 0 ? void 0 : _options$erc20Options2.enableAutoApprove) !== false;
          erc20Client = new ERC20Client(rpcClient, wallet, (_erc20Spenders$ = erc20Spenders[0]) === null || _erc20Spenders$ === void 0 ? void 0 : _erc20Spenders$.token);
          if (!autoApproveForErc20) {
            _context7.n = 4;
            break;
          }
          _context7.n = 4;
          return approvalAllSpenders({
            spenders: erc20Spenders,
            client: erc20Client,
            owner: sender,
            multicallAddress: multicall3Address,
            rpcClient: rpcClient,
            useMultiCall: false
          });
        case 4:
          return _context7.a(2, handleWipPayment(_objectSpread2(_objectSpread2({}, baseContractCallArgs), {}, {
            tokenSpenders: wipSpenders,
            options: {
              wipOptions: _objectSpread2(_objectSpread2({}, options === null || options === void 0 ? void 0 : options.wipOptions), {}, {
                // Need to pay erc20 fees with the wallet, cannot use multicall when handling erc20 payment.
                useMulticallWhenPossible: false
              })
            }
          })));
        case 5:
          if (!(erc20Spenders.length > 0)) {
            _context7.n = 6;
            break;
          }
          return _context7.a(2, handleErc20Payment(_objectSpread2(_objectSpread2({}, baseContractCallArgs), {}, {
            tokenSpenders: erc20Spenders
          })));
        case 6:
          return _context7.a(2, handleWipPayment(_objectSpread2(_objectSpread2({}, baseContractCallArgs), {}, {
            tokenSpenders: wipSpenders
          })));
        case 7:
          return _context7.a(2);
      }
    }, _callee7);
  }));
  return function contractCallWithFees(_x7) {
    return _ref11.apply(this, arguments);
  };
}();
var handleTransactionResponse = /*#__PURE__*/function () {
  var _ref12 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(txHash, rpcClient, txOptions) {
    return _regenerator().w(function (_context8) {
      while (1) switch (_context8.n) {
        case 0:
          if (!Array.isArray(txHash)) {
            _context8.n = 1;
            break;
          }
          return _context8.a(2, waitForTxReceipts({
            rpcClient: rpcClient,
            txOptions: txOptions,
            txHashes: txHash
          }));
        case 1:
          return _context8.a(2, waitForTxReceipt({
            rpcClient: rpcClient,
            txOptions: txOptions,
            txHash: txHash
          }));
      }
    }, _callee8);
  }));
  return function handleTransactionResponse(_x8, _x9, _x0) {
    return _ref12.apply(this, arguments);
  };
}();

/**
 * Group token spenders into wip and erc20 spenders.
 */
var groupTokenSpenders = function groupTokenSpenders(tokenSpenders) {
  var wipSpenders = [];
  var erc20Spenders = [];
  var _iterator2 = _createForOfIteratorHelper(tokenSpenders),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var spender = _step2.value;
      if (spender.token.toLowerCase() === WIP_TOKEN_ADDRESS.toLowerCase()) {
        mergeSpenderByAddress(wipSpenders, spender);
      } else {
        mergeSpenderByAddress(erc20Spenders, spender);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return {
    wipSpenders: wipSpenders,
    erc20Spenders: erc20Spenders
  };
};
var checkErc20BalanceBelowFees = /*#__PURE__*/function () {
  var _ref13 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(erc20Spenders, rpcClient, wallet, sender) {
    var _erc20Spenders$2;
    var erc20Client, erc20Balance, erc20TotalFees;
    return _regenerator().w(function (_context9) {
      while (1) switch (_context9.n) {
        case 0:
          erc20Client = new ERC20Client(rpcClient, wallet, (_erc20Spenders$2 = erc20Spenders[0]) === null || _erc20Spenders$2 === void 0 ? void 0 : _erc20Spenders$2.token);
          _context9.n = 1;
          return erc20Client.balanceOf(sender);
        case 1:
          erc20Balance = _context9.v;
          erc20TotalFees = calculateTotalAmount(erc20Spenders); //If the wallet does not have enough erc20 token to pay for fees, throw an error.
          if (!(erc20Balance < erc20TotalFees)) {
            _context9.n = 2;
            break;
          }
          throw new Error("Wallet does not have enough erc20 token to pay for fees. Total fees:  ".concat(getTokenAmountDisplay(erc20TotalFees), ", balance: ").concat(getTokenAmountDisplay(erc20Balance), "."));
        case 2:
          return _context9.a(2);
      }
    }, _callee9);
  }));
  return function checkErc20BalanceBelowFees(_x1, _x10, _x11, _x12) {
    return _ref13.apply(this, arguments);
  };
}();

var v0Prefix = "1220";
var convertCIDtoHashIPFS = function convertCIDtoHashIPFS(cid$1) {
  var isV0 = cid$1.startsWith("Qm");
  var parsedCID = cid.CID.parse(cid$1);
  var base58CID = isV0 ? parsedCID.toString() : parsedCID.toV0().toString();
  var bytes = bs58__default.default.decode(base58CID);
  var base16CID = Array.from(bytes).map(function (_byte) {
    return _byte.toString(16).padStart(2, "0");
  }).join("");
  return "0x" + base16CID.slice(v0Prefix.length);
};
var convertHashIPFStoCID = function convertHashIPFStoCID(hash) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "v0";
  var base16CID = v0Prefix + hash.slice(2);
  var bytes = new Uint8Array(base16CID.match(/.{1,2}/g).map(function (_byte2) {
    return parseInt(_byte2, 16);
  }));
  var base58CID = bs58__default.default.encode(Buffer.from(bytes));
  if (version === "v0") {
    return base58CID;
  } else {
    return cid.CID.parse(base58CID, base58.base58btc).toV1().toString();
  }
};

/**
 * The ABI for the OptimisticOracleV3 contract. Contract address may be changed.
 * @see https://aeneid.storyscan.io/address/0xABac6a158431edED06EE6cba37eDE8779F599eE4?tab=contract_abi
 */
var ASSERTION_ABI = [{
  inputs: [{
    internalType: "bytes32",
    name: "assertionId",
    type: "bytes32"
  }],
  name: "getAssertion",
  outputs: [{
    components: [{
      components: [{
        internalType: "bool",
        name: "arbitrateViaEscalationManager",
        type: "bool"
      }, {
        internalType: "bool",
        name: "discardOracle",
        type: "bool"
      }, {
        internalType: "bool",
        name: "validateDisputers",
        type: "bool"
      }, {
        internalType: "address",
        name: "assertingCaller",
        type: "address"
      }, {
        internalType: "address",
        name: "escalationManager",
        type: "address"
      }],
      internalType: "struct OptimisticOracleV3Interface.EscalationManagerSettings",
      name: "escalationManagerSettings",
      type: "tuple"
    }, {
      internalType: "address",
      name: "asserter",
      type: "address"
    }, {
      internalType: "uint64",
      name: "assertionTime",
      type: "uint64"
    }, {
      internalType: "bool",
      name: "settled",
      type: "bool"
    }, {
      internalType: "contract IERC20",
      name: "currency",
      type: "address"
    }, {
      internalType: "uint64",
      name: "expirationTime",
      type: "uint64"
    }, {
      internalType: "bool",
      name: "settlementResolution",
      type: "bool"
    }, {
      internalType: "bytes32",
      name: "domainId",
      type: "bytes32"
    }, {
      internalType: "bytes32",
      name: "identifier",
      type: "bytes32"
    }, {
      internalType: "uint256",
      name: "bond",
      type: "uint256"
    }, {
      internalType: "address",
      name: "callbackRecipient",
      type: "address"
    }, {
      internalType: "address",
      name: "disputer",
      type: "address"
    }],
    internalType: "struct OptimisticOracleV3Interface.Assertion",
    name: "",
    type: "tuple"
  }],
  stateMutability: "view",
  type: "function"
}, {
  inputs: [{
    internalType: "bytes32",
    name: "assertionId",
    type: "bytes32"
  }],
  name: "settleAssertion",
  outputs: [],
  stateMutability: "nonpayable",
  type: "function"
}, {
  inputs: [{
    internalType: "address",
    name: "currency",
    type: "address"
  }],
  name: "getMinimumBond",
  outputs: [{
    internalType: "uint256",
    name: "",
    type: "uint256"
  }],
  stateMutability: "view",
  type: "function"
}];

var getOov3Contract = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(arbitrationPolicyUmaClient) {
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          _context.n = 1;
          return arbitrationPolicyUmaClient.oov3();
        case 1:
          return _context.a(2, _context.v);
      }
    }, _callee);
  }));
  return function getOov3Contract(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getAssertionDetails = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(rpcClient, arbitrationPolicyUmaClient, assertionId) {
    var oov3Contract, _yield$rpcClient$read, bond;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          _context2.n = 1;
          return getOov3Contract(arbitrationPolicyUmaClient);
        case 1:
          oov3Contract = _context2.v;
          _context2.n = 2;
          return rpcClient.readContract({
            address: oov3Contract,
            abi: ASSERTION_ABI,
            functionName: "getAssertion",
            args: [assertionId]
          });
        case 2:
          _yield$rpcClient$read = _context2.v;
          bond = _yield$rpcClient$read.bond;
          return _context2.a(2, bond);
      }
    }, _callee2);
  }));
  return function getAssertionDetails(_x2, _x3, _x4) {
    return _ref2.apply(this, arguments);
  };
}();
var getMinimumBond = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(rpcClient, arbitrationPolicyUmaClient, currency) {
    var oov3Contract;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          _context3.n = 1;
          return getOov3Contract(arbitrationPolicyUmaClient);
        case 1:
          oov3Contract = _context3.v;
          _context3.n = 2;
          return rpcClient.readContract({
            address: oov3Contract,
            abi: ASSERTION_ABI,
            functionName: "getMinimumBond",
            args: [currency]
          });
        case 2:
          return _context3.a(2, _context3.v);
      }
    }, _callee3);
  }));
  return function getMinimumBond(_x5, _x6, _x7) {
    return _ref3.apply(this, arguments);
  };
}();

/**
 * Settles an assertion associated with a dispute in the UMA arbitration protocol.
 *
 * This function takes a dispute ID, resolves it to an assertion ID, and then calls
 * the `settleAssertion` function on the Optimistic Oracle V3 contract to finalize
 * the arbitration outcome.
 *
 * The function is specifically designed for testing on the `aeneid` testnet and will
 * not work on other chains. It handles the entire settlement process including:
 * - Creating the appropriate clients with the provided private key
 * - Retrieving the assertion ID from the dispute ID
 * - Executing the settlement transaction
 * - Waiting for transaction confirmation
 *
 * @see https://docs.story.foundation/docs/uma-arbitration-policy#/
 * @see https://docs.uma.xyz/developers/optimistic-oracle-v3
 *
 * @param privateKey - The private key of the wallet that will sign the settlement transaction.
 * @param disputeId - The ID of the dispute to be settled.
 * @param transport - Optional custom RPC URL; defaults to the aeneid testnet RPC URL.
 * @returns A promise that resolves to the transaction hash of the settlement transaction.
 */
var settleAssertion = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(privateKey, disputeId, transport) {
    var baseConfig, rpcClient, walletClient, arbitrationPolicyUmaClient, oov3Contract, assertionId, txHash, _t;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.p = _context4.n) {
        case 0:
          _context4.p = 0;
          baseConfig = {
            chain: chainStringToViemChain("aeneid"),
            transport: viem.http(transport !== null && transport !== void 0 ? transport : aeneid.rpcUrls["default"].http[0])
          };
          rpcClient = viem.createPublicClient(baseConfig);
          walletClient = viem.createWalletClient(_objectSpread2(_objectSpread2({}, baseConfig), {}, {
            account: accounts.privateKeyToAccount(privateKey)
          }));
          arbitrationPolicyUmaClient = new ArbitrationPolicyUmaClient(rpcClient, walletClient);
          _context4.n = 1;
          return getOov3Contract(arbitrationPolicyUmaClient);
        case 1:
          oov3Contract = _context4.v;
          _context4.n = 2;
          return arbitrationPolicyUmaClient.disputeIdToAssertionId({
            disputeId: BigInt(disputeId)
          });
        case 2:
          assertionId = _context4.v;
          _context4.n = 3;
          return walletClient.writeContract({
            address: oov3Contract,
            abi: ASSERTION_ABI,
            functionName: "settleAssertion",
            args: [assertionId]
          });
        case 3:
          txHash = _context4.v;
          _context4.n = 4;
          return rpcClient.waitForTransactionReceipt({
            hash: txHash
          });
        case 4:
          return _context4.a(2, txHash);
        case 5:
          _context4.p = 5;
          _t = _context4.v;
          return _context4.a(2, handleError(_t, "Failed to settle assertion"));
      }
    }, _callee4, null, [[0, 5]]);
  }));
  return function settleAssertion(_x8, _x9, _x0) {
    return _ref4.apply(this, arguments);
  };
}();

var DisputeClient = /*#__PURE__*/function () {
  function DisputeClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, DisputeClient);
    this.rpcClient = rpcClient;
    this.disputeModuleClient = new DisputeModuleClient(rpcClient, wallet);
    this.arbitrationPolicyUmaClient = new ArbitrationPolicyUmaClient(rpcClient, wallet);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.wrappedIpClient = new WrappedIpClient(rpcClient, wallet);
    this.chainId = chainId;
    this.wallet = wallet;
  }

  /**
   * Raises a dispute on a given ipId.
   *
   * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/dispute/IDisputeModule.sol#L64 | `DisputeRaised`} event.
   */
  return _createClass(DisputeClient, [{
    key: "raiseDispute",
    value: (function () {
      var _raiseDispute = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(request) {
        var _this = this;
        var _request$txOptions, liveness, _yield$Promise$all, _yield$Promise$all2, minLiveness, maxLiveness, _yield$Promise$all3, _yield$Promise$all4, minimumBond, maximumBond, bonds, tag, data, _yield$this$disputeMo, isWhiteList, req, encodedTxData, contractCall, _yield$contractCallWi, txHash, receipt, targetLogs, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              liveness = BigInt(request.liveness);
              _context.n = 1;
              return Promise.all([this.arbitrationPolicyUmaClient.minLiveness(), this.arbitrationPolicyUmaClient.maxLiveness()]);
            case 1:
              _yield$Promise$all = _context.v;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              minLiveness = _yield$Promise$all2[0];
              maxLiveness = _yield$Promise$all2[1];
              if (!(liveness < minLiveness || liveness > maxLiveness)) {
                _context.n = 2;
                break;
              }
              throw new Error("Liveness must be between ".concat(minLiveness, " and ").concat(maxLiveness, "."));
            case 2:
              _context.n = 3;
              return Promise.all([getMinimumBond(this.rpcClient, this.arbitrationPolicyUmaClient, WIP_TOKEN_ADDRESS), this.arbitrationPolicyUmaClient.maxBonds({
                token: WIP_TOKEN_ADDRESS
              })]);
            case 3:
              _yield$Promise$all3 = _context.v;
              _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
              minimumBond = _yield$Promise$all4[0];
              maximumBond = _yield$Promise$all4[1];
              bonds = BigInt(request.bond === undefined ? minimumBond : request.bond);
              if (!(bonds > maximumBond || bonds < minimumBond)) {
                _context.n = 4;
                break;
              }
              throw new Error("Bonds must be between ".concat(minimumBond, " and ").concat(maximumBond, "."));
            case 4:
              tag = viem.stringToHex(request.targetTag, {
                size: 32
              });
              data = viem.encodeAbiParameters([{
                name: "",
                type: "uint64"
              }, {
                name: "",
                type: "address"
              }, {
                name: "",
                type: "uint256"
              }], [liveness, WIP_TOKEN_ADDRESS, bonds]);
              _context.n = 5;
              return this.disputeModuleClient.isWhitelistedDisputeTag({
                tag: tag
              });
            case 5:
              _yield$this$disputeMo = _context.v;
              isWhiteList = _yield$this$disputeMo.allowed;
              if (isWhiteList) {
                _context.n = 6;
                break;
              }
              throw new Error("The target tag ".concat(request.targetTag, " is not whitelisted."));
            case 6:
              req = {
                targetIpId: validateAddress(request.targetIpId),
                targetTag: tag,
                disputeEvidenceHash: convertCIDtoHashIPFS(request.cid),
                data: data
              };
              encodedTxData = this.disputeModuleClient.raiseDisputeEncode(req);
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.n = 7;
                break;
              }
              return _context.a(2, {
                encodedTxData: encodedTxData
              });
            case 7:
              contractCall = function contractCall() {
                return _this.disputeModuleClient.raiseDispute(req);
              };
              _context.n = 8;
              return contractCallWithFees({
                options: {
                  wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                    // Disable multicall because multicall makes more complex due to disputeInitiator in this version.
                    useMulticallWhenPossible: false
                  })
                },
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                tokenSpenders: [{
                  address: this.arbitrationPolicyUmaClient.address,
                  amount: bonds,
                  // Currently, only WIP is supported as the whitelisted dispute bond token.
                  token: WIP_TOKEN_ADDRESS
                }],
                contractCall: contractCall,
                encodedTxs: [encodedTxData],
                wallet: this.wallet,
                txOptions: request.txOptions,
                sender: this.wallet.account.address
              });
            case 8:
              _yield$contractCallWi = _context.v;
              txHash = _yield$contractCallWi.txHash;
              receipt = _yield$contractCallWi.receipt;
              if (receipt) {
                _context.n = 9;
                break;
              }
              return _context.a(2, {
                txHash: txHash
              });
            case 9:
              targetLogs = this.disputeModuleClient.parseTxDisputeRaisedEvent(receipt);
              return _context.a(2, {
                txHash: txHash,
                disputeId: targetLogs[0].disputeId
              });
            case 10:
              _context.n = 12;
              break;
            case 11:
              _context.p = 11;
              _t = _context.v;
              return _context.a(2, handleError(_t, "Failed to raise dispute"));
            case 12:
              return _context.a(2);
          }
        }, _callee, this, [[0, 11]]);
      }));
      function raiseDispute(_x) {
        return _raiseDispute.apply(this, arguments);
      }
      return raiseDispute;
    }()
    /**
     * Cancels an ongoing dispute
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/dispute/IDisputeModule.sol#L84 | `DisputeCancelled`} event.
     */
    )
  }, {
    key: "cancelDispute",
    value: (function () {
      var _cancelDispute = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(request) {
        var _request$txOptions2, _req, txHash, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              _req = {
                disputeId: BigInt(request.disputeId),
                data: request.data ? request.data : "0x"
              };
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.encodedTxDataOnly)) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2, {
                encodedTxData: this.disputeModuleClient.cancelDisputeEncode(_req)
              });
            case 1:
              _context2.n = 2;
              return this.disputeModuleClient.cancelDispute(_req);
            case 2:
              txHash = _context2.v;
              _context2.n = 3;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 3:
              return _context2.a(2, {
                txHash: txHash
              });
            case 4:
              _context2.n = 6;
              break;
            case 5:
              _context2.p = 5;
              _t2 = _context2.v;
              return _context2.a(2, handleError(_t2, "Failed to cancel dispute"));
            case 6:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 5]]);
      }));
      function cancelDispute(_x2) {
        return _cancelDispute.apply(this, arguments);
      }
      return cancelDispute;
    }()
    /**
     * Resolves a dispute after it has been judged.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/dispute/IDisputeModule.sol#L104 | `DisputeResolved`} event.
     */
    )
  }, {
    key: "resolveDispute",
    value: (function () {
      var _resolveDispute = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(request) {
        var _request$data, _request$txOptions3, _req2, txHash, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              _req2 = {
                disputeId: BigInt(request.disputeId),
                data: (_request$data = request.data) !== null && _request$data !== void 0 ? _request$data : "0x"
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context3.n = 1;
                break;
              }
              return _context3.a(2, {
                encodedTxData: this.disputeModuleClient.resolveDisputeEncode(_req2)
              });
            case 1:
              _context3.n = 2;
              return this.disputeModuleClient.resolveDispute(_req2);
            case 2:
              txHash = _context3.v;
              _context3.n = 3;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 3:
              return _context3.a(2, {
                txHash: txHash
              });
            case 4:
              _context3.n = 6;
              break;
            case 5:
              _context3.p = 5;
              _t3 = _context3.v;
              return _context3.a(2, handleError(_t3, "Failed to resolve dispute"));
            case 6:
              return _context3.a(2);
          }
        }, _callee3, this, [[0, 5]]);
      }));
      function resolveDispute(_x3) {
        return _resolveDispute.apply(this, arguments);
      }
      return resolveDispute;
    }()
    /**
     * Tags a derivative if a parent has been tagged with an infringement tag
     * or a group ip if a group member has been tagged with an infringement tag.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/dispute/IDisputeModule.sol#L93 | `IpTaggedOnRelatedIpInfringement`} event.
     */
    )
  }, {
    key: "tagIfRelatedIpInfringed",
    value: (function () {
      var _tagIfRelatedIpInfringed = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(request) {
        var _this2 = this;
        var _request$options, objects, txHashes, calls, txHash, _iterator, _step, object, _txHash, _t4, _t5;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              objects = request.infringementTags.map(function (arg) {
                return {
                  ipIdToTag: validateAddress(arg.ipId),
                  infringerDisputeId: BigInt(arg.disputeId)
                };
              });
              txHashes = [];
              if (!(((_request$options = request.options) === null || _request$options === void 0 ? void 0 : _request$options.useMulticallWhenPossible) !== false && request.infringementTags.length > 1)) {
                _context4.n = 2;
                break;
              }
              calls = objects.map(function (object) {
                return {
                  target: _this2.disputeModuleClient.address,
                  allowFailure: false,
                  callData: _this2.disputeModuleClient.tagIfRelatedIpInfringedEncode(object).data
                };
              });
              _context4.n = 1;
              return this.multicall3Client.aggregate3({
                calls: calls
              });
            case 1:
              txHash = _context4.v;
              txHashes.push(txHash);
              _context4.n = 10;
              break;
            case 2:
              _iterator = _createForOfIteratorHelper(objects);
              _context4.p = 3;
              _iterator.s();
            case 4:
              if ((_step = _iterator.n()).done) {
                _context4.n = 7;
                break;
              }
              object = _step.value;
              _context4.n = 5;
              return this.disputeModuleClient.tagIfRelatedIpInfringed(object);
            case 5:
              _txHash = _context4.v;
              txHashes.push(_txHash);
            case 6:
              _context4.n = 4;
              break;
            case 7:
              _context4.n = 9;
              break;
            case 8:
              _context4.p = 8;
              _t4 = _context4.v;
              _iterator.e(_t4);
            case 9:
              _context4.p = 9;
              _iterator.f();
              return _context4.f(9);
            case 10:
              _context4.n = 11;
              return Promise.all(txHashes.map(function (txHash) {
                return waitForTxReceipt({
                  txHash: txHash,
                  txOptions: request.txOptions,
                  rpcClient: _this2.rpcClient
                });
              }));
            case 11:
              return _context4.a(2, _context4.v);
            case 12:
              _context4.p = 12;
              _t5 = _context4.v;
              return _context4.a(2, handleError(_t5, "Failed to tag related ip infringed"));
          }
        }, _callee4, this, [[3, 8, 9, 10], [0, 12]]);
      }));
      function tagIfRelatedIpInfringed(_x4) {
        return _tagIfRelatedIpInfringed.apply(this, arguments);
      }
      return tagIfRelatedIpInfringed;
    }()
    /**
     * Counters a dispute that was raised by another party on an IP using counter evidence.
     * The counter evidence (e.g., documents, images) should be uploaded to IPFS,
     * and its corresponding CID is converted to a hash for the request.
     *
     * @remarks
     *  The liveness period is split in two parts:
     *  - the first part of the liveness period in which only the IP's owner can be called the method.
     *  - a second part in which any address can be called the method.
     *
     * If you only have a `disputeId`, call {@link disputeIdToAssertionId} to get the `assertionId` needed here.
     */
    )
  }, {
    key: "disputeAssertion",
    value: (function () {
      var _disputeAssertion = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(request) {
        var _this3 = this;
        var ipAccount, bond, counterEvidenceHash, encodedData, _yield$this$wrappedIp, allowance, _txHash2, contractCall, _yield$contractCallWi2, txHash, receipt, _t6;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              _context5.p = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(request.ipId));
              _context5.n = 1;
              return getAssertionDetails(this.rpcClient, this.arbitrationPolicyUmaClient, request.assertionId);
            case 1:
              bond = _context5.v;
              counterEvidenceHash = convertCIDtoHashIPFS(request.counterEvidenceCID);
              encodedData = this.arbitrationPolicyUmaClient.disputeAssertionEncode({
                assertionId: request.assertionId,
                counterEvidenceHash: counterEvidenceHash
              });
              _context5.n = 2;
              return this.wrappedIpClient.allowance({
                owner: this.wallet.account.address,
                spender: ipAccount.address
              });
            case 2:
              _yield$this$wrappedIp = _context5.v;
              allowance = _yield$this$wrappedIp.result;
              if (!(allowance < bond)) {
                _context5.n = 4;
                break;
              }
              _context5.n = 3;
              return this.wrappedIpClient.approve({
                spender: ipAccount.address,
                amount: viem.maxUint256
              });
            case 3:
              _txHash2 = _context5.v;
              _context5.n = 4;
              return this.rpcClient.waitForTransactionReceipt({
                hash: _txHash2
              });
            case 4:
              contractCall = function contractCall() {
                var calls = [];
                if (bond > 0) {
                  calls.push({
                    target: _this3.wrappedIpClient.address,
                    value: 0n,
                    data: _this3.wrappedIpClient.transferFromEncode({
                      from: _this3.wallet.account.address,
                      to: ipAccount.address,
                      amount: bond
                    }).data
                  });
                  calls.push({
                    target: _this3.wrappedIpClient.address,
                    value: 0n,
                    data: _this3.wrappedIpClient.approveEncode({
                      spender: _this3.arbitrationPolicyUmaClient.address,
                      amount: viem.maxUint256
                    }).data
                  });
                }
                return ipAccount.executeBatch({
                  calls: [].concat(calls, [{
                    target: encodedData.to,
                    value: 0n,
                    data: encodedData.data
                  }]),
                  operation: 0
                });
              };
              _context5.n = 5;
              return contractCallWithFees({
                options: {
                  wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                    // Disable auto approve because msg.sender is ipAccount instead of wallet.
                    enableAutoApprove: false,
                    // Disable multicall because multicall makes more complex due to disputeInitiator in this version.
                    useMulticallWhenPossible: false
                  })
                },
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                contractCall: contractCall,
                tokenSpenders: [{
                  address: this.arbitrationPolicyUmaClient.address,
                  amount: bond,
                  // Currently, only WIP is supported as the whitelisted dispute bond token.
                  token: WIP_TOKEN_ADDRESS
                }],
                encodedTxs: [encodedData],
                wallet: this.wallet,
                sender: this.wallet.account.address,
                txOptions: request.txOptions
              });
            case 5:
              _yield$contractCallWi2 = _context5.v;
              txHash = _yield$contractCallWi2.txHash;
              receipt = _yield$contractCallWi2.receipt;
              return _context5.a(2, {
                txHash: txHash,
                receipt: receipt
              });
            case 6:
              _context5.p = 6;
              _t6 = _context5.v;
              return _context5.a(2, handleError(_t6, "Failed to dispute assertion"));
          }
        }, _callee5, this, [[0, 6]]);
      }));
      function disputeAssertion(_x5) {
        return _disputeAssertion.apply(this, arguments);
      }
      return disputeAssertion;
    }())
  }, {
    key: "disputeIdToAssertionId",
    value: function () {
      var _disputeIdToAssertionId = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(disputeId) {
        var assertionId;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              _context6.n = 1;
              return this.arbitrationPolicyUmaClient.disputeIdToAssertionId({
                disputeId: BigInt(disputeId)
              });
            case 1:
              assertionId = _context6.v;
              return _context6.a(2, assertionId);
          }
        }, _callee6, this);
      }));
      function disputeIdToAssertionId(_x6) {
        return _disputeIdToAssertionId.apply(this, arguments);
      }
      return disputeIdToAssertionId;
    }()
  }]);
}();

/**
 * This data used IP owners to define the configuration
 * when others are minting license tokens of their IP through the LicensingModule.
 * Contract reference: @see {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/lib/Licensing.sol#L27 | Licensing.sol}
 * For detailed documentation on licensing configuration, visit {@link https://docs.story.foundation/concepts/licensing-module/license-config}
 */

/**
 * Input for token amount, can be bigint or number.
 * Will be converted to bigint for contract calls.
 */

/**
 * Input for token id, can be bigint or number.
 * Will be converted to bigint for contract calls.
 */

/**
 * The type of revenue share.
 * It is used to determine the type of revenue share to be used in the revenue share calculation and throw error when the revenue share is not valid.
 */
var RevShareType = /*#__PURE__*/function (RevShareType) {
  RevShareType["COMMERCIAL_REVENUE_SHARE"] = "commercialRevShare";
  RevShareType["MAX_REVENUE_SHARE"] = "maxRevenueShare";
  RevShareType["MAX_ALLOWED_REWARD_SHARE"] = "maxAllowedRewardShare";
  RevShareType["EXPECT_MINIMUM_GROUP_REWARD_SHARE"] = "expectMinimumGroupRewardShare";
  RevShareType["MAX_ALLOWED_REWARD_SHARE_PERCENTAGE"] = "maxAllowedRewardSharePercentage";
  return RevShareType;
}({});

/**
 * Input for license terms id, can be bigint or number.
 * Will be converted to bigint for contract calls.
 */

/**
 * Input for deadline, can be bigint or number.
 * Will be converted to bigint for contract calls.
 */

/**
 * Input for revenue share, can be number.
 */

/**
 * Input for fee, can be bigint or number.
 * Will be converted to bigint for contract calls.
 */

/**
 * Permission level
 */
var AccessPermission = /*#__PURE__*/function (AccessPermission) {
  /**
   * ABSTAIN means having not enough information to make decision at
   * current level, deferred decision to up.
   */
  AccessPermission[AccessPermission["ABSTAIN"] = 0] = "ABSTAIN";
  /** ALLOW means the permission is granted to transaction signer to call the function. */
  AccessPermission[AccessPermission["ALLOW"] = 1] = "ALLOW";
  /** DENY means the permission is denied to transaction signer to call the function. */
  AccessPermission[AccessPermission["DENY"] = 2] = "DENY";
  return AccessPermission;
}({});

/**
 * Gets the function signature from an ABI for a given method name
 * @param abi - The contract ABI
 * @param methodName - The name of the method to get the signature for
 * @param overloadIndex - Optional index for overloaded functions (0-based)
 * @returns The function signature in standard format (e.g. "methodName(uint256,address)")
 * @throws Error if method not found or if overloadIndex is required but not provided
 */
var getFunctionSignature = function getFunctionSignature(abi, methodName, overloadIndex) {
  var functions = abi.filter(function (x) {
    return x.type === "function" && x.name === methodName;
  });
  if (functions.length === 0) {
    throw new Error("Method ".concat(methodName, " not found in ABI."));
  }
  if (functions.length > 1 && overloadIndex === undefined) {
    throw new Error("Method ".concat(methodName, " has ").concat(functions.length, " overloads. Please specify overloadIndex (0-").concat(functions.length - 1, ")."));
  }
  var func = functions[0];
  var _getTypeString = function getTypeString(input) {
    if (input.type.startsWith("tuple")) {
      var _input$components;
      var components = (_input$components = input.components) === null || _input$components === void 0 ? void 0 : _input$components.map(function (comp) {
        return _getTypeString(comp);
      }).join(",");
      return "(".concat(components, ")");
    }
    return input.type;
  };
  var inputs = func.inputs.map(function (input) {
    return _getTypeString(input);
  }).join(",");
  return "".concat(methodName, "(").concat(inputs, ")");
};

var getIpMetadataForWorkflow = function getIpMetadataForWorkflow(ipMetadata) {
  return {
    ipMetadataURI: (ipMetadata === null || ipMetadata === void 0 ? void 0 : ipMetadata.ipMetadataURI) || "",
    ipMetadataHash: (ipMetadata === null || ipMetadata === void 0 ? void 0 : ipMetadata.ipMetadataHash) || viem.zeroHash,
    nftMetadataURI: (ipMetadata === null || ipMetadata === void 0 ? void 0 : ipMetadata.nftMetadataURI) || "",
    nftMetadataHash: (ipMetadata === null || ipMetadata === void 0 ? void 0 : ipMetadata.nftMetadataHash) || viem.zeroHash
  };
};

/** The amount of revenue token claimable. */

/**
 * Native royalty policy created by the Story team
 * - LAP: {@link https://docs.story.foundation/concepts/royalty-module/liquid-absolute-percentage | Liquid Absolute Percentage}
 * - LRP: {@link https://docs.story.foundation/concepts/royalty-module/liquid-relative-percentage | Liquid Relative Percentage}
 */
var NativeRoyaltyPolicy = /*#__PURE__*/function (NativeRoyaltyPolicy) {
  NativeRoyaltyPolicy[NativeRoyaltyPolicy["LAP"] = 0] = "LAP";
  NativeRoyaltyPolicy[NativeRoyaltyPolicy["LRP"] = 1] = "LRP";
  return NativeRoyaltyPolicy;
}({});

/**
 * Allow custom royalty policy address or use a native royalty policy enum.
 * For custom royalty policy, @see {@link https://docs.story.foundation/concepts/royalty-module/external-royalty-policies | External Royalty Policies}
 */

var royaltyPolicyInputToAddress = function royaltyPolicyInputToAddress(input, chainId) {
  var transferredChainId = chain[chainId || "aeneid"];
  var address;
  switch (input) {
    case undefined:
    case NativeRoyaltyPolicy.LAP:
      address = royaltyPolicyLapAddress[transferredChainId];
      break;
    case NativeRoyaltyPolicy.LRP:
      address = royaltyPolicyLrpAddress[transferredChainId];
      break;
    default:
      address = validateAddress(input);
  }
  return address;
};
var getRevenueShare = function getRevenueShare(revShareNumber) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RevShareType.COMMERCIAL_REVENUE_SHARE;
  if (revShareNumber < 0 || revShareNumber > 100) {
    throw new Error("".concat(type, " must be between 0 and 100."));
  }
  // use Math.trunc to avoid precision issues
  return Math.trunc(revShareNumber * Math.pow(10, 6));
};

/**
 * Get the signature for setting permissions.
 */
var getPermissionSignature = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(param) {
    var ipId, deadline, state, wallet, chainId, permissions, accessAddress, isBatchPermissionFunction, data;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          ipId = param.ipId, deadline = param.deadline, state = param.state, wallet = param.wallet, chainId = param.chainId, permissions = param.permissions;
          accessAddress = accessControllerAddress[chainId];
          isBatchPermissionFunction = permissions.length >= 2;
          data = viem.encodeFunctionData({
            abi: accessControllerAbi,
            functionName: isBatchPermissionFunction ? "setBatchTransientPermissions" : "setTransientPermission",
            args: isBatchPermissionFunction ? [permissions.map(function (item) {
              return {
                ipAccount: validateAddress(item.ipId),
                signer: validateAddress(item.signer),
                to: validateAddress(item.to),
                func: item.func ? viem.toFunctionSelector(item.func) : defaultFunctionSelector,
                permission: item.permission
              };
            })] : [validateAddress(permissions[0].ipId), validateAddress(permissions[0].signer), validateAddress(permissions[0].to), permissions[0].func ? viem.toFunctionSelector(permissions[0].func) : defaultFunctionSelector, permissions[0].permission]
          });
          _context.n = 1;
          return getSignature({
            state: state,
            to: accessAddress,
            encodeData: data,
            wallet: wallet,
            verifyingContract: ipId,
            deadline: deadline,
            chainId: chainId
          });
        case 1:
          return _context.a(2, _context.v);
      }
    }, _callee);
  }));
  return function getPermissionSignature(_x) {
    return _ref.apply(this, arguments);
  };
}();
var getDeadline = function getDeadline(unixTimestamp, deadline) {
  if (deadline && BigInt(deadline) < 0n) {
    throw new Error("Invalid deadline value.");
  }
  return deadline ? unixTimestamp + BigInt(deadline) : unixTimestamp + 1000n;
};

/**
 * Get the signature.
 */
var getSignature = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(_ref2) {
    var state, to, encodeData, wallet, verifyingContract, deadline, chainId, nonce, signature;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          state = _ref2.state, to = _ref2.to, encodeData = _ref2.encodeData, wallet = _ref2.wallet, verifyingContract = _ref2.verifyingContract, deadline = _ref2.deadline, chainId = _ref2.chainId;
          if (wallet.signTypedData) {
            _context2.n = 1;
            break;
          }
          throw new Error("The wallet client does not support signTypedData, please try again.");
        case 1:
          if (wallet.account) {
            _context2.n = 2;
            break;
          }
          throw new Error("The wallet client does not have an account, please try again.");
        case 2:
          nonce = viem.keccak256(viem.encodeAbiParameters([{
            name: "",
            type: "bytes32"
          }, {
            name: "",
            type: "bytes"
          }], [state, viem.encodeFunctionData({
            abi: ipAccountImplAbi,
            functionName: "execute",
            args: [to, 0n, encodeData]
          })]));
          _context2.n = 3;
          return wallet.signTypedData({
            account: wallet.account,
            domain: {
              name: "Story Protocol IP Account",
              version: "1",
              chainId: chainId,
              verifyingContract: verifyingContract
            },
            types: {
              Execute: [{
                name: "to",
                type: "address"
              }, {
                name: "value",
                type: "uint256"
              }, {
                name: "data",
                type: "bytes"
              }, {
                name: "nonce",
                type: "bytes32"
              }, {
                name: "deadline",
                type: "uint256"
              }]
            },
            primaryType: "Execute",
            message: {
              to: to,
              value: BigInt(0),
              data: encodeData,
              nonce: nonce,
              deadline: BigInt(deadline)
            }
          });
        case 3:
          signature = _context2.v;
          return _context2.a(2, {
            signature: signature,
            nonce: nonce
          });
      }
    }, _callee2);
  }));
  return function getSignature(_x2) {
    return _ref3.apply(this, arguments);
  };
}();

var validateLicenseConfig = function validateLicenseConfig(licensingConfig) {
  if (!licensingConfig) {
    return {
      isSet: false,
      mintingFee: 0n,
      licensingHook: viem.zeroAddress,
      hookData: viem.zeroHash,
      commercialRevShare: 0,
      disabled: false,
      expectMinimumGroupRewardShare: 0,
      expectGroupRewardPool: viem.zeroAddress
    };
  }
  var licenseConfig = {
    expectMinimumGroupRewardShare: getRevenueShare(licensingConfig.expectMinimumGroupRewardShare, RevShareType.EXPECT_MINIMUM_GROUP_REWARD_SHARE),
    commercialRevShare: getRevenueShare(licensingConfig.commercialRevShare),
    mintingFee: BigInt(licensingConfig.mintingFee),
    expectGroupRewardPool: validateAddress(licensingConfig.expectGroupRewardPool),
    licensingHook: validateAddress(licensingConfig.licensingHook),
    hookData: licensingConfig.hookData,
    isSet: licensingConfig.isSet,
    disabled: licensingConfig.disabled
  };
  if (licenseConfig.mintingFee < 0) {
    throw new Error("The mintingFee must be greater than 0.");
  }
  return licenseConfig;
};

var GroupClient = /*#__PURE__*/function () {
  function GroupClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, GroupClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.groupingWorkflowsClient = new GroupingWorkflowsClient(rpcClient, wallet);
    this.groupingModuleEventClient = new GroupingModuleEventClient(rpcClient);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseTokenReadOnlyClient = new LicenseTokenReadOnlyClient(rpcClient);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.groupingModuleClient = new GroupingModuleClient(rpcClient, wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(rpcClient, wallet);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.royaltyModuleEventClient = new RoyaltyModuleEventClient(rpcClient);
  }

  /** Registers a Group IPA.
   *
   * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L14 | `IPGroupRegistered`} event.
   */
  return _createClass(GroupClient, [{
    key: "registerGroup",
    value: (function () {
      var _registerGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(request) {
        var _request$txOptions, object, txHash, txReceipt, groupId, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              object = {
                groupPool: validateAddress(request.groupPool)
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.n = 1;
                break;
              }
              return _context.a(2, {
                encodedTxData: this.groupingModuleClient.registerGroupEncode(object)
              });
            case 1:
              _context.n = 2;
              return this.groupingModuleClient.registerGroup(object);
            case 2:
              txHash = _context.v;
              _context.n = 3;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 3:
              txReceipt = _context.v;
              groupId = this.groupingModuleEventClient.parseTxIpGroupRegisteredEvent(txReceipt)[0].groupId;
              return _context.a(2, {
                txHash: txHash,
                groupId: groupId
              });
            case 4:
              _context.n = 6;
              break;
            case 5:
              _context.p = 5;
              _t = _context.v;
              return _context.a(2, handleError(_t, "Failed to register group"));
            case 6:
              return _context.a(2);
          }
        }, _callee, this, [[0, 5]]);
      }));
      function registerGroup(_x) {
        return _registerGroup.apply(this, arguments);
      }
      return registerGroup;
    }()
    /** Mint an NFT from a SPGNFT collection, register it with metadata as an IP, attach license terms to the registered IP, and add it to a group IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIpAndAttachLicenseAndAddToGroup",
    value: (function () {
      var _mintAndRegisterIpAndAttachLicenseAndAddToGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(request) {
        var _request$maxAllowedRe, _request$txOptions2, groupId, recipient, spgNftContract, deadline, isRegistered, ipAccount, _yield$ipAccount$stat, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS, sigAddToGroupSignature, object, txHash, receipt, log, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              groupId = request.groupId, recipient = request.recipient, spgNftContract = request.spgNftContract, deadline = request.deadline;
              _context2.n = 1;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(groupId)
              });
            case 1:
              isRegistered = _context2.v;
              if (isRegistered) {
                _context2.n = 2;
                break;
              }
              throw new Error("Group IP ".concat(groupId, " is not registered."));
            case 2:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, groupId);
              _context2.n = 3;
              return ipAccount.state();
            case 3:
              _yield$ipAccount$stat = _context2.v;
              state = _yield$ipAccount$stat.result;
              _context2.n = 4;
              return this.rpcClient.getBlock();
            case 4:
              blockTimestamp = _context2.v.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, deadline);
              _context2.n = 5;
              return getPermissionSignature({
                ipId: groupId,
                deadline: calculatedDeadline,
                state: state,
                wallet: this.wallet,
                chainId: this.chainId,
                permissions: [{
                  ipId: groupId,
                  signer: validateAddress(this.groupingWorkflowsClient.address),
                  to: validateAddress(this.groupingModuleClient.address),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(groupingModuleAbi, "addIp")
                }]
              });
            case 5:
              _yield$getPermissionS = _context2.v;
              sigAddToGroupSignature = _yield$getPermissionS.signature;
              object = _objectSpread2(_objectSpread2({}, request), {}, {
                allowDuplicates: request.allowDuplicates || true,
                spgNftContract: validateAddress(spgNftContract),
                recipient: validateAddress(recipient || this.wallet.account.address),
                maxAllowedRewardShare: BigInt(getRevenueShare((_request$maxAllowedRe = request.maxAllowedRewardShare) !== null && _request$maxAllowedRe !== void 0 ? _request$maxAllowedRe : 100, RevShareType.MAX_ALLOWED_REWARD_SHARE)),
                licensesData: this.getLicenseData(request.licenseData),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigAddToGroup: {
                  signer: validateAddress(this.wallet.account.address),
                  deadline: calculatedDeadline,
                  signature: sigAddToGroupSignature
                }
              });
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.encodedTxDataOnly)) {
                _context2.n = 6;
                break;
              }
              return _context2.a(2, {
                encodedTxData: this.groupingWorkflowsClient.mintAndRegisterIpAndAttachLicenseAndAddToGroupEncode(object)
              });
            case 6:
              _context2.n = 7;
              return this.groupingWorkflowsClient.mintAndRegisterIpAndAttachLicenseAndAddToGroup(object);
            case 7:
              txHash = _context2.v;
              _context2.n = 8;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 8:
              receipt = _context2.v;
              log = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt)[0];
              return _context2.a(2, {
                txHash: txHash,
                ipId: log.ipId,
                tokenId: log.tokenId
              });
            case 9:
              _context2.n = 11;
              break;
            case 10:
              _context2.p = 10;
              _t2 = _context2.v;
              return _context2.a(2, handleError(_t2, "Failed to mint and register IP and attach license and add to group"));
            case 11:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 10]]);
      }));
      function mintAndRegisterIpAndAttachLicenseAndAddToGroup(_x2) {
        return _mintAndRegisterIpAndAttachLicenseAndAddToGroup.apply(this, arguments);
      }
      return mintAndRegisterIpAndAttachLicenseAndAddToGroup;
    }()
    /** Register an NFT as IP with metadata, attach license terms to the registered IP, and add it to a group IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "registerIpAndAttachLicenseAndAddToGroup",
    value: (function () {
      var _registerIpAndAttachLicenseAndAddToGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(request) {
        var _request$maxAllowedRe2, _request$txOptions3, ipIdAddress, isRegistered, ipAccount, _yield$ipAccount$stat2, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS2, sigAddToGroupSignature, _yield$getPermissionS3, sigMetadataAndAttachSignature, object, txHash, receipt, log, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              _context3.n = 1;
              return this.ipAssetRegistryClient.ipId({
                chainId: BigInt(this.chainId),
                tokenContract: validateAddress(request.nftContract),
                tokenId: BigInt(request.tokenId)
              });
            case 1:
              ipIdAddress = _context3.v;
              _context3.n = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.groupId)
              });
            case 2:
              isRegistered = _context3.v;
              if (isRegistered) {
                _context3.n = 3;
                break;
              }
              throw new Error("Group IP ".concat(request.groupId, " is not registered."));
            case 3:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, request.groupId);
              _context3.n = 4;
              return ipAccount.state();
            case 4:
              _yield$ipAccount$stat2 = _context3.v;
              state = _yield$ipAccount$stat2.result;
              _context3.n = 5;
              return this.rpcClient.getBlock();
            case 5:
              blockTimestamp = _context3.v.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, request.deadline);
              _context3.n = 6;
              return getPermissionSignature({
                ipId: request.groupId,
                deadline: calculatedDeadline,
                state: state,
                wallet: this.wallet,
                chainId: this.chainId,
                permissions: [{
                  ipId: request.groupId,
                  signer: this.groupingWorkflowsClient.address,
                  to: this.groupingModuleClient.address,
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(groupingModuleAbi, "addIp")
                }]
              });
            case 6:
              _yield$getPermissionS2 = _context3.v;
              sigAddToGroupSignature = _yield$getPermissionS2.signature;
              _context3.n = 7;
              return getPermissionSignature({
                ipId: ipIdAddress,
                deadline: calculatedDeadline,
                state: viem.toHex(0, {
                  size: 32
                }),
                wallet: this.wallet,
                chainId: this.chainId,
                permissions: [{
                  ipId: ipIdAddress,
                  signer: this.groupingWorkflowsClient.address,
                  to: validateAddress(this.coreMetadataModuleClient.address),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
                }, {
                  ipId: ipIdAddress,
                  signer: this.groupingWorkflowsClient.address,
                  to: validateAddress(this.licensingModuleClient.address),
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
                }, {
                  ipId: ipIdAddress,
                  signer: this.groupingWorkflowsClient.address,
                  to: this.licensingModuleClient.address,
                  permission: AccessPermission.ALLOW,
                  func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
                }]
              });
            case 7:
              _yield$getPermissionS3 = _context3.v;
              sigMetadataAndAttachSignature = _yield$getPermissionS3.signature;
              object = {
                nftContract: request.nftContract,
                groupId: request.groupId,
                licensesData: this.getLicenseData(request.licenseData),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                tokenId: BigInt(request.tokenId),
                maxAllowedRewardShare: BigInt(getRevenueShare((_request$maxAllowedRe2 = request.maxAllowedRewardShare) !== null && _request$maxAllowedRe2 !== void 0 ? _request$maxAllowedRe2 : 100, RevShareType.MAX_ALLOWED_REWARD_SHARE)),
                sigAddToGroup: {
                  signer: validateAddress(this.wallet.account.address),
                  deadline: calculatedDeadline,
                  signature: sigAddToGroupSignature
                },
                sigMetadataAndAttachAndConfig: {
                  signer: this.wallet.account.address,
                  deadline: calculatedDeadline,
                  signature: sigMetadataAndAttachSignature
                }
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context3.n = 8;
                break;
              }
              return _context3.a(2, {
                encodedTxData: this.groupingWorkflowsClient.registerIpAndAttachLicenseAndAddToGroupEncode(object)
              });
            case 8:
              _context3.n = 9;
              return this.groupingWorkflowsClient.registerIpAndAttachLicenseAndAddToGroup(object);
            case 9:
              txHash = _context3.v;
              _context3.n = 10;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 10:
              receipt = _context3.v;
              log = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt)[0];
              return _context3.a(2, {
                txHash: txHash,
                ipId: log.ipId,
                tokenId: log.tokenId
              });
            case 11:
              _context3.p = 11;
              _t3 = _context3.v;
              return _context3.a(2, handleError(_t3, "Failed to register IP and attach license and add to group"));
          }
        }, _callee3, this, [[0, 11]]);
      }));
      function registerIpAndAttachLicenseAndAddToGroup(_x3) {
        return _registerIpAndAttachLicenseAndAddToGroup.apply(this, arguments);
      }
      return registerIpAndAttachLicenseAndAddToGroup;
    }()
    /** Register a group IP with a group reward pool and attach license terms to the group IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L14 | `IPGroupRegistered`} event.
     */
    )
  }, {
    key: "registerGroupAndAttachLicense",
    value: (function () {
      var _registerGroupAndAttachLicense = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(request) {
        var _request$txOptions4, object, txHash, txReceipt, groupId, _t4;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              object = {
                groupPool: validateAddress(request.groupPool),
                licenseData: this.getLicenseData(request.licenseData)[0]
              };
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.encodedTxDataOnly)) {
                _context4.n = 1;
                break;
              }
              return _context4.a(2, {
                encodedTxData: this.groupingWorkflowsClient.registerGroupAndAttachLicenseEncode(object)
              });
            case 1:
              _context4.n = 2;
              return this.groupingWorkflowsClient.registerGroupAndAttachLicense(object);
            case 2:
              txHash = _context4.v;
              _context4.n = 3;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 3:
              txReceipt = _context4.v;
              groupId = this.groupingModuleEventClient.parseTxIpGroupRegisteredEvent(txReceipt)[0].groupId;
              return _context4.a(2, {
                txHash: txHash,
                groupId: groupId
              });
            case 4:
              _context4.p = 4;
              _t4 = _context4.v;
              return _context4.a(2, handleError(_t4, "Failed to register group and attach license"));
          }
        }, _callee4, this, [[0, 4]]);
      }));
      function registerGroupAndAttachLicense(_x4) {
        return _registerGroupAndAttachLicense.apply(this, arguments);
      }
      return registerGroupAndAttachLicense;
    }()
    /** Register a group IP with a group reward pool, attach license terms to the group IP, and add individual IPs to the group IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L14 | `IPGroupRegistered`} event.
     */
    )
  }, {
    key: "registerGroupAndAttachLicenseAndAddIps",
    value: (function () {
      var _registerGroupAndAttachLicenseAndAddIps = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(request) {
        var _request$maxAllowedRe3, _request$txOptions5, object, i, isRegistered, _i, isAttachedLicenseTerms, txHash, txReceipt, groupId, _t5;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              _context5.p = 0;
              object = {
                groupPool: validateAddress(request.groupPool),
                ipIds: request.ipIds,
                licenseData: this.getLicenseData(request.licenseData)[0],
                maxAllowedRewardShare: BigInt(getRevenueShare((_request$maxAllowedRe3 = request.maxAllowedRewardShare) !== null && _request$maxAllowedRe3 !== void 0 ? _request$maxAllowedRe3 : 100, RevShareType.MAX_ALLOWED_REWARD_SHARE))
              };
              i = 0;
            case 1:
              if (!(i < request.ipIds.length)) {
                _context5.n = 4;
                break;
              }
              _context5.n = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.ipIds[i])
              });
            case 2:
              isRegistered = _context5.v;
              if (isRegistered) {
                _context5.n = 3;
                break;
              }
              throw new Error("IP ".concat(request.ipIds[i], " is not registered."));
            case 3:
              i++;
              _context5.n = 1;
              break;
            case 4:
              _i = 0;
            case 5:
              if (!(_i < request.ipIds.length)) {
                _context5.n = 8;
                break;
              }
              _context5.n = 6;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.ipIds[_i],
                licenseTemplate: object.licenseData.licenseTemplate,
                licenseTermsId: object.licenseData.licenseTermsId
              });
            case 6:
              isAttachedLicenseTerms = _context5.v;
              if (isAttachedLicenseTerms) {
                _context5.n = 7;
                break;
              }
              throw new Error("License terms must be attached to IP ".concat(request.ipIds[_i], " before adding to group."));
            case 7:
              _i++;
              _context5.n = 5;
              break;
            case 8:
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context5.n = 9;
                break;
              }
              return _context5.a(2, {
                encodedTxData: this.groupingWorkflowsClient.registerGroupAndAttachLicenseAndAddIpsEncode(object)
              });
            case 9:
              _context5.n = 10;
              return this.groupingWorkflowsClient.registerGroupAndAttachLicenseAndAddIps(object);
            case 10:
              txHash = _context5.v;
              _context5.n = 11;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 11:
              txReceipt = _context5.v;
              groupId = this.groupingModuleEventClient.parseTxIpGroupRegisteredEvent(txReceipt)[0].groupId;
              return _context5.a(2, {
                txHash: txHash,
                groupId: groupId
              });
            case 12:
              _context5.p = 12;
              _t5 = _context5.v;
              return _context5.a(2, handleError(_t5, "Failed to register group and attach license and add ips"));
          }
        }, _callee5, this, [[0, 12]]);
      }));
      function registerGroupAndAttachLicenseAndAddIps(_x5) {
        return _registerGroupAndAttachLicenseAndAddIps.apply(this, arguments);
      }
      return registerGroupAndAttachLicenseAndAddIps;
    }()
    /**
     * Collect royalties for the entire group and distribute the rewards to each member IP's royalty vault.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L38 | `CollectedRoyaltiesToGroupPool`} event.
     */
    )
  }, {
    key: "collectAndDistributeGroupRoyalties",
    value: (function () {
      var _collectAndDistributeGroupRoyalties = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(_ref) {
        var _this = this;
        var groupIpId, currencyTokens, memberIpIds, txOptions, collectAndClaimParams, isGroupRegistered, txHash, _yield$waitForTxRecei, receipt, collectedRoyalties, royaltiesDistributed, _t6;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              groupIpId = _ref.groupIpId, currencyTokens = _ref.currencyTokens, memberIpIds = _ref.memberIpIds, txOptions = _ref.txOptions;
              _context7.p = 1;
              if (currencyTokens.length) {
                _context7.n = 2;
                break;
              }
              throw new Error("At least one currency token is required.");
            case 2:
              if (memberIpIds.length) {
                _context7.n = 3;
                break;
              }
              throw new Error("At least one member IP ID is required.");
            case 3:
              if (!currencyTokens.some(function (token) {
                return token === viem.zeroAddress;
              })) {
                _context7.n = 4;
                break;
              }
              throw new Error("Currency token cannot be the zero address.");
            case 4:
              collectAndClaimParams = {
                groupIpId: validateAddress(groupIpId),
                currencyTokens: validateAddresses(currencyTokens),
                memberIpIds: validateAddresses(memberIpIds)
              };
              _context7.n = 5;
              return this.ipAssetRegistryClient.isRegistered({
                id: collectAndClaimParams.groupIpId
              });
            case 5:
              isGroupRegistered = _context7.v;
              if (isGroupRegistered) {
                _context7.n = 6;
                break;
              }
              throw new Error("The group IP with ID ".concat(collectAndClaimParams.groupIpId, " is not registered."));
            case 6:
              _context7.n = 7;
              return Promise.all(collectAndClaimParams.memberIpIds.map(/*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(ipId) {
                  var isMemberRegistered;
                  return _regenerator().w(function (_context6) {
                    while (1) switch (_context6.n) {
                      case 0:
                        _context6.n = 1;
                        return _this.ipAssetRegistryClient.isRegistered({
                          id: ipId
                        });
                      case 1:
                        isMemberRegistered = _context6.v;
                        if (isMemberRegistered) {
                          _context6.n = 2;
                          break;
                        }
                        throw new Error("Member IP with ID ".concat(ipId, " is not registered ."));
                      case 2:
                        return _context6.a(2);
                    }
                  }, _callee6);
                }));
                return function (_x7) {
                  return _ref2.apply(this, arguments);
                };
              }()));
            case 7:
              _context7.n = 8;
              return this.groupingWorkflowsClient.collectRoyaltiesAndClaimReward(collectAndClaimParams);
            case 8:
              txHash = _context7.v;
              _context7.n = 9;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 9:
              _yield$waitForTxRecei = _context7.v;
              receipt = _yield$waitForTxRecei.receipt;
              if (receipt) {
                _context7.n = 10;
                break;
              }
              return _context7.a(2, {
                txHash: txHash
              });
            case 10:
              collectedRoyalties = this.groupingModuleEventClient.parseTxCollectedRoyaltiesToGroupPoolEvent(receipt).map(function (_ref3) {
                var groupId = _ref3.groupId,
                  amount = _ref3.amount,
                  token = _ref3.token;
                return {
                  groupId: groupId,
                  amount: amount,
                  token: token
                };
              });
              royaltiesDistributed = this.royaltyModuleEventClient.parseTxRoyaltyPaidEvent(receipt).map(function (_ref4) {
                var receiverIpId = _ref4.receiverIpId,
                  amount = _ref4.amount,
                  token = _ref4.token,
                  amountAfterFee = _ref4.amountAfterFee;
                return {
                  ipId: receiverIpId,
                  amount: amount,
                  token: token,
                  amountAfterFee: amountAfterFee
                };
              });
              return _context7.a(2, {
                txHash: txHash,
                collectedRoyalties: collectedRoyalties,
                royaltiesDistributed: royaltiesDistributed
              });
            case 11:
              _context7.p = 11;
              _t6 = _context7.v;
              return _context7.a(2, handleError(_t6, "Failed to collect and distribute group royalties"));
          }
        }, _callee7, this, [[1, 11]]);
      }));
      function collectAndDistributeGroupRoyalties(_x6) {
        return _collectAndDistributeGroupRoyalties.apply(this, arguments);
      }
      return collectAndDistributeGroupRoyalties;
    }()
    /**
     * Adds IPs to group.
     * The function must be called by the Group IP owner or an authorized operator.
     */
    )
  }, {
    key: "addIpsToGroup",
    value: (function () {
      var _addIpsToGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(_ref5) {
        var groupIpId, ipIds, maxAllowedRewardSharePercentage, txOptions, addIpParam, txHash, _t7;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              groupIpId = _ref5.groupIpId, ipIds = _ref5.ipIds, maxAllowedRewardSharePercentage = _ref5.maxAllowedRewardSharePercentage, txOptions = _ref5.txOptions;
              _context8.p = 1;
              addIpParam = {
                groupIpId: validateAddress(groupIpId),
                ipIds: validateAddresses(ipIds),
                maxAllowedRewardShare: BigInt(getRevenueShare(maxAllowedRewardSharePercentage !== null && maxAllowedRewardSharePercentage !== void 0 ? maxAllowedRewardSharePercentage : 100, RevShareType.MAX_ALLOWED_REWARD_SHARE_PERCENTAGE))
              };
              _context8.n = 2;
              return this.groupingModuleClient.addIp(addIpParam);
            case 2:
              txHash = _context8.v;
              _context8.n = 3;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 3:
              return _context8.a(2, _context8.v);
            case 4:
              _context8.p = 4;
              _t7 = _context8.v;
              return _context8.a(2, handleError(_t7, "Failed to add IP to group"));
          }
        }, _callee8, this, [[1, 4]]);
      }));
      function addIpsToGroup(_x8) {
        return _addIpsToGroup.apply(this, arguments);
      }
      return addIpsToGroup;
    }()
    /**
     * Returns the available reward for each IP in the group.
     */
    )
  }, {
    key: "getClaimableReward",
    value: (function () {
      var _getClaimableReward = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(_ref6) {
        var groupIpId, currencyToken, memberIpIds, claimableReward, _t8;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              groupIpId = _ref6.groupIpId, currencyToken = _ref6.currencyToken, memberIpIds = _ref6.memberIpIds;
              _context9.p = 1;
              _context9.n = 2;
              return this.groupingModuleClient.getClaimableReward({
                groupId: validateAddress(groupIpId),
                ipIds: validateAddresses(memberIpIds),
                token: validateAddress(currencyToken)
              });
            case 2:
              claimableReward = _context9.v;
              return _context9.a(2, claimableReward);
            case 3:
              _context9.p = 3;
              _t8 = _context9.v;
              return _context9.a(2, handleError(_t8, "Failed to get claimable reward"));
          }
        }, _callee9, this, [[1, 3]]);
      }));
      function getClaimableReward(_x9) {
        return _getClaimableReward.apply(this, arguments);
      }
      return getClaimableReward;
    }()
    /**
     * Removes IPs from group.
     * The function must be called by the Group IP owner or an authorized operator.
     */
    )
  }, {
    key: "removeIpsFromGroup",
    value: (function () {
      var _removeIpsFromGroup = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(_ref7) {
        var groupIpId, ipIds, txOptions, removeIpParam, txHash, _t9;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.p = _context0.n) {
            case 0:
              groupIpId = _ref7.groupIpId, ipIds = _ref7.ipIds, txOptions = _ref7.txOptions;
              _context0.p = 1;
              removeIpParam = {
                groupIpId: validateAddress(groupIpId),
                ipIds: validateAddresses(ipIds)
              };
              _context0.n = 2;
              return this.groupingModuleClient.removeIp(removeIpParam);
            case 2:
              txHash = _context0.v;
              _context0.n = 3;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 3:
              return _context0.a(2, _context0.v);
            case 4:
              _context0.p = 4;
              _t9 = _context0.v;
              return _context0.a(2, handleError(_t9, "Failed to remove IPs from group"));
          }
        }, _callee0, this, [[1, 4]]);
      }));
      function removeIpsFromGroup(_x0) {
        return _removeIpsFromGroup.apply(this, arguments);
      }
      return removeIpsFromGroup;
    }()
    /**
     * Claims reward.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L31 | `ClaimedReward`} event.
     */
    )
  }, {
    key: "claimReward",
    value: (function () {
      var _claimReward = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(_ref8) {
        var groupIpId, currencyToken, memberIpIds, txOptions, claimRewardParam, txHash, _yield$waitForTxRecei2, receipt, claimedReward, _t0;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.p = _context1.n) {
            case 0:
              groupIpId = _ref8.groupIpId, currencyToken = _ref8.currencyToken, memberIpIds = _ref8.memberIpIds, txOptions = _ref8.txOptions;
              _context1.p = 1;
              claimRewardParam = {
                groupId: validateAddress(groupIpId),
                ipIds: validateAddresses(memberIpIds),
                token: validateAddress(currencyToken)
              };
              _context1.n = 2;
              return this.groupingModuleClient.claimReward(claimRewardParam);
            case 2:
              txHash = _context1.v;
              _context1.n = 3;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 3:
              _yield$waitForTxRecei2 = _context1.v;
              receipt = _yield$waitForTxRecei2.receipt;
              if (receipt) {
                _context1.n = 4;
                break;
              }
              return _context1.a(2, {
                txHash: txHash
              });
            case 4:
              claimedReward = this.groupingModuleEventClient.parseTxClaimedRewardEvent(receipt);
              return _context1.a(2, {
                txHash: txHash,
                claimedReward: claimedReward
              });
            case 5:
              _context1.p = 5;
              _t0 = _context1.v;
              return _context1.a(2, handleError(_t0, "Failed to claim reward"));
          }
        }, _callee1, this, [[1, 5]]);
      }));
      function claimReward(_x1) {
        return _claimReward.apply(this, arguments);
      }
      return claimReward;
    }()
    /**
     * Collects royalties into the pool, making them claimable by group member IPs.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/grouping/IGroupingModule.sol#L38 | `CollectedRoyaltiesToGroupPool`} event.
     */
    )
  }, {
    key: "collectRoyalties",
    value: (function () {
      var _collectRoyalties = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref9) {
        var groupIpId, currencyToken, txOptions, collectRoyaltiesParam, txHash, _yield$waitForTxRecei3, receipt, collectedRoyalties, _t1;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.p = _context10.n) {
            case 0:
              groupIpId = _ref9.groupIpId, currencyToken = _ref9.currencyToken, txOptions = _ref9.txOptions;
              _context10.p = 1;
              collectRoyaltiesParam = {
                groupId: validateAddress(groupIpId),
                token: validateAddress(currencyToken)
              };
              _context10.n = 2;
              return this.groupingModuleClient.collectRoyalties(collectRoyaltiesParam);
            case 2:
              txHash = _context10.v;
              _context10.n = 3;
              return waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              });
            case 3:
              _yield$waitForTxRecei3 = _context10.v;
              receipt = _yield$waitForTxRecei3.receipt;
              if (receipt) {
                _context10.n = 4;
                break;
              }
              return _context10.a(2, {
                txHash: txHash
              });
            case 4:
              collectedRoyalties = this.groupingModuleEventClient.parseTxCollectedRoyaltiesToGroupPoolEvent(receipt)[0].amount;
              return _context10.a(2, {
                txHash: txHash,
                collectedRoyalties: collectedRoyalties
              });
            case 5:
              _context10.p = 5;
              _t1 = _context10.v;
              return _context10.a(2, handleError(_t1, "Failed to collect royalties"));
          }
        }, _callee10, this, [[1, 5]]);
      }));
      function collectRoyalties(_x10) {
        return _collectRoyalties.apply(this, arguments);
      }
      return collectRoyalties;
    }())
  }, {
    key: "getLicenseData",
    value: function getLicenseData(licenseData) {
      var _this2 = this;
      var isArray = Array.isArray(licenseData);
      if (isArray && licenseData.length === 0 || !licenseData) {
        throw new Error("License data is required.");
      }
      var licenseDataArray = isArray ? licenseData : [licenseData];
      return licenseDataArray.map(function (item) {
        return {
          licenseTemplate: validateAddress(item.licenseTemplate || _this2.licenseTemplateClient.address),
          licenseTermsId: BigInt(item.licenseTermsId),
          licensingConfig: validateLicenseConfig(item.licensingConfig)
        };
      });
    }
  }]);
}();

var IPAccountClient = /*#__PURE__*/function () {
  function IPAccountClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, IPAccountClient);
    this.wallet = wallet;
    this.rpcClient = rpcClient;
    this.chainId = chainId;
    this.wrappedIpClient = new WrappedIpClient(rpcClient, wallet);
    this.erc20Client = new Erc20Client(rpcClient, wallet);
  }

  /**
   * Executes a transaction from the IP Account.
   */
  return _createClass(IPAccountClient, [{
    key: "execute",
    value: (function () {
      var _execute = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(request) {
        var _request$txOptions, ipAccountClient, req, txHash, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(request.ipId));
              req = {
                to: request.to,
                value: BigInt(0),
                data: request.data
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.n = 1;
                break;
              }
              return _context.a(2, {
                encodedTxData: ipAccountClient.executeEncode(_objectSpread2(_objectSpread2({}, req), {}, {
                  operation: 0
                }))
              });
            case 1:
              _context.n = 2;
              return ipAccountClient.execute(_objectSpread2(_objectSpread2({}, req), {}, {
                operation: 0
              }));
            case 2:
              txHash = _context.v;
              _context.n = 3;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 3:
              return _context.a(2, {
                txHash: txHash
              });
            case 4:
              _context.n = 6;
              break;
            case 5:
              _context.p = 5;
              _t = _context.v;
              return _context.a(2, handleError(_t, "Failed to execute the IP Account transaction"));
            case 6:
              return _context.a(2);
          }
        }, _callee, this, [[0, 5]]);
      }));
      function execute(_x) {
        return _execute.apply(this, arguments);
      }
      return execute;
    }()
    /**
     * Executes a transaction from the IP Account with a signature.
     */
    )
  }, {
    key: "executeWithSig",
    value: (function () {
      var _executeWithSig = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(request) {
        var _request$txOptions2, ipAccountClient, req, txHash, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(request.ipId));
              req = {
                to: validateAddress(request.to),
                value: BigInt(request.value || 0),
                data: request.data,
                signer: validateAddress(request.signer),
                deadline: BigInt(request.deadline),
                signature: request.signature
              };
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.encodedTxDataOnly)) {
                _context2.n = 1;
                break;
              }
              return _context2.a(2, {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 1:
              _context2.n = 2;
              return ipAccountClient.executeWithSig(req);
            case 2:
              txHash = _context2.v;
              _context2.n = 3;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 3:
              return _context2.a(2, {
                txHash: txHash
              });
            case 4:
              _context2.n = 6;
              break;
            case 5:
              _context2.p = 5;
              _t2 = _context2.v;
              return _context2.a(2, handleError(_t2, "Failed to execute with signature for the IP Account transaction"));
            case 6:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 5]]);
      }));
      function executeWithSig(_x2) {
        return _executeWithSig.apply(this, arguments);
      }
      return executeWithSig;
    }()
    /**
     * Returns the IPAccount's internal nonce for transaction ordering.
     */
    )
  }, {
    key: "getIpAccountNonce",
    value: (function () {
      var _getIpAccountNonce = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(ipId) {
        var ipAccount, _yield$ipAccount$stat, state, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(ipId));
              _context3.n = 1;
              return ipAccount.state();
            case 1:
              _yield$ipAccount$stat = _context3.v;
              state = _yield$ipAccount$stat.result;
              return _context3.a(2, state);
            case 2:
              _context3.p = 2;
              _t3 = _context3.v;
              return _context3.a(2, handleError(_t3, "Failed to get the IP Account nonce"));
          }
        }, _callee3, this, [[0, 2]]);
      }));
      function getIpAccountNonce(_x3) {
        return _getIpAccountNonce.apply(this, arguments);
      }
      return getIpAccountNonce;
    }()
    /**
     * Returns the identifier of the non-fungible token which owns the account
     */
    )
  }, {
    key: "getToken",
    value: (function () {
      var _getToken = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(ipId) {
        var ipAccount, _yield$ipAccount$toke, _yield$ipAccount$toke2, chainId, tokenContract, tokenId, _t4;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(ipId));
              _context4.n = 1;
              return ipAccount.token();
            case 1:
              _yield$ipAccount$toke = _context4.v;
              _yield$ipAccount$toke2 = _slicedToArray(_yield$ipAccount$toke, 3);
              chainId = _yield$ipAccount$toke2[0];
              tokenContract = _yield$ipAccount$toke2[1];
              tokenId = _yield$ipAccount$toke2[2];
              return _context4.a(2, {
                chainId: chainId,
                tokenContract: tokenContract,
                tokenId: tokenId
              });
            case 2:
              _context4.p = 2;
              _t4 = _context4.v;
              return _context4.a(2, handleError(_t4, "Failed to get the token"));
          }
        }, _callee4, this, [[0, 2]]);
      }));
      function getToken(_x4) {
        return _getToken.apply(this, arguments);
      }
      return getToken;
    }()
    /**
     * Sets the metadataURI for an IP asset.
     */
    )
  }, {
    key: "setIpMetadata",
    value: (function () {
      var _setIpMetadata = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(_ref) {
        var ipId, metadataURI, metadataHash, txOptions, data, _yield$this$execute, txHash, _t5;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              ipId = _ref.ipId, metadataURI = _ref.metadataURI, metadataHash = _ref.metadataHash, txOptions = _ref.txOptions;
              _context5.p = 1;
              data = viem.encodeFunctionData({
                abi: coreMetadataModuleAbi,
                functionName: "setMetadataURI",
                args: [validateAddress(ipId), metadataURI, metadataHash]
              });
              _context5.n = 2;
              return this.execute({
                ipId: ipId,
                to: coreMetadataModuleAddress[this.chainId],
                data: data,
                value: 0,
                txOptions: _objectSpread2(_objectSpread2({}, txOptions), {}, {
                  encodedTxDataOnly: false
                })
              });
            case 2:
              _yield$this$execute = _context5.v;
              txHash = _yield$this$execute.txHash;
              return _context5.a(2, txHash);
            case 3:
              _context5.p = 3;
              _t5 = _context5.v;
              return _context5.a(2, handleError(_t5, "Failed to set the IP metadata"));
          }
        }, _callee5, this, [[1, 3]]);
      }));
      function setIpMetadata(_x5) {
        return _setIpMetadata.apply(this, arguments);
      }
      return setIpMetadata;
    }()
    /**
     * Transfers ERC20 tokens from the IP Account to the target address.
     */
    )
  }, {
    key: "transferErc20",
    value: (function () {
      var _transferErc = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref2) {
        var _this = this;
        var ipId, tokens, txOptions, ipAccount, calls, txHash, _t6;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              ipId = _ref2.ipId, tokens = _ref2.tokens, txOptions = _ref2.txOptions;
              _context6.p = 1;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(ipId));
              calls = tokens.map(function (_ref3) {
                var token = _ref3.address,
                  target = _ref3.target,
                  amount = _ref3.amount;
                var encodedData;
                if (validateAddress(token) === WIP_TOKEN_ADDRESS) {
                  encodedData = _this.wrappedIpClient.transferEncode({
                    to: validateAddress(target),
                    amount: BigInt(amount)
                  }).data;
                } else {
                  encodedData = _this.erc20Client.transferEncode({
                    to: validateAddress(target),
                    value: BigInt(amount)
                  }).data;
                }
                return {
                  target: token,
                  data: encodedData,
                  value: 0n
                };
              });
              _context6.n = 2;
              return ipAccount.executeBatch({
                calls: calls,
                operation: 0
              });
            case 2:
              txHash = _context6.v;
              return _context6.a(2, waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 3:
              _context6.p = 3;
              _t6 = _context6.v;
              return _context6.a(2, handleError(_t6, "Failed to transfer Erc20"));
          }
        }, _callee6, this, [[1, 3]]);
      }));
      function transferErc20(_x6) {
        return _transferErc.apply(this, arguments);
      }
      return transferErc20;
    }())
  }]);
}();

var SignatureMethodType = /*#__PURE__*/function (SignatureMethodType) {
  SignatureMethodType["REGISTER_IP_AND_MAKE_DERIVATIVE_AND_DEPLOY_ROYALTY_VAULT"] = "registerIpAndMakeDerivativeAndDeployRoyaltyVault";
  SignatureMethodType["DISTRIBUTE_ROYALTY_TOKENS"] = "distributeRoyaltyTokens";
  SignatureMethodType["REGISTER_DERIVATIVE_IP"] = "registerDerivativeIp";
  SignatureMethodType["REGISTER_IP_AND_ATTACH_PIL_TERMS_AND_DEPLOY_ROYALTY_VAULT"] = "registerIpAndAttachPilTermsAndDeployRoyaltyVault";
  SignatureMethodType["REGISTER_IP_AND_ATTACH_PIL_TERMS"] = "registerIpAndAttachPilTerms";
  SignatureMethodType["REGISTER_IP_AND_MAKE_DERIVATIVE_WITH_LICENSE_TOKENS"] = "registerIpAndMakeDerivativeWithLicenseTokens";
  SignatureMethodType["REGISTER_PIL_TERMS_AND_ATTACH"] = "registerPilTermsAndAttach";
  SignatureMethodType["REGISTER"] = "register";
  SignatureMethodType["BATCH_REGISTER_DERIVATIVE"] = "batchRegisterDerivative";
  return SignatureMethodType;
}({});

/**
 * Predict the minting license fee.
 *
 * @remarks
 * The method passes `walletAddress` to the `readContract` function so the smart contract can verify
 * if the wallet is the owner of the IP ID. The wallet address is required when using the default license terms ID.
 */
var predictMintingLicenseFee = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(_ref) {
    var predictMintingFeeRequest, rpcClient, chainId, walletAddress, result;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          predictMintingFeeRequest = _ref.predictMintingFeeRequest, rpcClient = _ref.rpcClient, chainId = _ref.chainId, walletAddress = _ref.walletAddress;
          _context.n = 1;
          return rpcClient.readContract({
            abi: licensingModuleAbi,
            address: licensingModuleAddress[chainId],
            functionName: "predictMintingLicenseFee",
            args: [predictMintingFeeRequest.licensorIpId, predictMintingFeeRequest.licenseTemplate, predictMintingFeeRequest.licenseTermsId, predictMintingFeeRequest.amount, predictMintingFeeRequest.receiver, predictMintingFeeRequest.royaltyContext],
            account: walletAddress
          });
        case 1:
          result = _context.v;
          return _context.a(2, {
            currencyToken: result[0],
            tokenAmount: result[1]
          });
      }
    }, _callee);
  }));
  return function predictMintingLicenseFee(_x) {
    return _ref2.apply(this, arguments);
  };
}();
var calculateDerivativeMintingFee = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(_ref3) {
    var derivData, rpcClient, chainId, wallet, sender, walletAddress, mintFees, i, mintFee;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          derivData = _ref3.derivData, rpcClient = _ref3.rpcClient, chainId = _ref3.chainId, wallet = _ref3.wallet, sender = _ref3.sender;
          walletAddress = sender || wallet.account.address;
          mintFees = [];
          i = 0;
        case 1:
          if (!(i < derivData.parentIpIds.length)) {
            _context2.n = 4;
            break;
          }
          _context2.n = 2;
          return calculateLicenseMintFee({
            predictMintingFeeRequest: {
              licensorIpId: derivData.parentIpIds[i],
              licenseTemplate: derivData.licenseTemplate,
              licenseTermsId: derivData.licenseTermsIds[i],
              receiver: walletAddress,
              amount: 1n,
              royaltyContext: viem.zeroAddress
            },
            rpcClient: rpcClient,
            chainId: chainId,
            walletAddress: walletAddress
          });
        case 2:
          mintFee = _context2.v;
          if (mintFee.amount > 0n) {
            mintFees.push(mintFee);
          }
        case 3:
          i++;
          _context2.n = 1;
          break;
        case 4:
          return _context2.a(2, mintFees);
      }
    }, _callee2);
  }));
  return function calculateDerivativeMintingFee(_x2) {
    return _ref4.apply(this, arguments);
  };
}();
var calculateLicenseMintFee = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(_ref5) {
    var predictMintingFeeRequest, rpcClient, chainId, walletAddress, _yield$predictMinting, currencyToken, tokenAmount;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          predictMintingFeeRequest = _ref5.predictMintingFeeRequest, rpcClient = _ref5.rpcClient, chainId = _ref5.chainId, walletAddress = _ref5.walletAddress;
          _context3.n = 1;
          return predictMintingLicenseFee({
            predictMintingFeeRequest: predictMintingFeeRequest,
            rpcClient: rpcClient,
            chainId: chainId,
            walletAddress: walletAddress
          });
        case 1:
          _yield$predictMinting = _context3.v;
          currencyToken = _yield$predictMinting.currencyToken;
          tokenAmount = _yield$predictMinting.tokenAmount;
          return _context3.a(2, {
            token: currencyToken,
            amount: tokenAmount
          });
      }
    }, _callee3);
  }));
  return function calculateLicenseMintFee(_x3) {
    return _ref6.apply(this, arguments);
  };
}();
var calculateSPGMintFee = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(spgNftClient) {
    var token, amount;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          _context4.n = 1;
          return spgNftClient.mintFeeToken();
        case 1:
          token = _context4.v;
          _context4.n = 2;
          return spgNftClient.mintFee();
        case 2:
          amount = _context4.v;
          if (!(amount > 0n)) {
            _context4.n = 3;
            break;
          }
          return _context4.a(2, {
            token: token,
            amount: amount
          });
        case 3:
          return _context4.a(2);
      }
    }, _callee4);
  }));
  return function calculateSPGMintFee(_x4) {
    return _ref7.apply(this, arguments);
  };
}();

var generateOperationSignature = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(_ref) {
    var deadline, ipIdAddress, methodType, ipRoyaltyVault, totalAmount, state, encodeData, wallet, chainId, baseConfig, royaltyTokenDistributionWorkflowsAddr, coreMetadataModuleAddr, licensingModuleAddr, derivativeWorkflowsAddr, licenseAttachmentWorkflowsAddr, registrationWorkflowsAddr, signatureConfigs, signatureRequest, _yield$getSignature, signature, _yield$getPermissionS, _signature;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          deadline = _ref.deadline, ipIdAddress = _ref.ipIdAddress, methodType = _ref.methodType, ipRoyaltyVault = _ref.ipRoyaltyVault, totalAmount = _ref.totalAmount, state = _ref.state, encodeData = _ref.encodeData, wallet = _ref.wallet, chainId = _ref.chainId;
          baseConfig = {
            ipId: ipIdAddress,
            deadline: deadline,
            state: viem.toHex(0, {
              size: 32
            }),
            wallet: wallet,
            chainId: chain[chainId]
          }; // Validate required parameters based on method type
          if (!(methodType === SignatureMethodType.DISTRIBUTE_ROYALTY_TOKENS && (!ipRoyaltyVault || !state || !totalAmount || !encodeData))) {
            _context.n = 1;
            break;
          }
          throw new Error("ipRoyaltyVault, state, totalAmount, and encodeData are required for distributing royalty tokens.");
        case 1:
          if (!(methodType === SignatureMethodType.REGISTER_PIL_TERMS_AND_ATTACH && !state)) {
            _context.n = 2;
            break;
          }
          throw new Error("State is required for registering PIL terms and attaching.");
        case 2:
          if (!(methodType === SignatureMethodType.BATCH_REGISTER_DERIVATIVE && (!state || !encodeData))) {
            _context.n = 3;
            break;
          }
          throw new Error("State and encodeData are required for batch registering derivative.");
        case 3:
          // Get contract addresses for the current chain
          royaltyTokenDistributionWorkflowsAddr = royaltyTokenDistributionWorkflowsAddress[chainId];
          coreMetadataModuleAddr = coreMetadataModuleAddress[chainId];
          licensingModuleAddr = licensingModuleAddress[chainId];
          derivativeWorkflowsAddr = derivativeWorkflowsAddress[chainId];
          licenseAttachmentWorkflowsAddr = licenseAttachmentWorkflowsAddress[chainId];
          registrationWorkflowsAddr = registrationWorkflowsAddress[chainId]; // Define signature configurations for each method type
          signatureConfigs = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, SignatureMethodType.REGISTER_IP_AND_MAKE_DERIVATIVE_AND_DEPLOY_ROYALTY_VAULT, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "registerDerivative")
            }]
          })), SignatureMethodType.DISTRIBUTE_ROYALTY_TOKENS, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            verifyingContract: ipIdAddress,
            deadline: deadline,
            state: state,
            to: ipRoyaltyVault,
            encodeData: encodeData
          })), SignatureMethodType.REGISTER_DERIVATIVE_IP, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: derivativeWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: derivativeWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "registerDerivative")
            }]
          })), SignatureMethodType.REGISTER_IP_AND_ATTACH_PIL_TERMS_AND_DEPLOY_ROYALTY_VAULT, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
            }, {
              ipId: ipIdAddress,
              signer: royaltyTokenDistributionWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
            }]
          })), SignatureMethodType.REGISTER_IP_AND_ATTACH_PIL_TERMS, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
            }, {
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
            }]
          })), SignatureMethodType.REGISTER_IP_AND_MAKE_DERIVATIVE_WITH_LICENSE_TOKENS, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: derivativeWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }, {
              ipId: ipIdAddress,
              signer: derivativeWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "registerDerivativeWithLicenseTokens")
            }]
          })), SignatureMethodType.REGISTER_PIL_TERMS_AND_ATTACH, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            state: state,
            permissions: [{
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "attachLicenseTerms")
            }, {
              ipId: ipIdAddress,
              signer: licenseAttachmentWorkflowsAddr,
              to: licensingModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(licensingModuleAbi, "setLicensingConfig")
            }]
          })), SignatureMethodType.REGISTER, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            permissions: [{
              ipId: ipIdAddress,
              signer: registrationWorkflowsAddr,
              to: coreMetadataModuleAddr,
              permission: AccessPermission.ALLOW,
              func: getFunctionSignature(coreMetadataModuleAbi, "setAll")
            }]
          })), SignatureMethodType.BATCH_REGISTER_DERIVATIVE, _objectSpread2(_objectSpread2({}, baseConfig), {}, {
            state: state,
            to: licensingModuleAddr,
            encodeData: encodeData,
            verifyingContract: ipIdAddress
          })); // Get the appropriate signature configuration for the requested method type
          signatureRequest = signatureConfigs[methodType]; // Generate the appropriate signature type based on the method
          if (!((methodType === SignatureMethodType.DISTRIBUTE_ROYALTY_TOKENS || methodType === SignatureMethodType.BATCH_REGISTER_DERIVATIVE) && signatureRequest)) {
            _context.n = 5;
            break;
          }
          _context.n = 4;
          return getSignature(signatureRequest);
        case 4:
          _yield$getSignature = _context.v;
          signature = _yield$getSignature.signature;
          return _context.a(2, signature);
        case 5:
          _context.n = 6;
          return getPermissionSignature(signatureRequest);
        case 6:
          _yield$getPermissionS = _context.v;
          _signature = _yield$getPermissionS.signature;
          return _context.a(2, _signature);
        case 7:
          return _context.a(2);
      }
    }, _callee);
  }));
  return function generateOperationSignature(_x) {
    return _ref2.apply(this, arguments);
  };
}();

var _PILFlavor;
var PIL_URIS = {
  NCSR: "https://github.com/piplabs/pil-document/blob/998c13e6ee1d04eb817aefd1fe16dfe8be3cd7a2/off-chain-terms/NCSR.json",
  COMMERCIAL_USE: "https://github.com/piplabs/pil-document/blob/9a1f803fcf8101a8a78f1dcc929e6014e144ab56/off-chain-terms/CommercialUse.json",
  COMMERCIAL_REMIX: "https://github.com/piplabs/pil-document/blob/ad67bb632a310d2557f8abcccd428e4c9c798db1/off-chain-terms/CommercialRemix.json",
  CC_BY: "https://github.com/piplabs/pil-document/blob/998c13e6ee1d04eb817aefd1fe16dfe8be3cd7a2/off-chain-terms/CC-BY.json"
};
var COMMON_DEFAULTS = {
  transferable: true,
  royaltyPolicy: viem.zeroAddress,
  defaultMintingFee: 0n,
  expiration: 0n,
  commercializerChecker: viem.zeroAddress,
  commercializerCheckerData: viem.zeroAddress,
  commercialRevShare: 0,
  commercialRevCeiling: 0n,
  derivativeRevCeiling: 0n,
  currency: viem.zeroAddress
};

/**
 * Pre-configured Programmable IP License (PIL) flavors for ease of use.
 *
 * The PIL is highly configurable, but these pre-configured license terms (flavors)
 * are the most popular options that cover common use cases.
 *
 * @see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-flavors | PIL Flavors Documentation}
 *
 * @example
 * ```typescript
 * // Create a commercial use license
 * const commercialLicense = PILFlavor.commercialUse({
 *   defaultMintingFee: 1000000000000000000n, // 1 IP minting fee
 *   currencyToken: "0x1234...", // currency token
 *   royaltyPolicy: "LAP"  // royalty policy
 * });
 *
 * // Create a non-commercial social remixing license
 * const remixLicense = PILFlavor.nonCommercialSocialRemixing();
 * ```
 */
var PILFlavor = /*#__PURE__*/_createClass(function PILFlavor() {
  _classCallCheck(this, PILFlavor);
});
_PILFlavor = PILFlavor;
_defineProperty(PILFlavor, "_nonComSocialRemixingPIL", _objectSpread2(_objectSpread2({}, COMMON_DEFAULTS), {}, {
  commercialUse: false,
  commercialAttribution: false,
  derivativesAllowed: true,
  derivativesAttribution: true,
  derivativesApproval: false,
  derivativesReciprocal: true,
  uri: PIL_URIS.NCSR
}));
_defineProperty(PILFlavor, "_commercialUse", _objectSpread2(_objectSpread2({}, COMMON_DEFAULTS), {}, {
  commercialUse: true,
  commercialAttribution: true,
  derivativesAllowed: false,
  derivativesAttribution: false,
  derivativesApproval: false,
  derivativesReciprocal: false,
  uri: PIL_URIS.COMMERCIAL_USE
}));
_defineProperty(PILFlavor, "_commercialRemix", _objectSpread2(_objectSpread2({}, COMMON_DEFAULTS), {}, {
  commercialUse: true,
  commercialAttribution: true,
  derivativesAllowed: true,
  derivativesAttribution: true,
  derivativesApproval: false,
  derivativesReciprocal: true,
  uri: PIL_URIS.COMMERCIAL_REMIX
}));
_defineProperty(PILFlavor, "_creativeCommonsAttribution", _objectSpread2(_objectSpread2({}, COMMON_DEFAULTS), {}, {
  commercialUse: true,
  commercialAttribution: true,
  derivativesAllowed: true,
  derivativesAttribution: true,
  derivativesApproval: false,
  derivativesReciprocal: true,
  uri: PIL_URIS.CC_BY
}));
/**
 * Gets the values to create a Non-Commercial Social Remixing license terms flavor.
 * @see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-flavors#non-commercial-social-remixing | Non Commercial Social Remixing}
 */
_defineProperty(PILFlavor, "nonCommercialSocialRemixing", function (request) {
  return _PILFlavor.validateLicenseTerms(_objectSpread2(_objectSpread2({}, _PILFlavor._nonComSocialRemixingPIL), request === null || request === void 0 ? void 0 : request.override), request === null || request === void 0 ? void 0 : request.chainId);
});
/**
 * Gets the values to create a Commercial Use license terms flavor.
 * @see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-flavors#commercial-use | Commercial Use}
 */
_defineProperty(PILFlavor, "commercialUse", function (_ref) {
  var defaultMintingFee = _ref.defaultMintingFee,
    currency = _ref.currency,
    royaltyPolicy = _ref.royaltyPolicy,
    chainId = _ref.chainId,
    override = _ref.override;
  return _PILFlavor.validateLicenseTerms(_objectSpread2(_objectSpread2({}, _PILFlavor._commercialUse), {}, {
    defaultMintingFee: defaultMintingFee,
    currency: currency,
    royaltyPolicy: royaltyPolicy
  }, override), chainId);
});
/**
 * Gets the values to create a Commercial Remixing license terms flavor.
 * @see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-flavors#commercial-remix | Commercial Remix}
 */
_defineProperty(PILFlavor, "commercialRemix", function (_ref2) {
  var defaultMintingFee = _ref2.defaultMintingFee,
    royaltyPolicy = _ref2.royaltyPolicy,
    currency = _ref2.currency,
    commercialRevShare = _ref2.commercialRevShare,
    chainId = _ref2.chainId,
    override = _ref2.override;
  return _PILFlavor.validateLicenseTerms(_objectSpread2(_objectSpread2({}, _PILFlavor._commercialRemix), {}, {
    commercialRevShare: commercialRevShare,
    defaultMintingFee: defaultMintingFee,
    currency: currency,
    royaltyPolicy: royaltyPolicy
  }, override), chainId);
});
/**
 * Gets the values to create a Creative Commons Attribution (CC-BY) license terms flavor.
 * @see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-flavors#creative-commons-attribution | Creative Commons Attribution}
 */
_defineProperty(PILFlavor, "creativeCommonsAttribution", function (_ref3) {
  var royaltyPolicy = _ref3.royaltyPolicy,
    currency = _ref3.currency,
    chainId = _ref3.chainId,
    override = _ref3.override;
  return _PILFlavor.validateLicenseTerms(_objectSpread2(_objectSpread2({}, _PILFlavor._creativeCommonsAttribution), {}, {
    currency: currency,
    royaltyPolicy: royaltyPolicy
  }, override), chainId);
});
_defineProperty(PILFlavor, "validateLicenseTerms", function (params, chainId) {
  var normalized = _objectSpread2(_objectSpread2({}, params), {}, {
    defaultMintingFee: BigInt(params.defaultMintingFee),
    expiration: BigInt(params.expiration),
    commercialRevCeiling: BigInt(params.commercialRevCeiling),
    derivativeRevCeiling: BigInt(params.derivativeRevCeiling),
    royaltyPolicy: royaltyPolicyInputToAddress(params.royaltyPolicy, chainId)
  });
  var royaltyPolicy = normalized.royaltyPolicy,
    currency = normalized.currency;

  // Validate royalty policy and currency relationship
  if (royaltyPolicy !== viem.zeroAddress && currency === viem.zeroAddress) {
    throw new PILFlavorError("Royalty policy requires currency token.");
  }

  // Validate defaultMintingFee
  if (normalized.defaultMintingFee < 0n) {
    throw new PILFlavorError("DefaultMintingFee should be greater than or equal to 0.");
  }
  if (normalized.defaultMintingFee > 0n && normalized.royaltyPolicy === viem.zeroAddress) {
    throw new PILFlavorError("Royalty policy is required when defaultMintingFee is greater than 0.");
  }

  // Validate commercial use and derivatives
  _PILFlavor.verifyCommercialUse(normalized);
  _PILFlavor.verifyDerivatives(normalized);
  if (normalized.commercialRevShare > 100 || normalized.commercialRevShare < 0) {
    throw new PILFlavorError("commercialRevShare must be between 0 and 100.");
  }
  return normalized;
});
_defineProperty(PILFlavor, "verifyCommercialUse", function (terms) {
  if (!terms.commercialUse) {
    var commercialFields = [{
      field: "commercialAttribution",
      value: terms.commercialAttribution
    }, {
      field: "commercializerChecker",
      value: terms.commercializerChecker !== viem.zeroAddress
    }, {
      field: "commercialRevShare",
      value: terms.commercialRevShare > 0
    }, {
      field: "commercialRevCeiling",
      value: terms.commercialRevCeiling > 0n
    }, {
      field: "derivativeRevCeiling",
      value: terms.derivativeRevCeiling > 0n
    }, {
      field: "royaltyPolicy",
      value: terms.royaltyPolicy !== viem.zeroAddress
    }];
    for (var _i = 0, _commercialFields = commercialFields; _i < _commercialFields.length; _i++) {
      var _commercialFields$_i = _commercialFields[_i],
        field = _commercialFields$_i.field,
        value = _commercialFields$_i.value;
      if (value) {
        throw new PILFlavorError("Cannot add ".concat(field, " when commercial use is disabled."));
      }
    }
  } else {
    if (terms.royaltyPolicy === viem.zeroAddress) {
      throw new PILFlavorError("Royalty policy is required when commercial use is enabled.");
    }
  }
});
_defineProperty(PILFlavor, "verifyDerivatives", function (terms) {
  if (!terms.derivativesAllowed) {
    var derivativeFields = [{
      field: "derivativesAttribution",
      value: terms.derivativesAttribution
    }, {
      field: "derivativesApproval",
      value: terms.derivativesApproval
    }, {
      field: "derivativesReciprocal",
      value: terms.derivativesReciprocal
    }, {
      field: "derivativeRevCeiling",
      value: terms.derivativeRevCeiling > 0n
    }];
    for (var _i2 = 0, _derivativeFields = derivativeFields; _i2 < _derivativeFields.length; _i2++) {
      var _derivativeFields$_i = _derivativeFields[_i2],
        field = _derivativeFields$_i.field,
        value = _derivativeFields$_i.value;
      if (value) {
        throw new PILFlavorError("Cannot add ".concat(field, " when derivative use is disabled."));
      }
    }
  }
});

function _regeneratorValues(e) {
  if (null != e) {
    var t = e["function" == typeof Symbol && Symbol.iterator || "@@iterator"],
      r = 0;
    if (t) return t.call(e);
    if ("function" == typeof e.next) return e;
    if (!isNaN(e.length)) return {
      next: function () {
        return e && r >= e.length && (e = void 0), {
          value: e && e[r++],
          done: !e
        };
      }
    };
  }
  throw new TypeError(typeof e + " is not iterable");
}

function _regeneratorKeys(e) {
  var n = Object(e),
    r = [];
  for (var t in n) r.unshift(t);
  return function e() {
    for (; r.length;) if ((t = r.pop()) in n) return e.value = t, e.done = false, e;
    return e.done = true, e;
  };
}

var getPublicMinting = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(spgNftContract, rpcClient) {
    var spgNftContractImpl;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          spgNftContractImpl = new SpgnftImplReadOnlyClient(rpcClient, spgNftContract);
          _context.n = 1;
          return spgNftContractImpl.publicMinting();
        case 1:
          return _context.a(2, _context.v);
      }
    }, _callee);
  }));
  return function getPublicMinting(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var validateLicenseTermsData = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(licenseTermsData, rpcClient, chainId) {
    var licenseTerms, processedLicenseTermsData, maxLicenseTokens, i, licenseTerm, royaltyModuleReadOnlyClient, isWhitelistedArbitrationPolicy, isWhitelistedRoyaltyToken, licensingConfig, maxLicenseTokensValue;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          licenseTerms = [];
          processedLicenseTermsData = [];
          maxLicenseTokens = [];
          i = 0;
        case 1:
          if (!(i < licenseTermsData.length)) {
            _context2.n = 10;
            break;
          }
          licenseTerm = PILFlavor.validateLicenseTerms(licenseTermsData[i].terms, chainId);
          licenseTerm.commercialRevShare = getRevenueShare(licenseTerm.commercialRevShare);
          royaltyModuleReadOnlyClient = new RoyaltyModuleReadOnlyClient(rpcClient);
          if (!(validateAddress(licenseTerm.royaltyPolicy) !== viem.zeroAddress)) {
            _context2.n = 3;
            break;
          }
          _context2.n = 2;
          return royaltyModuleReadOnlyClient.isWhitelistedRoyaltyPolicy({
            royaltyPolicy: licenseTerm.royaltyPolicy
          });
        case 2:
          isWhitelistedArbitrationPolicy = _context2.v;
          if (isWhitelistedArbitrationPolicy) {
            _context2.n = 3;
            break;
          }
          throw new Error("The royalty policy ".concat(licenseTerm.royaltyPolicy, " is not whitelisted."));
        case 3:
          if (!(validateAddress(licenseTerm.currency) !== viem.zeroAddress)) {
            _context2.n = 5;
            break;
          }
          _context2.n = 4;
          return royaltyModuleReadOnlyClient.isWhitelistedRoyaltyToken({
            token: licenseTerm.currency
          });
        case 4:
          isWhitelistedRoyaltyToken = _context2.v;
          if (isWhitelistedRoyaltyToken) {
            _context2.n = 5;
            break;
          }
          throw new Error("The currency token ".concat(licenseTerm.currency, " is not whitelisted."));
        case 5:
          licensingConfig = validateLicenseConfig(licenseTermsData[i].licensingConfig);
          if (!(licensingConfig.mintingFee > 0 && licenseTerm.royaltyPolicy === viem.zeroAddress)) {
            _context2.n = 6;
            break;
          }
          throw new Error("A royalty policy must be provided when the minting fee is greater than 0.");
        case 6:
          maxLicenseTokensValue = licenseTermsData[i].maxLicenseTokens;
          if (!(maxLicenseTokensValue !== undefined)) {
            _context2.n = 8;
            break;
          }
          if (!(maxLicenseTokensValue < 0)) {
            _context2.n = 7;
            break;
          }
          throw new Error("The max license tokens must be greater than or equal to 0.");
        case 7:
          licensingConfig.licensingHook = totalLicenseTokenLimitHookAddress[chainId];
          maxLicenseTokens[i] = BigInt(maxLicenseTokensValue);
        case 8:
          licenseTerms.push(licenseTerm);
          processedLicenseTermsData.push({
            terms: licenseTerm,
            licensingConfig: licensingConfig
          });
        case 9:
          i++;
          _context2.n = 1;
          break;
        case 10:
          return _context2.a(2, {
            licenseTerms: licenseTerms,
            licenseTermsData: processedLicenseTermsData,
            maxLicenseTokens: maxLicenseTokens
          });
      }
    }, _callee2);
  }));
  return function validateLicenseTermsData(_x3, _x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}();
var getRoyaltyShares = function getRoyaltyShares(royaltyShares) {
  var actualTotal = 0;
  var sum = 0;
  var shares = royaltyShares.map(function (share) {
    if (share.percentage <= 0) {
      throw new Error("The percentage of the royalty shares must be greater than 0.");
    }
    if (share.percentage > 100) {
      throw new Error("The percentage of the royalty shares must be less than or equal to 100.");
    }
    sum += share.percentage;
    if (sum > 100) {
      throw new Error("The sum of the royalty shares cannot exceeds 100.");
    }
    // use Math.trunc to avoid precision issues
    var value = Math.trunc(share.percentage * Math.pow(10, 6));
    actualTotal += value;
    return _objectSpread2(_objectSpread2({}, share), {}, {
      percentage: value
    });
  });
  // use Math.trunc to avoid precision issues
  return {
    royaltyShares: shares,
    totalAmount: Math.trunc(actualTotal)
  };
};
var validateDerivativeData = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(_ref3) {
    var _derivativeDataInput$, _derivativeDataInput$2;
    var derivativeDataInput, rpcClient, wallet, chainId, licenseTemplateAddress, ipAssetRegistryClient, licenseRegistryReadOnlyClient, derivativeData, i, parentId, isParentIpRegistered, isAttachedLicenseTerms, _yield$licenseRegistr, royaltyPercent;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          derivativeDataInput = _ref3.derivativeDataInput, rpcClient = _ref3.rpcClient, wallet = _ref3.wallet, chainId = _ref3.chainId;
          licenseTemplateAddress = piLicenseTemplateAddress[chainId];
          ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
          licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
          derivativeData = {
            parentIpIds: derivativeDataInput.parentIpIds,
            licenseTermsIds: derivativeDataInput.licenseTermsIds.map(function (id) {
              return BigInt(id);
            }),
            licenseTemplate: validateAddress(derivativeDataInput.licenseTemplate || licenseTemplateAddress),
            royaltyContext: viem.zeroAddress,
            maxMintingFee: BigInt((_derivativeDataInput$ = derivativeDataInput.maxMintingFee) !== null && _derivativeDataInput$ !== void 0 ? _derivativeDataInput$ : 0),
            maxRts: validateMaxRts(derivativeDataInput.maxRts),
            maxRevenueShare: getRevenueShare((_derivativeDataInput$2 = derivativeDataInput.maxRevenueShare) !== null && _derivativeDataInput$2 !== void 0 ? _derivativeDataInput$2 : 100, RevShareType.MAX_REVENUE_SHARE)
          };
          if (!(derivativeData.parentIpIds.length === 0)) {
            _context3.n = 1;
            break;
          }
          throw new Error("The parent IP IDs must be provided.");
        case 1:
          if (!(derivativeData.licenseTermsIds.length === 0)) {
            _context3.n = 2;
            break;
          }
          throw new Error("The license terms IDs must be provided.");
        case 2:
          if (!(derivativeData.parentIpIds.length !== derivativeData.licenseTermsIds.length)) {
            _context3.n = 3;
            break;
          }
          throw new Error("The number of parent IP IDs must match the number of license terms IDs.");
        case 3:
          if (!(derivativeData.maxMintingFee < 0)) {
            _context3.n = 4;
            break;
          }
          throw new Error("The maxMintingFee must be greater than 0.");
        case 4:
          i = 0;
        case 5:
          if (!(i < derivativeData.parentIpIds.length)) {
            _context3.n = 12;
            break;
          }
          parentId = derivativeData.parentIpIds[i];
          _context3.n = 6;
          return ipAssetRegistryClient.isRegistered({
            id: validateAddress(parentId)
          });
        case 6:
          isParentIpRegistered = _context3.v;
          if (isParentIpRegistered) {
            _context3.n = 7;
            break;
          }
          throw new Error("The parent IP with id ".concat(parentId, " is not registered."));
        case 7:
          _context3.n = 8;
          return licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
            ipId: parentId,
            licenseTemplate: derivativeData.licenseTemplate,
            licenseTermsId: derivativeData.licenseTermsIds[i]
          });
        case 8:
          isAttachedLicenseTerms = _context3.v;
          if (isAttachedLicenseTerms) {
            _context3.n = 9;
            break;
          }
          throw new Error("License terms id ".concat(derivativeData.licenseTermsIds[i], " must be attached to the parent ipId ").concat(derivativeData.parentIpIds[i], " before registering derivative."));
        case 9:
          _context3.n = 10;
          return licenseRegistryReadOnlyClient.getRoyaltyPercent({
            ipId: parentId,
            licenseTemplate: derivativeData.licenseTemplate,
            licenseTermsId: derivativeData.licenseTermsIds[i]
          });
        case 10:
          _yield$licenseRegistr = _context3.v;
          royaltyPercent = _yield$licenseRegistr.royaltyPercent;
          if (!(derivativeData.maxRevenueShare !== 0 && royaltyPercent > derivativeData.maxRevenueShare)) {
            _context3.n = 11;
            break;
          }
          throw new Error("The royalty percent for the parent IP with id ".concat(parentId, " is greater than the maximum revenue share ").concat(derivativeData.maxRevenueShare, "."));
        case 11:
          i++;
          _context3.n = 5;
          break;
        case 12:
          return _context3.a(2, derivativeData);
      }
    }, _callee3);
  }));
  return function validateDerivativeData(_x6) {
    return _ref4.apply(this, arguments);
  };
}();
var validateMaxRts = function validateMaxRts(maxRts) {
  if (maxRts === undefined) {
    return MAX_ROYALTY_TOKEN;
  } else if (maxRts < 0 || maxRts > MAX_ROYALTY_TOKEN) {
    throw new Error("The maxRts must be greater than 0 and less than ".concat(MAX_ROYALTY_TOKEN, "."));
  }
  return maxRts;
};
var getIpIdAddress = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref5) {
    var nftContract, tokenId, rpcClient, wallet, chainId, ipAssetRegistryClient, ipId;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          nftContract = _ref5.nftContract, tokenId = _ref5.tokenId, rpcClient = _ref5.rpcClient, wallet = _ref5.wallet, chainId = _ref5.chainId;
          ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
          _context4.n = 1;
          return ipAssetRegistryClient.ipId({
            chainId: BigInt(chain[chainId]),
            tokenContract: validateAddress(nftContract),
            tokenId: BigInt(tokenId)
          });
        case 1:
          ipId = _context4.v;
          return _context4.a(2, ipId);
      }
    }, _callee4);
  }));
  return function getIpIdAddress(_x7) {
    return _ref6.apply(this, arguments);
  };
}();
var getCalculatedDeadline = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(rpcClient, requestDeadline) {
    var blockTimestamp;
    return _regenerator().w(function (_context5) {
      while (1) switch (_context5.n) {
        case 0:
          _context5.n = 1;
          return rpcClient.getBlock();
        case 1:
          blockTimestamp = _context5.v.timestamp;
          return _context5.a(2, getDeadline(blockTimestamp, requestDeadline));
      }
    }, _callee5);
  }));
  return function getCalculatedDeadline(_x8, _x9) {
    return _ref7.apply(this, arguments);
  };
}();
var mergeSpenders = function mergeSpenders(previousSpenders, newSpenders) {
  if (!newSpenders || newSpenders.length === 0) {
    return previousSpenders;
  }
  return newSpenders.reduce(function (acc, spender) {
    if (!spender || !spender.address) {
      return acc;
    }
    var existingSpender = acc.find(function (s) {
      return s.address === spender.address && s.token === spender.token;
    });
    if (!existingSpender) {
      acc.push(_objectSpread2(_objectSpread2({}, spender), {}, {
        amount: spender.amount || 0n
      }));
    } else {
      existingSpender.amount = (existingSpender.amount || 0n) + (spender.amount || 0n);
    }
    return acc;
  }, _toConsumableArray(previousSpenders));
};
var hasMinterRole = /*#__PURE__*/function () {
  var _ref8 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(spgNftContract, rpcClient, walletAddress) {
    var spgNftContractImpl, minterRole;
    return _regenerator().w(function (_context6) {
      while (1) switch (_context6.n) {
        case 0:
          spgNftContractImpl = new SpgnftImplReadOnlyClient(rpcClient, spgNftContract);
          minterRole = viem.toHex(1, {
            size: 32
          });
          _context6.n = 1;
          return spgNftContractImpl.hasRole({
            role: minterRole,
            account: walletAddress
          });
        case 1:
          return _context6.a(2, _context6.v);
      }
    }, _callee6);
  }));
  return function hasMinterRole(_x0, _x1, _x10) {
    return _ref8.apply(this, arguments);
  };
}();

/**
 * Aggregates the registration requests for the given workflow responses.
 *
 * This function combines multiple workflow responses into a consolidated request structure,
 * aggregating:
 * - Token spenders and their allowances
 * - Total fees required for all operations
 * - Encoded transaction data
 * - Contract calls to be executed
 *
 * @remarks
 * The function handles two execution modes:
 * 1. If `disableMulticallWhenPossible` is true or a workflow response supports multicall3
 *    (indicated by `isUseMulticall3`), individual contract calls are added to the `contractCall` array.
 * 2. Otherwise, it concatenates all `encodedTxData` and passes them as parameters to the
 *    workflowClient's `multicall` method, optimizing gas usage by batching transactions.
 *
 * This approach allows for flexible transaction handling based on contract capabilities
 * and user preferences.
 */
var aggregateTransformIpRegistrationWorkflow = function aggregateTransformIpRegistrationWorkflow(transferWorkflowRequests, multicall3Address, disableMulticallWhenPossible) {
  var aggregateRegistrationRequest = {};
  var _iterator = _createForOfIteratorHelper(transferWorkflowRequests),
    _step;
  try {
    var _loop = function _loop() {
      var _currentRequest$extra;
      var res = _step.value;
      var spenders = res.spenders,
        encodedTxData = res.encodedTxData,
        workflowClient = res.workflowClient,
        isUseMulticall3 = res.isUseMulticall3,
        extraData = res.extraData;
      var shouldUseMulticall = isUseMulticall3;
      if (disableMulticallWhenPossible) {
        shouldUseMulticall = false;
      }
      var targetAddress = shouldUseMulticall ? multicall3Address : workflowClient.address;
      if (!aggregateRegistrationRequest[targetAddress]) {
        aggregateRegistrationRequest[targetAddress] = {
          spenders: [],
          encodedTxData: [],
          contractCall: [],
          extraData: []
        };
      }
      var currentRequest = aggregateRegistrationRequest[targetAddress];
      currentRequest.spenders = mergeSpenders(currentRequest.spenders, spenders || []);
      currentRequest.encodedTxData = currentRequest.encodedTxData.concat(encodedTxData);
      currentRequest.extraData = (_currentRequest$extra = currentRequest.extraData) === null || _currentRequest$extra === void 0 ? void 0 : _currentRequest$extra.concat(extraData || undefined);
      if (isUseMulticall3 || disableMulticallWhenPossible) {
        currentRequest.contractCall = currentRequest.contractCall.concat(res.contractCall);
      } else {
        currentRequest.contractCall = [function () {
          return workflowClient.multicall({
            data: currentRequest.encodedTxData.map(function (tx) {
              return tx.data;
            })
          });
        }];
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return aggregateRegistrationRequest;
};
var handleMulticall = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(_ref) {
    var _options$wipOptions;
    var transferWorkflowRequests, multicall3Address, options, rpcClient, wallet, walletAddress, aggregateRegistrationRequest, txResponses, _loop2, key, _t2, _t3;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          transferWorkflowRequests = _ref.transferWorkflowRequests, multicall3Address = _ref.multicall3Address, options = _ref.options, rpcClient = _ref.rpcClient, wallet = _ref.wallet, walletAddress = _ref.walletAddress;
          aggregateRegistrationRequest = aggregateTransformIpRegistrationWorkflow(transferWorkflowRequests, multicall3Address, (options === null || options === void 0 || (_options$wipOptions = options.wipOptions) === null || _options$wipOptions === void 0 ? void 0 : _options$wipOptions.useMulticallWhenPossible) === false);
          txResponses = [];
          _loop2 = /*#__PURE__*/_regenerator().m(function _loop2() {
            var _aggregateRegistratio, spenders, encodedTxData, contractCall, contractCalls, useMulticallWhenPossible, txResponse;
            return _regenerator().w(function (_context2) {
              while (1) switch (_context2.n) {
                case 0:
                  _aggregateRegistratio = aggregateRegistrationRequest[key], spenders = _aggregateRegistratio.spenders, encodedTxData = _aggregateRegistratio.encodedTxData, contractCall = _aggregateRegistratio.contractCall;
                  contractCalls = /*#__PURE__*/function () {
                    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
                      var txHashes, _iterator2, _step2, call, txHash, _t;
                      return _regenerator().w(function (_context) {
                        while (1) switch (_context.p = _context.n) {
                          case 0:
                            txHashes = [];
                            _iterator2 = _createForOfIteratorHelper(contractCall);
                            _context.p = 1;
                            _iterator2.s();
                          case 2:
                            if ((_step2 = _iterator2.n()).done) {
                              _context.n = 5;
                              break;
                            }
                            call = _step2.value;
                            _context.n = 3;
                            return call();
                          case 3:
                            txHash = _context.v;
                            txHashes.push(txHash);
                          case 4:
                            _context.n = 2;
                            break;
                          case 5:
                            _context.n = 7;
                            break;
                          case 6:
                            _context.p = 6;
                            _t = _context.v;
                            _iterator2.e(_t);
                          case 7:
                            _context.p = 7;
                            _iterator2.f();
                            return _context.f(7);
                          case 8:
                            return _context.a(2, txHashes);
                        }
                      }, _callee, null, [[1, 6, 7, 8]]);
                    }));
                    return function contractCalls() {
                      return _ref3.apply(this, arguments);
                    };
                  }();
                  useMulticallWhenPossible = key === multicall3Address ? true : false;
                  _context2.n = 1;
                  return contractCallWithFees({
                    options: _objectSpread2(_objectSpread2({}, options), {}, {
                      wipOptions: _objectSpread2(_objectSpread2({}, options === null || options === void 0 ? void 0 : options.wipOptions), {}, {
                        useMulticallWhenPossible: useMulticallWhenPossible
                      })
                    }),
                    multicall3Address: multicall3Address,
                    rpcClient: rpcClient,
                    tokenSpenders: spenders,
                    contractCall: contractCalls,
                    sender: walletAddress,
                    wallet: wallet,
                    encodedTxs: encodedTxData
                  });
                case 1:
                  txResponse = _context2.v;
                  txResponses.push.apply(txResponses, _toConsumableArray(Array.isArray(txResponse) ? txResponse : [txResponse]));
                case 2:
                  return _context2.a(2);
              }
            }, _loop2);
          });
          _t2 = _regeneratorKeys(aggregateRegistrationRequest);
        case 1:
          if ((_t3 = _t2()).done) {
            _context3.n = 3;
            break;
          }
          key = _t3.value;
          return _context3.d(_regeneratorValues(_loop2()), 2);
        case 2:
          _context3.n = 1;
          break;
        case 3:
          return _context3.a(2, {
            response: txResponses,
            aggregateRegistrationRequest: aggregateRegistrationRequest
          });
      }
    }, _callee2);
  }));
  return function handleMulticall(_x) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * Transforms the registration request to the appropriate format based on workflow type.
 *
 * @remarks
 * This utility function serves as the entry point for processing both `register*` and
 * `mintAndRegister*` workflows. It analyzes the request structure and routes it to the
 * appropriate handler:
 *
 * - For minting + registration workflows (containing `spgNftContract`): Routes to `handleMintAndRegisterRequest`
 * - For registration-only workflows (containing `nftContract` and `tokenId`): Routes to `handleRegisterRequest`
 *
 * Each handler then applies the necessary transformations, validates inputs, calculates fees,
 * generates required signatures, and prepares the transaction data for submission.
 *
 * @throws Error if the request doesn't match any supported workflow pattern
 */

var transformRegistrationRequest = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(_ref) {
    var request, rpcClient, wallet, chainId;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          request = _ref.request, rpcClient = _ref.rpcClient, wallet = _ref.wallet, chainId = _ref.chainId;
          if (!("spgNftContract" in request)) {
            _context.n = 1;
            break;
          }
          return _context.a(2, handleMintAndRegisterRequest({
            request: request,
            rpcClient: rpcClient,
            wallet: wallet,
            chainId: chainId
          }));
        case 1:
          if (!("nftContract" in request && "tokenId" in request)) {
            _context.n = 2;
            break;
          }
          return _context.a(2, handleRegisterRequest({
            request: request,
            rpcClient: rpcClient,
            wallet: wallet,
            chainId: chainId
          }));
        case 2:
          throw new Error("Invalid registration request type");
        case 3:
          return _context.a(2);
      }
    }, _callee);
  }));
  return function transformRegistrationRequest(_x) {
    return _ref2.apply(this, arguments);
  };
}();

/**
 * Handles a request for the `register*` contract methods.
 *
 * @remarks
 * This method processes various IP registration workflows including:
 *
 * - {@link registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens} - Registers derivative IP with license terms and royalty distribution
 * - {@link registerIpAndAttachPilTerms} - Registers IP and attaches PIL (Programmable IP License) terms
 * - {@link registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens} - Registers IP with license terms and royalty distribution
 * - {@link registerDerivativeIp} - Registers a derivative work based on existing IP
 * - {@link registerIpAndMakeDerivativeAndDeployRoyaltyVault} - Registers IP, creates derivative, and deploys royalty vault
 *
 * Key features:
 * - Automatically calculates all required license fees
 * - Generates appropriate operation signatures based on workflow type using EIP-712
 * - Does not support `multicall3` integration because the signature signer must be the transaction caller
 * - Uses SPG's native transaction handling for multicall
 * - Validates all input parameters
 */
var handleRegisterRequest = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(_ref3) {
    var request, rpcClient, wallet, chainId, ipIdAddress, baseRequest, calculatedDeadline, royaltyTokenDistributionWorkflowsClient, licenseAttachmentWorkflowsClient, derivativeWorkflowsClient, _yield$validateLicens, licenseTermsData, maxLicenseTokens, requestWithTerms, derivData, derivativeMintingFee;
    return _regenerator().w(function (_context2) {
      while (1) switch (_context2.n) {
        case 0:
          request = _ref3.request, rpcClient = _ref3.rpcClient, wallet = _ref3.wallet, chainId = _ref3.chainId;
          _context2.n = 1;
          return getIpIdAddress({
            nftContract: validateAddress(request.nftContract),
            tokenId: BigInt(request.tokenId),
            rpcClient: rpcClient,
            wallet: wallet,
            chainId: chainId
          });
        case 1:
          ipIdAddress = _context2.v;
          baseRequest = {
            nftContract: validateAddress(request.nftContract),
            tokenId: BigInt(request.tokenId),
            ipMetadata: getIpMetadataForWorkflow(request.ipMetadata)
          };
          _context2.n = 2;
          return getCalculatedDeadline(rpcClient, request.deadline);
        case 2:
          calculatedDeadline = _context2.v;
          royaltyTokenDistributionWorkflowsClient = new RoyaltyTokenDistributionWorkflowsClient(rpcClient, wallet);
          licenseAttachmentWorkflowsClient = new LicenseAttachmentWorkflowsClient(rpcClient, wallet);
          derivativeWorkflowsClient = new DerivativeWorkflowsClient(rpcClient, wallet);
          if (!("licenseTermsData" in request)) {
            _context2.n = 7;
            break;
          }
          _context2.n = 3;
          return validateLicenseTermsData(request.licenseTermsData, rpcClient, chainId);
        case 3:
          _yield$validateLicens = _context2.v;
          licenseTermsData = _yield$validateLicens.licenseTermsData;
          maxLicenseTokens = _yield$validateLicens.maxLicenseTokens;
          requestWithTerms = _objectSpread2(_objectSpread2({}, baseRequest), {}, {
            licenseTermsData: licenseTermsData
          });
          if (!("royaltyShares" in request)) {
            _context2.n = 5;
            break;
          }
          _context2.n = 4;
          return transferRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest({
            request: requestWithTerms,
            royaltyTokenDistributionWorkflowsClient: royaltyTokenDistributionWorkflowsClient,
            chainId: chainId,
            wallet: wallet,
            calculatedDeadline: calculatedDeadline,
            ipIdAddress: ipIdAddress,
            royaltyShares: request.royaltyShares,
            maxLicenseTokens: maxLicenseTokens
          });
        case 4:
          return _context2.a(2, _context2.v);
        case 5:
          _context2.n = 6;
          return transferRegisterIpAndAttachPilTermsRequest({
            request: requestWithTerms,
            licenseAttachmentWorkflowsClient: licenseAttachmentWorkflowsClient,
            calculatedDeadline: calculatedDeadline,
            ipIdAddress: ipIdAddress,
            wallet: wallet,
            chainId: chainId,
            maxLicenseTokens: maxLicenseTokens
          });
        case 6:
          return _context2.a(2, _context2.v);
        case 7:
          if (!("derivData" in request)) {
            _context2.n = 13;
            break;
          }
          _context2.n = 8;
          return validateDerivativeData({
            derivativeDataInput: request.derivData,
            rpcClient: rpcClient,
            chainId: chainId,
            wallet: wallet
          });
        case 8:
          derivData = _context2.v;
          _context2.n = 9;
          return calculateDerivativeMintingFee({
            derivData: derivData,
            rpcClient: rpcClient,
            chainId: chainId,
            wallet: wallet
          });
        case 9:
          derivativeMintingFee = _context2.v;
          if (!("royaltyShares" in request)) {
            _context2.n = 11;
            break;
          }
          _context2.n = 10;
          return transferRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest({
            request: _objectSpread2(_objectSpread2({}, baseRequest), {}, {
              derivData: derivData
            }),
            calculatedDeadline: calculatedDeadline,
            ipIdAddress: ipIdAddress,
            wallet: wallet,
            chainId: chainId,
            royaltyTokenDistributionWorkflowsClient: royaltyTokenDistributionWorkflowsClient,
            derivativeMintingFee: derivativeMintingFee,
            royaltyShares: request.royaltyShares
          });
        case 10:
          return _context2.a(2, _context2.v);
        case 11:
          _context2.n = 12;
          return transferRegisterDerivativeIpRequest({
            request: _objectSpread2(_objectSpread2({}, baseRequest), {}, {
              derivData: derivData
            }),
            calculatedDeadline: calculatedDeadline,
            ipIdAddress: ipIdAddress,
            wallet: wallet,
            chainId: chainId,
            derivativeWorkflowsClient: derivativeWorkflowsClient,
            derivativeMintingFee: derivativeMintingFee
          });
        case 12:
          return _context2.a(2, _context2.v);
        case 13:
          throw new Error("Invalid register request type");
        case 14:
          return _context2.a(2);
      }
    }, _callee2);
  }));
  return function handleRegisterRequest(_x2) {
    return _ref4.apply(this, arguments);
  };
}();

/**
 * Transforms a request for the `registerDerivativeIp` contract method.
 */
var transferRegisterDerivativeIpRequest = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(_ref5) {
    var request, calculatedDeadline, ipIdAddress, wallet, chainId, derivativeWorkflowsClient, derivativeMintingFee, signature, transformRequest, spenders;
    return _regenerator().w(function (_context3) {
      while (1) switch (_context3.n) {
        case 0:
          request = _ref5.request, calculatedDeadline = _ref5.calculatedDeadline, ipIdAddress = _ref5.ipIdAddress, wallet = _ref5.wallet, chainId = _ref5.chainId, derivativeWorkflowsClient = _ref5.derivativeWorkflowsClient, derivativeMintingFee = _ref5.derivativeMintingFee;
          _context3.n = 1;
          return generateOperationSignature({
            ipIdAddress: ipIdAddress,
            methodType: SignatureMethodType.REGISTER_DERIVATIVE_IP,
            deadline: calculatedDeadline,
            wallet: wallet,
            chainId: chainId
          });
        case 1:
          signature = _context3.v;
          transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
            sigMetadataAndRegister: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signature
            }
          });
          spenders = derivativeMintingFee.map(function (fee) {
            return _objectSpread2({
              address: derivativeWorkflowsClient.address
            }, fee);
          });
          return _context3.a(2, {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            spenders: spenders,
            contractCall: function contractCall() {
              return derivativeWorkflowsClient.registerIpAndMakeDerivative(transformRequest);
            },
            workflowClient: derivativeWorkflowsClient,
            encodedTxData: {
              to: derivativeWorkflowsClient.address,
              data: viem.encodeFunctionData({
                abi: derivativeWorkflowsAbi,
                functionName: "registerIpAndMakeDerivative",
                args: [transformRequest.nftContract, transformRequest.tokenId, transformRequest.derivData, transformRequest.ipMetadata, transformRequest.sigMetadataAndRegister]
              })
            }
          });
      }
    }, _callee3);
  }));
  return function transferRegisterDerivativeIpRequest(_x3) {
    return _ref6.apply(this, arguments);
  };
}();

/**
 * Transforms a request for the `registerIpAndAttachPilTermsAndDeployRoyaltyVault` contract method.
 */
var transferRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest = /*#__PURE__*/function () {
  var _ref8 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref7) {
    var request, royaltyTokenDistributionWorkflowsClient, chainId, wallet, calculatedDeadline, ipIdAddress, royaltyShares, maxLicenseTokens, signature, transformRequest;
    return _regenerator().w(function (_context4) {
      while (1) switch (_context4.n) {
        case 0:
          request = _ref7.request, royaltyTokenDistributionWorkflowsClient = _ref7.royaltyTokenDistributionWorkflowsClient, chainId = _ref7.chainId, wallet = _ref7.wallet, calculatedDeadline = _ref7.calculatedDeadline, ipIdAddress = _ref7.ipIdAddress, royaltyShares = _ref7.royaltyShares, maxLicenseTokens = _ref7.maxLicenseTokens;
          _context4.n = 1;
          return generateOperationSignature({
            ipIdAddress: ipIdAddress,
            methodType: SignatureMethodType.REGISTER_IP_AND_ATTACH_PIL_TERMS_AND_DEPLOY_ROYALTY_VAULT,
            deadline: calculatedDeadline,
            wallet: wallet,
            chainId: chainId
          });
        case 1:
          signature = _context4.v;
          transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
            sigMetadataAndAttachAndConfig: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signature
            }
          });
          return _context4.a(2, {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            contractCall: function contractCall() {
              return royaltyTokenDistributionWorkflowsClient.registerIpAndAttachPilTermsAndDeployRoyaltyVault(transformRequest);
            },
            workflowClient: royaltyTokenDistributionWorkflowsClient,
            encodedTxData: {
              to: royaltyTokenDistributionWorkflowsClient.address,
              data: viem.encodeFunctionData({
                abi: royaltyTokenDistributionWorkflowsAbi,
                functionName: "registerIpAndAttachPILTermsAndDeployRoyaltyVault",
                args: [transformRequest.nftContract, transformRequest.tokenId, transformRequest.ipMetadata, transformRequest.licenseTermsData, transformRequest.sigMetadataAndAttachAndConfig]
              })
            },
            extraData: {
              royaltyShares: royaltyShares,
              deadline: calculatedDeadline,
              maxLicenseTokens: maxLicenseTokens,
              licenseTermsData: request.licenseTermsData
            }
          });
      }
    }, _callee4);
  }));
  return function transferRegisterIpAndAttachPilTermsAndDeployRoyaltyVaultRequest(_x4) {
    return _ref8.apply(this, arguments);
  };
}();

/**
 * Transforms a request for the `registerIpAndAttachPilTerms` contract method.
 */
var transferRegisterIpAndAttachPilTermsRequest = /*#__PURE__*/function () {
  var _ref0 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(_ref9) {
    var request, licenseAttachmentWorkflowsClient, calculatedDeadline, ipIdAddress, wallet, chainId, maxLicenseTokens, signature, transformRequest;
    return _regenerator().w(function (_context5) {
      while (1) switch (_context5.n) {
        case 0:
          request = _ref9.request, licenseAttachmentWorkflowsClient = _ref9.licenseAttachmentWorkflowsClient, calculatedDeadline = _ref9.calculatedDeadline, ipIdAddress = _ref9.ipIdAddress, wallet = _ref9.wallet, chainId = _ref9.chainId, maxLicenseTokens = _ref9.maxLicenseTokens;
          _context5.n = 1;
          return generateOperationSignature({
            ipIdAddress: ipIdAddress,
            methodType: SignatureMethodType.REGISTER_IP_AND_ATTACH_PIL_TERMS,
            deadline: calculatedDeadline,
            wallet: wallet,
            chainId: chainId
          });
        case 1:
          signature = _context5.v;
          transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
            sigMetadataAndAttachAndConfig: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signature
            }
          });
          return _context5.a(2, {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            contractCall: function contractCall() {
              return licenseAttachmentWorkflowsClient.registerIpAndAttachPilTerms(transformRequest);
            },
            workflowClient: licenseAttachmentWorkflowsClient,
            encodedTxData: {
              to: licenseAttachmentWorkflowsClient.address,
              data: viem.encodeFunctionData({
                abi: licenseAttachmentWorkflowsAbi,
                functionName: "registerIpAndAttachPILTerms",
                args: [transformRequest.nftContract, transformRequest.tokenId, transformRequest.ipMetadata, transformRequest.licenseTermsData, transformRequest.sigMetadataAndAttachAndConfig]
              })
            },
            extraData: {
              maxLicenseTokens: maxLicenseTokens,
              licenseTermsData: request.licenseTermsData
            }
          });
      }
    }, _callee5);
  }));
  return function transferRegisterIpAndAttachPilTermsRequest(_x5) {
    return _ref0.apply(this, arguments);
  };
}();

/**
 * Transforms a request for the `registerIpAndMakeDerivativeAndDeployRoyaltyVault` contract method.
 */
var transferRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest = /*#__PURE__*/function () {
  var _ref10 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref1) {
    var request, calculatedDeadline, ipIdAddress, wallet, chainId, royaltyTokenDistributionWorkflowsClient, derivativeMintingFee, royaltyShares, signature, transformRequest, spenders;
    return _regenerator().w(function (_context6) {
      while (1) switch (_context6.n) {
        case 0:
          request = _ref1.request, calculatedDeadline = _ref1.calculatedDeadline, ipIdAddress = _ref1.ipIdAddress, wallet = _ref1.wallet, chainId = _ref1.chainId, royaltyTokenDistributionWorkflowsClient = _ref1.royaltyTokenDistributionWorkflowsClient, derivativeMintingFee = _ref1.derivativeMintingFee, royaltyShares = _ref1.royaltyShares;
          _context6.n = 1;
          return generateOperationSignature({
            ipIdAddress: ipIdAddress,
            methodType: SignatureMethodType.REGISTER_IP_AND_MAKE_DERIVATIVE_AND_DEPLOY_ROYALTY_VAULT,
            deadline: calculatedDeadline,
            wallet: wallet,
            chainId: chainId
          });
        case 1:
          signature = _context6.v;
          transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
            sigMetadataAndRegister: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signature
            }
          });
          spenders = derivativeMintingFee.map(function (fee) {
            return _objectSpread2({
              address: royaltyTokenDistributionWorkflowsClient.address
            }, fee);
          });
          return _context6.a(2, {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            spenders: spenders,
            contractCall: function contractCall() {
              return royaltyTokenDistributionWorkflowsClient.registerIpAndMakeDerivativeAndDeployRoyaltyVault(transformRequest);
            },
            workflowClient: royaltyTokenDistributionWorkflowsClient,
            encodedTxData: {
              to: royaltyTokenDistributionWorkflowsClient.address,
              data: viem.encodeFunctionData({
                abi: royaltyTokenDistributionWorkflowsAbi,
                functionName: "registerIpAndMakeDerivativeAndDeployRoyaltyVault",
                args: [transformRequest.nftContract, transformRequest.tokenId, transformRequest.ipMetadata, transformRequest.derivData, transformRequest.sigMetadataAndRegister]
              })
            },
            extraData: {
              royaltyShares: royaltyShares,
              deadline: calculatedDeadline
            }
          });
      }
    }, _callee6);
  }));
  return function transferRegisterIpAndMakeDerivativeAndDeployRoyaltyVaultRequest(_x6) {
    return _ref10.apply(this, arguments);
  };
}();

/**
 * Handles a request for the `mintAndRegister*` contract methods.
 *
 * @remarks
 * This method processes various mint and register workflows including:
 *
 * - {@link mintAndRegisterIpAndMakeDerivative} - Mints NFT and registers IP with derivative creation
 * - {@link mintAndRegisterIpAssetWithPilTerms} - Mints NFT and registers IP with PIL terms
 * - {@link mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens} - Mints, registers, attaches terms and distributes royalties
 * - {@link mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens} - Mints, registers with derivative and distributes royalties
 *
 * Key features and optimizations:
 * - Automatically calculates all required fees (SPG mint fees and license mint fees)
 * - Transaction batching strategy varies by contract type:
 *   - Public minting contracts: Uses `multicall3` for gas-efficient batching
 *   - Private minting contracts: Uses SPG's native `multicall` implementation
 *   - Special case: {@link mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens} always
 *     uses SPG's native multicall due to specific signature requirements
 */
var handleMintAndRegisterRequest = /*#__PURE__*/function () {
  var _ref12 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(_ref11) {
    var _request$allowDuplica;
    var request, rpcClient, wallet, chainId, royaltyTokenDistributionWorkflowsClient, licenseAttachmentWorkflowsClient, derivativeWorkflowsClient, isPublicMinting, nftMintFee, baseRequest, _yield$validateLicens2, licenseTermsData, maxLicenseTokens, requestWithTerms, derivData, derivativeMintingFee, requestWithDeriv;
    return _regenerator().w(function (_context7) {
      while (1) switch (_context7.n) {
        case 0:
          request = _ref11.request, rpcClient = _ref11.rpcClient, wallet = _ref11.wallet, chainId = _ref11.chainId;
          royaltyTokenDistributionWorkflowsClient = new RoyaltyTokenDistributionWorkflowsClient(rpcClient, wallet);
          licenseAttachmentWorkflowsClient = new LicenseAttachmentWorkflowsClient(rpcClient, wallet);
          derivativeWorkflowsClient = new DerivativeWorkflowsClient(rpcClient, wallet);
          _context7.n = 1;
          return getPublicMinting(request.spgNftContract, rpcClient);
        case 1:
          isPublicMinting = _context7.v;
          _context7.n = 2;
          return calculateSPGMintFee(new SpgnftImplReadOnlyClient(rpcClient, request.spgNftContract));
        case 2:
          nftMintFee = _context7.v;
          baseRequest = {
            spgNftContract: validateAddress(request.spgNftContract),
            recipient: validateAddress(request.recipient || wallet.account.address),
            ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
            allowDuplicates: (_request$allowDuplica = request.allowDuplicates) !== null && _request$allowDuplica !== void 0 ? _request$allowDuplica : true
          };
          if (!("licenseTermsData" in request)) {
            _context7.n = 5;
            break;
          }
          _context7.n = 3;
          return validateLicenseTermsData(request.licenseTermsData, rpcClient, chainId);
        case 3:
          _yield$validateLicens2 = _context7.v;
          licenseTermsData = _yield$validateLicens2.licenseTermsData;
          maxLicenseTokens = _yield$validateLicens2.maxLicenseTokens;
          requestWithTerms = _objectSpread2(_objectSpread2({}, baseRequest), {}, {
            licenseTermsData: licenseTermsData
          });
          if (!("royaltyShares" in request)) {
            _context7.n = 4;
            break;
          }
          return _context7.a(2, transformMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest({
            request: _objectSpread2(_objectSpread2({}, requestWithTerms), {}, {
              royaltyShares: request.royaltyShares
            }),
            royaltyTokenDistributionWorkflowsClient: royaltyTokenDistributionWorkflowsClient,
            nftMintFee: nftMintFee,
            maxLicenseTokens: maxLicenseTokens
          }));
        case 4:
          return _context7.a(2, transferMintAndRegisterIpAssetWithPilTermsRequest({
            request: _objectSpread2(_objectSpread2({}, requestWithTerms), {}, {
              licenseTermsData: licenseTermsData
            }),
            licenseAttachmentWorkflowsClient: licenseAttachmentWorkflowsClient,
            nftMintFee: nftMintFee,
            isPublicMinting: isPublicMinting,
            maxLicenseTokens: maxLicenseTokens
          }));
        case 5:
          if (!("derivData" in request)) {
            _context7.n = 9;
            break;
          }
          _context7.n = 6;
          return validateDerivativeData({
            derivativeDataInput: request.derivData,
            rpcClient: rpcClient,
            wallet: wallet,
            chainId: chainId
          });
        case 6:
          derivData = _context7.v;
          _context7.n = 7;
          return calculateDerivativeMintingFee({
            derivData: derivData,
            rpcClient: rpcClient,
            chainId: chainId,
            wallet: wallet
          });
        case 7:
          derivativeMintingFee = _context7.v;
          requestWithDeriv = _objectSpread2(_objectSpread2({}, baseRequest), {}, {
            derivData: derivData
          });
          if (!("royaltyShares" in request)) {
            _context7.n = 8;
            break;
          }
          return _context7.a(2, transferMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest({
            request: _objectSpread2(_objectSpread2({}, requestWithDeriv), {}, {
              royaltyShares: request.royaltyShares
            }),
            nftMintFee: nftMintFee,
            isPublicMinting: isPublicMinting,
            derivativeMintingFee: derivativeMintingFee,
            royaltyTokenDistributionWorkflowsClient: royaltyTokenDistributionWorkflowsClient
          }));
        case 8:
          return _context7.a(2, transferMintAndRegisterIpAndMakeDerivativeRequest({
            request: _objectSpread2(_objectSpread2({}, requestWithDeriv), {}, {
              derivData: derivData
            }),
            derivativeWorkflowsClient: derivativeWorkflowsClient,
            nftMintFee: nftMintFee,
            isPublicMinting: isPublicMinting,
            derivativeMintingFee: derivativeMintingFee
          }));
        case 9:
          throw new Error("Invalid mint and register request type");
        case 10:
          return _context7.a(2);
      }
    }, _callee7);
  }));
  return function handleMintAndRegisterRequest(_x7) {
    return _ref12.apply(this, arguments);
  };
}();

/**
 * Transforms a request for the `mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens` contract method.
 */
var transformMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest = function transformMintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensRequest(_ref13) {
  var request = _ref13.request,
    royaltyTokenDistributionWorkflowsClient = _ref13.royaltyTokenDistributionWorkflowsClient,
    nftMintFee = _ref13.nftMintFee,
    maxLicenseTokens = _ref13.maxLicenseTokens;
  var _getRoyaltyShares = getRoyaltyShares(request.royaltyShares),
    royaltyShares = _getRoyaltyShares.royaltyShares;
  var transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
    royaltyShares: royaltyShares
  });
  return {
    // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
    transformRequest: transformRequest,
    // Because mint tokens is given `msg.sender` as the recipient, so we need to set `useMulticall3` to false.
    isUseMulticall3: false,
    contractCall: function contractCall() {
      return royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(transformRequest);
    },
    spenders: _toConsumableArray(nftMintFee ? [_objectSpread2({
      address: transformRequest.spgNftContract
    }, nftMintFee)] : []),
    encodedTxData: {
      to: royaltyTokenDistributionWorkflowsClient.address,
      data: viem.encodeFunctionData({
        abi: royaltyTokenDistributionWorkflowsAbi,
        functionName: "mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens",
        args: [transformRequest.spgNftContract, transformRequest.recipient, transformRequest.ipMetadata, transformRequest.licenseTermsData, transformRequest.royaltyShares, transformRequest.allowDuplicates]
      })
    },
    workflowClient: royaltyTokenDistributionWorkflowsClient,
    extraData: {
      maxLicenseTokens: maxLicenseTokens,
      licenseTermsData: transformRequest.licenseTermsData
    }
  };
};

/**
 * Transforms a request for the `mintAndRegisterIpAssetWithPilTerms` contract method.
 */
var transferMintAndRegisterIpAssetWithPilTermsRequest = function transferMintAndRegisterIpAssetWithPilTermsRequest(_ref14) {
  var request = _ref14.request,
    licenseAttachmentWorkflowsClient = _ref14.licenseAttachmentWorkflowsClient,
    nftMintFee = _ref14.nftMintFee,
    isPublicMinting = _ref14.isPublicMinting,
    maxLicenseTokens = _ref14.maxLicenseTokens;
  var spenders = nftMintFee ? [_objectSpread2({
    address: request.spgNftContract
  }, nftMintFee)] : [];
  return {
    // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
    transformRequest: request,
    isUseMulticall3: isErc20AboveZero(spenders) ? false : isPublicMinting,
    spenders: spenders,
    encodedTxData: {
      to: licenseAttachmentWorkflowsClient.address,
      data: viem.encodeFunctionData({
        abi: licenseAttachmentWorkflowsAbi,
        functionName: "mintAndRegisterIpAndAttachPILTerms",
        args: [request.spgNftContract, request.recipient, request.ipMetadata, request.licenseTermsData, request.allowDuplicates]
      })
    },
    contractCall: function contractCall() {
      return licenseAttachmentWorkflowsClient.mintAndRegisterIpAndAttachPilTerms(request);
    },
    workflowClient: licenseAttachmentWorkflowsClient,
    extraData: {
      maxLicenseTokens: maxLicenseTokens,
      licenseTermsData: request.licenseTermsData
    }
  };
};

/**
 * Transforms a request for the `mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens` contract method.
 */
var transferMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest = function transferMintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensRequest(_ref15) {
  var _derivativeMintingFee;
  var request = _ref15.request,
    nftMintFee = _ref15.nftMintFee,
    isPublicMinting = _ref15.isPublicMinting,
    derivativeMintingFee = _ref15.derivativeMintingFee,
    royaltyTokenDistributionWorkflowsClient = _ref15.royaltyTokenDistributionWorkflowsClient;
  var _getRoyaltyShares2 = getRoyaltyShares(request.royaltyShares),
    royaltyShares = _getRoyaltyShares2.royaltyShares;
  /**
   * The SDK should handle both cases in the `contractCallWithFees` method.
   * Currently, it only supports WIP tokens and does not handle ERC20 tokens, such as approving ERC20 tokens.
   */
  var transformRequest = _objectSpread2(_objectSpread2({}, request), {}, {
    royaltyShares: royaltyShares
  });
  var spenders = (_derivativeMintingFee = derivativeMintingFee.map(function (fee) {
    return _objectSpread2({
      address: royaltyTokenDistributionWorkflowsClient.address
    }, fee);
  })).concat.apply(_derivativeMintingFee, _toConsumableArray(nftMintFee ? [_objectSpread2({
    address: request.spgNftContract
  }, nftMintFee)] : []));
  return {
    // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
    transformRequest: transformRequest,
    isUseMulticall3: isErc20AboveZero(spenders) ? false : isPublicMinting,
    spenders: spenders,
    encodedTxData: {
      to: royaltyTokenDistributionWorkflowsClient.address,
      data: viem.encodeFunctionData({
        abi: royaltyTokenDistributionWorkflowsAbi,
        functionName: "mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",
        args: [transformRequest.spgNftContract, transformRequest.recipient, transformRequest.ipMetadata, transformRequest.derivData, transformRequest.royaltyShares, transformRequest.allowDuplicates]
      })
    },
    workflowClient: royaltyTokenDistributionWorkflowsClient,
    contractCall: function contractCall() {
      return royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(transformRequest);
    }
  };
};
/**
 * Transforms a request for the `mintAndRegisterIpAndMakeDerivative` contract method.
 */

var transferMintAndRegisterIpAndMakeDerivativeRequest = function transferMintAndRegisterIpAndMakeDerivativeRequest(_ref16) {
  var _derivativeMintingFee2;
  var request = _ref16.request,
    derivativeWorkflowsClient = _ref16.derivativeWorkflowsClient,
    nftMintFee = _ref16.nftMintFee,
    isPublicMinting = _ref16.isPublicMinting,
    derivativeMintingFee = _ref16.derivativeMintingFee;
  var spenders = (_derivativeMintingFee2 = derivativeMintingFee.map(function (fee) {
    return _objectSpread2({
      address: derivativeWorkflowsClient.address
    }, fee);
  })).concat.apply(_derivativeMintingFee2, _toConsumableArray(nftMintFee ? [_objectSpread2({
    address: request.spgNftContract
  }, nftMintFee)] : []));
  return {
    // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
    transformRequest: request,
    isUseMulticall3: isErc20AboveZero(spenders) ? false : isPublicMinting,
    spenders: spenders,
    encodedTxData: {
      to: derivativeWorkflowsClient.address,
      data: viem.encodeFunctionData({
        abi: derivativeWorkflowsAbi,
        functionName: "mintAndRegisterIpAndMakeDerivative",
        args: [request.spgNftContract, request.derivData, request.ipMetadata, request.recipient, request.allowDuplicates]
      })
    },
    contractCall: function contractCall() {
      return derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivative(request);
    },
    workflowClient: derivativeWorkflowsClient
  };
};

/**
 * Transforms a request for the `distributeRoyaltyTokens` contract method.
 */
var transferDistributeRoyaltyTokensRequest = /*#__PURE__*/function () {
  var _ref18 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(_ref17) {
    var request, rpcClient, wallet, chainId, ipId, deadline, ipRoyaltyVault, totalAmount, calculatedDeadline, ipRoyaltyVaultImpl, balance, royaltyTokenDistributionWorkflowsClient, ipAccount, _yield$ipAccount$stat, state, signatureApproveRoyaltyTokens, transformRequest;
    return _regenerator().w(function (_context8) {
      while (1) switch (_context8.n) {
        case 0:
          request = _ref17.request, rpcClient = _ref17.rpcClient, wallet = _ref17.wallet, chainId = _ref17.chainId;
          ipId = request.ipId, deadline = request.deadline, ipRoyaltyVault = request.ipRoyaltyVault, totalAmount = request.totalAmount;
          _context8.n = 1;
          return getCalculatedDeadline(rpcClient, deadline);
        case 1:
          calculatedDeadline = _context8.v;
          ipRoyaltyVaultImpl = new IpRoyaltyVaultImplReadOnlyClient(rpcClient, ipRoyaltyVault);
          _context8.n = 2;
          return ipRoyaltyVaultImpl.balanceOf({
            account: ipId
          });
        case 2:
          balance = _context8.v;
          royaltyTokenDistributionWorkflowsClient = new RoyaltyTokenDistributionWorkflowsClient(rpcClient, wallet);
          if (!(BigInt(balance) < BigInt(totalAmount))) {
            _context8.n = 3;
            break;
          }
          throw new Error("The balance of the IP account in the IP Royalty Vault is insufficient to distribute the royalty tokens.");
        case 3:
          ipAccount = new IpAccountImplClient(rpcClient, wallet, validateAddress(ipId));
          _context8.n = 4;
          return ipAccount.state();
        case 4:
          _yield$ipAccount$stat = _context8.v;
          state = _yield$ipAccount$stat.result;
          _context8.n = 5;
          return generateOperationSignature({
            ipIdAddress: ipId,
            methodType: SignatureMethodType.DISTRIBUTE_ROYALTY_TOKENS,
            deadline: calculatedDeadline,
            ipRoyaltyVault: ipRoyaltyVault,
            totalAmount: totalAmount,
            state: state,
            encodeData: viem.encodeFunctionData({
              abi: ipRoyaltyVaultImplAbi,
              functionName: "approve",
              args: [royaltyTokenDistributionWorkflowsAddress[chainId], BigInt(totalAmount)]
            }),
            wallet: wallet,
            chainId: chainId
          });
        case 5:
          signatureApproveRoyaltyTokens = _context8.v;
          transformRequest = {
            ipId: ipId,
            royaltyShares: request.royaltyShares,
            sigApproveRoyaltyTokens: {
              signer: wallet.account.address,
              deadline: calculatedDeadline,
              signature: signatureApproveRoyaltyTokens
            }
          };
          return _context8.a(2, {
            // The `TransformIpRegistrationWorkflowResponse` is a union of all the possible requests, so we need to explicitly cast the type.
            transformRequest: transformRequest,
            isUseMulticall3: false,
            contractCall: function contractCall() {
              return royaltyTokenDistributionWorkflowsClient.distributeRoyaltyTokens(transformRequest);
            },
            workflowClient: royaltyTokenDistributionWorkflowsClient,
            encodedTxData: {
              to: royaltyTokenDistributionWorkflowsAddress[chainId],
              data: viem.encodeFunctionData({
                abi: royaltyTokenDistributionWorkflowsAbi,
                functionName: "distributeRoyaltyTokens",
                args: [transformRequest.ipId, transformRequest.royaltyShares, transformRequest.sigApproveRoyaltyTokens]
              })
            }
          });
      }
    }, _callee8);
  }));
  return function transferDistributeRoyaltyTokensRequest(_x8) {
    return _ref18.apply(this, arguments);
  };
}();
var prepareRoyaltyTokensDistributionRequests = /*#__PURE__*/function () {
  var _ref20 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(_ref19) {
    var royaltyDistributionRequests, ipRegisteredLog, ipRoyaltyVault, rpcClient, wallet, chainId, requests, ipRoyaltyVaults, _iterator, _step, _loop, _t;
    return _regenerator().w(function (_context0) {
      while (1) switch (_context0.p = _context0.n) {
        case 0:
          royaltyDistributionRequests = _ref19.royaltyDistributionRequests, ipRegisteredLog = _ref19.ipRegisteredLog, ipRoyaltyVault = _ref19.ipRoyaltyVault, rpcClient = _ref19.rpcClient, wallet = _ref19.wallet, chainId = _ref19.chainId;
          if (!(royaltyDistributionRequests.length === 0)) {
            _context0.n = 1;
            break;
          }
          return _context0.a(2, {
            requests: [],
            ipRoyaltyVaults: []
          });
        case 1:
          requests = [];
          ipRoyaltyVaults = [];
          _iterator = _createForOfIteratorHelper(royaltyDistributionRequests);
          _context0.p = 2;
          _loop = /*#__PURE__*/_regenerator().m(function _loop() {
            var req, filterIpIdAndTokenId, _req$royaltyShares, _getRoyaltyShares3, royaltyShares, totalAmount, calculatedDeadline, ipRoyaltyVaultItem, response;
            return _regenerator().w(function (_context9) {
              while (1) switch (_context9.n) {
                case 0:
                  req = _step.value;
                  filterIpIdAndTokenId = ipRegisteredLog.find(function (_ref21) {
                    var tokenContract = _ref21.tokenContract,
                      tokenId = _ref21.tokenId;
                    return tokenContract === req.nftContract && tokenId === req.tokenId;
                  });
                  if (!filterIpIdAndTokenId) {
                    _context9.n = 3;
                    break;
                  }
                  _getRoyaltyShares3 = getRoyaltyShares((_req$royaltyShares = req.royaltyShares) !== null && _req$royaltyShares !== void 0 ? _req$royaltyShares : []), royaltyShares = _getRoyaltyShares3.royaltyShares, totalAmount = _getRoyaltyShares3.totalAmount;
                  _context9.n = 1;
                  return getCalculatedDeadline(rpcClient, req.deadline);
                case 1:
                  calculatedDeadline = _context9.v;
                  // The ipRoyaltyVaultItem must be found, otherwise, the request is invalid.
                  ipRoyaltyVaultItem = ipRoyaltyVault.find(function (item) {
                    return item.ipId === filterIpIdAndTokenId.ipId;
                  });
                  _context9.n = 2;
                  return transferDistributeRoyaltyTokensRequest({
                    request: {
                      ipId: filterIpIdAndTokenId.ipId,
                      ipRoyaltyVault: ipRoyaltyVaultItem.ipRoyaltyVault,
                      royaltyShares: royaltyShares,
                      totalAmount: totalAmount,
                      deadline: calculatedDeadline
                    },
                    rpcClient: rpcClient,
                    wallet: wallet,
                    chainId: chainId
                  });
                case 2:
                  response = _context9.v;
                  requests.push(response);
                  ipRoyaltyVaults.push(ipRoyaltyVaultItem);
                case 3:
                  return _context9.a(2);
              }
            }, _loop);
          });
          _iterator.s();
        case 3:
          if ((_step = _iterator.n()).done) {
            _context0.n = 5;
            break;
          }
          return _context0.d(_regeneratorValues(_loop()), 4);
        case 4:
          _context0.n = 3;
          break;
        case 5:
          _context0.n = 7;
          break;
        case 6:
          _context0.p = 6;
          _t = _context0.v;
          _iterator.e(_t);
        case 7:
          _context0.p = 7;
          _iterator.f();
          return _context0.f(7);
        case 8:
          return _context0.a(2, {
            requests: requests,
            ipRoyaltyVaults: ipRoyaltyVaults
          });
      }
    }, _callee9, null, [[2, 6, 7, 8]]);
  }));
  return function prepareRoyaltyTokensDistributionRequests(_x9) {
    return _ref20.apply(this, arguments);
  };
}();

/**
 * Checks if the spenders contain ERC20 tokens with amount above zero.
 * Due to the `msg.sender` context limitations, if the spenders contain ERC20 tokens with amount above zero, the multicall3 cannot be used.
 */

var isErc20AboveZero = function isErc20AboveZero(spenders) {
  var erc20Spenders = spenders.filter(function (spender) {
    return spender.token !== WIP_TOKEN_ADDRESS;
  });
  var erc20TotalAmount = erc20Spenders.reduce(function (acc, spender) {
    var _spender$amount;
    return acc + ((_spender$amount = spender.amount) !== null && _spender$amount !== void 0 ? _spender$amount : 0n);
  }, 0n);
  return erc20TotalAmount > 0n;
};

var setMaxLicenseTokens = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(_ref) {
    var maxLicenseTokensData, licensorIpId, licenseTermsIds, totalLicenseTokenLimitHookClient, templateAddress, licenseTermsMaxLimitTxHashes, i, maxLicenseTokens, txHash;
    return _regenerator().w(function (_context) {
      while (1) switch (_context.n) {
        case 0:
          maxLicenseTokensData = _ref.maxLicenseTokensData, licensorIpId = _ref.licensorIpId, licenseTermsIds = _ref.licenseTermsIds, totalLicenseTokenLimitHookClient = _ref.totalLicenseTokenLimitHookClient, templateAddress = _ref.templateAddress;
          licenseTermsMaxLimitTxHashes = [];
          i = 0;
        case 1:
          if (!(i < maxLicenseTokensData.length)) {
            _context.n = 5;
            break;
          }
          maxLicenseTokens = maxLicenseTokensData[i].maxLicenseTokens;
          if (!(maxLicenseTokens === undefined || maxLicenseTokens < 0n)) {
            _context.n = 2;
            break;
          }
          return _context.a(3, 4);
        case 2:
          _context.n = 3;
          return totalLicenseTokenLimitHookClient.setTotalLicenseTokenLimit({
            licensorIpId: licensorIpId,
            licenseTemplate: templateAddress,
            licenseTermsId: licenseTermsIds[i],
            limit: BigInt(maxLicenseTokens)
          });
        case 3:
          txHash = _context.v;
          if (txHash) {
            licenseTermsMaxLimitTxHashes.push(txHash);
          }
        case 4:
          i++;
          _context.n = 1;
          break;
        case 5:
          return _context.a(2, licenseTermsMaxLimitTxHashes);
      }
    }, _callee);
  }));
  return function setMaxLicenseTokens(_x) {
    return _ref2.apply(this, arguments);
  };
}();

var IPAssetClient = /*#__PURE__*/function () {
  function IPAssetClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, IPAssetClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.licenseTokenReadOnlyClient = new LicenseTokenReadOnlyClient(rpcClient);
    this.accessControllerClient = new AccessControllerClient(rpcClient, wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(rpcClient, wallet);
    this.registrationWorkflowsClient = new RegistrationWorkflowsClient(rpcClient, wallet);
    this.licenseAttachmentWorkflowsClient = new LicenseAttachmentWorkflowsClient(rpcClient, wallet);
    this.derivativeWorkflowsClient = new DerivativeWorkflowsClient(rpcClient, wallet);
    this.royaltyTokenDistributionWorkflowsClient = new RoyaltyTokenDistributionWorkflowsClient(rpcClient, wallet);
    this.royaltyModuleEventClient = new RoyaltyModuleEventClient(rpcClient);
    this.wipClient = new WrappedIpClient(rpcClient, wallet);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.spgNftClient = new SpgnftImplReadOnlyClient(rpcClient);
    this.totalLicenseTokenLimitHookClient = new TotalLicenseTokenLimitHookClient(rpcClient, wallet);
    this.licenseTokenClient = new LicenseTokenClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.walletAddress = this.wallet.account.address;
    this.licenseTemplateAddress = this.licenseTemplateClient.address;
  }
  return _createClass(IPAssetClient, [{
    key: "generateCreatorMetadata",
    value: function generateCreatorMetadata(creator) {
      return creator;
    }
  }, {
    key: "generateIpMetadata",
    value: function generateIpMetadata(metadata) {
      return metadata;
    }

    /**
     * Registers an NFT as IP, creating a corresponding IP record.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
  }, {
    key: "register",
    value: (function () {
      var _register = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(request) {
        var _request$txOptions, tokenId, ipIdAddress, isRegistered, object, calculatedDeadline, signature, txHash, txReceipt, log, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              tokenId = BigInt(request.tokenId);
              _context.n = 1;
              return getIpIdAddress({
                nftContract: request.nftContract,
                tokenId: tokenId,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 1:
              ipIdAddress = _context.v;
              _context.n = 2;
              return this.isRegistered(ipIdAddress);
            case 2:
              isRegistered = _context.v;
              if (!isRegistered) {
                _context.n = 3;
                break;
              }
              return _context.a(2, {
                ipId: ipIdAddress
              });
            case 3:
              object = {
                tokenId: tokenId,
                nftContract: validateAddress(request.nftContract),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigMetadata: {
                  signer: viem.zeroAddress,
                  deadline: BigInt(0),
                  signature: viem.zeroHash
                }
              };
              if (!request.ipMetadata) {
                _context.n = 6;
                break;
              }
              _context.n = 4;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 4:
              calculatedDeadline = _context.v;
              _context.n = 5;
              return generateOperationSignature({
                ipIdAddress: ipIdAddress,
                methodType: SignatureMethodType.REGISTER,
                deadline: calculatedDeadline,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 5:
              signature = _context.v;
              object.sigMetadata = {
                signer: validateAddress(this.walletAddress),
                deadline: calculatedDeadline,
                signature: signature
              };
            case 6:
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.n = 9;
                break;
              }
              if (!request.ipMetadata) {
                _context.n = 7;
                break;
              }
              return _context.a(2, {
                encodedTxData: this.registrationWorkflowsClient.registerIpEncode(object)
              });
            case 7:
              return _context.a(2, {
                encodedTxData: this.ipAssetRegistryClient.registerEncode({
                  tokenContract: object.nftContract,
                  tokenId: object.tokenId,
                  chainid: BigInt(this.chainId)
                })
              });
            case 8:
              _context.n = 15;
              break;
            case 9:
              if (!request.ipMetadata) {
                _context.n = 11;
                break;
              }
              _context.n = 10;
              return this.registrationWorkflowsClient.registerIp(object);
            case 10:
              txHash = _context.v;
              _context.n = 13;
              break;
            case 11:
              _context.n = 12;
              return this.ipAssetRegistryClient.register({
                tokenContract: object.nftContract,
                tokenId: object.tokenId,
                chainid: BigInt(this.chainId)
              });
            case 12:
              txHash = _context.v;
            case 13:
              _context.n = 14;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 14:
              txReceipt = _context.v;
              log = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0];
              return _context.a(2, _objectSpread2({
                txHash: txHash
              }, log));
            case 15:
              _context.n = 17;
              break;
            case 16:
              _context.p = 16;
              _t = _context.v;
              return _context.a(2, handleError(_t, "Failed to register IP"));
            case 17:
              return _context.a(2);
          }
        }, _callee, this, [[0, 16]]);
      }));
      function register(_x) {
        return _register.apply(this, arguments);
      }
      return register;
    }()
    /**
     * Batch registers an NFT as IP, creating a corresponding IP record.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "batchRegister",
    value: (function () {
      var _batchRegister = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(request) {
        var _this = this;
        var contracts, spgContracts, encodedTxData, _iterator, _step, arg, result, spgTxHash, txHash, results, processTransaction, _t2, _t3, _t4;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              contracts = [];
              spgContracts = [];
              _iterator = _createForOfIteratorHelper(request.args);
              _context3.p = 1;
              _iterator.s();
            case 2:
              if ((_step = _iterator.n()).done) {
                _context3.n = 8;
                break;
              }
              arg = _step.value;
              _context3.p = 3;
              _context3.n = 4;
              return this.register(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 4:
              result = _context3.v;
              encodedTxData = result.encodedTxData.data;
              _context3.n = 6;
              break;
            case 5:
              _context3.p = 5;
              _t2 = _context3.v;
              throw new Error(_t2.message.replace("Failed to register IP:", "").trim());
            case 6:
              if (arg.ipMetadata) {
                spgContracts.push(encodedTxData);
              } else {
                contracts.push({
                  target: this.ipAssetRegistryClient.address,
                  allowFailure: false,
                  callData: encodedTxData
                });
              }
            case 7:
              _context3.n = 2;
              break;
            case 8:
              _context3.n = 10;
              break;
            case 9:
              _context3.p = 9;
              _t3 = _context3.v;
              _iterator.e(_t3);
            case 10:
              _context3.p = 10;
              _iterator.f();
              return _context3.f(10);
            case 11:
              if (!(spgContracts.length > 0)) {
                _context3.n = 13;
                break;
              }
              _context3.n = 12;
              return this.registrationWorkflowsClient.multicall({
                data: spgContracts
              });
            case 12:
              spgTxHash = _context3.v;
            case 13:
              if (!(contracts.length > 0)) {
                _context3.n = 15;
                break;
              }
              _context3.n = 14;
              return this.multicall3Client.aggregate3({
                calls: contracts
              });
            case 14:
              txHash = _context3.v;
            case 15:
              results = [];
              processTransaction = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(hash, contractType) {
                  var txReceipt, eventResults;
                  return _regenerator().w(function (_context2) {
                    while (1) switch (_context2.n) {
                      case 0:
                        _context2.n = 1;
                        return _this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                          hash: hash
                        }));
                      case 1:
                        txReceipt = _context2.v;
                        eventResults = _this.getIpIdAndTokenIdsFromEvent(txReceipt, contractType);
                        results.push.apply(results, _toConsumableArray(eventResults));
                      case 2:
                        return _context2.a(2);
                    }
                  }, _callee2);
                }));
                return function processTransaction(_x3, _x4) {
                  return _ref.apply(this, arguments);
                };
              }();
              if (!txHash) {
                _context3.n = 16;
                break;
              }
              _context3.n = 16;
              return processTransaction(txHash, "nftContract");
            case 16:
              if (!spgTxHash) {
                _context3.n = 17;
                break;
              }
              _context3.n = 17;
              return processTransaction(spgTxHash, "spgNftContract");
            case 17:
              return _context3.a(2, {
                txHash: txHash,
                spgTxHash: spgTxHash,
                results: results
              });
            case 18:
              _context3.p = 18;
              _t4 = _context3.v;
              return _context3.a(2, handleError(_t4, "Failed to batch register IP"));
          }
        }, _callee3, this, [[3, 5], [1, 9, 10, 11], [0, 18]]);
      }));
      function batchRegister(_x2) {
        return _batchRegister.apply(this, arguments);
      }
      return batchRegister;
    }()
    /**
     * Registers a derivative directly with parent IP's license terms, without needing license tokens,
     * and attaches the license terms of the parent IPs to the derivative IP.
     * The license terms must be attached to the parent IP before calling this function.
     * All IPs attached default license terms by default.
     * The derivative IP owner must be the caller or an authorized operator.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link linkDerivative} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.registerDerivative({
     *   childIpId: '0x...',
     *   parentIpIds: ['0x...'],
     *   licenseTermsIds: [1n]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.linkDerivative({
     *   childIpId: '0x...',
     *   parentIpIds: ['0x...'],
     *   licenseTermsIds: [1n]
     * });
     * ```
     */
    )
  }, {
    key: "registerDerivative",
    value: (function () {
      var _registerDerivative = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(request) {
        var _this2 = this;
        var _request$txOptions2, isChildIpIdRegistered, derivativeData, object, encodedTxData, _request$options, contractCall, _t5;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              _context4.n = 1;
              return this.isRegistered(request.childIpId);
            case 1:
              isChildIpIdRegistered = _context4.v;
              if (isChildIpIdRegistered) {
                _context4.n = 2;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 2:
              _context4.n = 3;
              return validateDerivativeData({
                derivativeDataInput: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 3:
              derivativeData = _context4.v;
              object = _objectSpread2({
                childIpId: request.childIpId
              }, derivativeData);
              encodedTxData = this.licensingModuleClient.registerDerivativeEncode(object);
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.encodedTxDataOnly)) {
                _context4.n = 4;
                break;
              }
              return _context4.a(2, {
                encodedTxData: encodedTxData
              });
            case 4:
              contractCall = function contractCall() {
                return _this2.licensingModuleClient.registerDerivative(object);
              };
              return _context4.a(2, this.handleRegistrationWithFees({
                sender: this.walletAddress,
                derivData: object,
                contractCall: contractCall,
                txOptions: request.txOptions,
                encodedTxs: [encodedTxData],
                spgSpenderAddress: this.royaltyModuleEventClient.address,
                options: _objectSpread2(_objectSpread2({}, request.options), {}, {
                  wipOptions: _objectSpread2(_objectSpread2({}, (_request$options = request.options) === null || _request$options === void 0 ? void 0 : _request$options.wipOptions), {}, {
                    useMulticallWhenPossible: false
                  })
                })
              }));
            case 5:
              _context4.n = 7;
              break;
            case 6:
              _context4.p = 6;
              _t5 = _context4.v;
              return _context4.a(2, handleError(_t5, "Failed to register derivative"));
            case 7:
              return _context4.a(2);
          }
        }, _callee4, this, [[0, 6]]);
      }));
      function registerDerivative(_x5) {
        return _registerDerivative.apply(this, arguments);
      }
      return registerDerivative;
    }()
    /**
     * Batch registers a derivative directly with parent IP's license terms.
     */
    )
  }, {
    key: "batchRegisterDerivative",
    value: (function () {
      var _batchRegisterDerivative = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(request) {
        var contracts, licenseModuleAddress, _iterator2, _step2, _arg$maxMintingFee, _arg$maxRevenueShare, arg, calculatedDeadline, ipAccount, data, _yield$ipAccount$stat, state, signature, txHash, _t6, _t7, _t8;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              _context5.p = 0;
              contracts = [];
              licenseModuleAddress = validateAddress(this.licensingModuleClient.address);
              _iterator2 = _createForOfIteratorHelper(request.args);
              _context5.p = 1;
              _iterator2.s();
            case 2:
              if ((_step2 = _iterator2.n()).done) {
                _context5.n = 11;
                break;
              }
              arg = _step2.value;
              _context5.p = 3;
              _context5.n = 4;
              return this.registerDerivative(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 4:
              _context5.n = 6;
              break;
            case 5:
              _context5.p = 5;
              _t6 = _context5.v;
              throw new Error(_t6.message.replace("Failed to register derivative:", "").trim());
            case 6:
              _context5.n = 7;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 7:
              calculatedDeadline = _context5.v;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, validateAddress(arg.childIpId));
              data = viem.encodeFunctionData({
                abi: licensingModuleAbi,
                functionName: "registerDerivative",
                args: [arg.childIpId, arg.parentIpIds, arg.licenseTermsIds.map(function (id) {
                  return BigInt(id);
                }), arg.licenseTemplate || this.licenseTemplateAddress, viem.zeroAddress, BigInt((_arg$maxMintingFee = arg.maxMintingFee) !== null && _arg$maxMintingFee !== void 0 ? _arg$maxMintingFee : 0), validateMaxRts(arg.maxRts), getRevenueShare((_arg$maxRevenueShare = arg.maxRevenueShare) !== null && _arg$maxRevenueShare !== void 0 ? _arg$maxRevenueShare : 100, RevShareType.MAX_REVENUE_SHARE)]
              });
              _context5.n = 8;
              return ipAccount.state();
            case 8:
              _yield$ipAccount$stat = _context5.v;
              state = _yield$ipAccount$stat.result;
              _context5.n = 9;
              return generateOperationSignature({
                ipIdAddress: arg.childIpId,
                methodType: SignatureMethodType.BATCH_REGISTER_DERIVATIVE,
                state: state,
                encodeData: data,
                deadline: calculatedDeadline,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 9:
              signature = _context5.v;
              contracts.push({
                target: arg.childIpId,
                allowFailure: false,
                callData: viem.encodeFunctionData({
                  abi: ipAccountImplAbi,
                  functionName: "executeWithSig",
                  args: [licenseModuleAddress, BigInt(0), data, this.wallet.account.address, calculatedDeadline, signature]
                })
              });
            case 10:
              _context5.n = 2;
              break;
            case 11:
              _context5.n = 13;
              break;
            case 12:
              _context5.p = 12;
              _t7 = _context5.v;
              _iterator2.e(_t7);
            case 13:
              _context5.p = 13;
              _iterator2.f();
              return _context5.f(13);
            case 14:
              _context5.n = 15;
              return this.multicall3Client.aggregate3({
                calls: contracts
              });
            case 15:
              txHash = _context5.v;
              _context5.n = 16;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 16:
              return _context5.a(2, {
                txHash: txHash
              });
            case 17:
              _context5.p = 17;
              _t8 = _context5.v;
              return _context5.a(2, handleError(_t8, "Failed to batch register derivative"));
          }
        }, _callee5, this, [[3, 5], [1, 12, 13, 14], [0, 17]]);
      }));
      function batchRegisterDerivative(_x6) {
        return _batchRegisterDerivative.apply(this, arguments);
      }
      return batchRegisterDerivative;
    }()
    /**
     * Registers a derivative with license tokens. The derivative IP is registered with license tokens minted from the parent IP's license terms.
     * The license terms of the parent IPs issued with license tokens are attached to the derivative IP.
     * The caller must be the derivative IP owner or an authorized operator.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link linkDerivative} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.registerDerivativeWithLicenseTokens({
     *   childIpId: '0x...',
     *   licenseTokenIds: [1n, 2n, 3n]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.linkDerivative({
     *   childIpId: '0x...',
     *   licenseTokenIds: [1n, 2n, 3n]
     * });
     * ```
     */
    )
  }, {
    key: "registerDerivativeWithLicenseTokens",
    value: (function () {
      var _registerDerivativeWithLicenseTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(request) {
        var _request$txOptions3, req, isChildIpIdRegistered, txHash, _t9;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              _context6.p = 0;
              req = {
                childIpId: validateAddress(request.childIpId),
                licenseTokenIds: request.licenseTokenIds.map(function (id) {
                  return BigInt(id);
                }),
                royaltyContext: viem.zeroAddress,
                maxRts: validateMaxRts(request.maxRts)
              };
              _context6.n = 1;
              return this.isRegistered(request.childIpId);
            case 1:
              isChildIpIdRegistered = _context6.v;
              if (isChildIpIdRegistered) {
                _context6.n = 2;
                break;
              }
              throw new Error("The child IP with id ".concat(request.childIpId, " is not registered."));
            case 2:
              if (!(request.licenseTokenIds.length === 0)) {
                _context6.n = 3;
                break;
              }
              throw new Error("The licenseTokenIds must be provided.");
            case 3:
              _context6.n = 4;
              return this.validateLicenseTokenIds(request.licenseTokenIds);
            case 4:
              request.licenseTokenIds = _context6.v;
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context6.n = 5;
                break;
              }
              return _context6.a(2, {
                encodedTxData: this.licensingModuleClient.registerDerivativeWithLicenseTokensEncode(req)
              });
            case 5:
              _context6.n = 6;
              return this.licensingModuleClient.registerDerivativeWithLicenseTokens(req);
            case 6:
              txHash = _context6.v;
              _context6.n = 7;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 7:
              return _context6.a(2, {
                txHash: txHash
              });
            case 8:
              _context6.n = 10;
              break;
            case 9:
              _context6.p = 9;
              _t9 = _context6.v;
              return _context6.a(2, handleError(_t9, "Failed to register derivative with license tokens"));
            case 10:
              return _context6.a(2);
          }
        }, _callee6, this, [[0, 9]]);
      }));
      function registerDerivativeWithLicenseTokens(_x7) {
        return _registerDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerDerivativeWithLicenseTokens;
    }()
    /**
     * Mint an NFT from a collection and register it as an IP.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.mintAndRegisterIpAssetWithPilTerms({
     *   spgNftContract: '0x...',
     *   licenseTermsData: [{ terms: PILFlavor.commercialRemix({...}) }]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerIpAsset({
     *   nft: { type: 'mint', spgNftContract: '0x...' },
     *   licenseTermsData: [{ terms: PILFlavor.commercialRemix({...}) }]
     * });
     * ```
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L19 | `LicenseTermsAttached`} events.
     */
    )
  }, {
    key: "mintAndRegisterIpAssetWithPilTerms",
    value: (function () {
      var _mintAndRegisterIpAssetWithPilTerms = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(request) {
        var _this3 = this;
        var _request$txOptions4, _yield$transformRegis, transformRequest, encodedTxData, contractCall, rsp, computedLicenseTermsIds, maxLicenseTokensTxHashes, _t0;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              _context7.p = 0;
              _context7.n = 1;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 1:
              _yield$transformRegis = _context7.v;
              transformRequest = _yield$transformRegis.transformRequest;
              encodedTxData = this.licenseAttachmentWorkflowsClient.mintAndRegisterIpAndAttachPilTermsEncode(transformRequest);
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.encodedTxDataOnly)) {
                _context7.n = 2;
                break;
              }
              return _context7.a(2, {
                encodedTxData: encodedTxData
              });
            case 2:
              contractCall = function contractCall() {
                return _this3.licenseAttachmentWorkflowsClient.mintAndRegisterIpAndAttachPilTerms(transformRequest);
              };
              _context7.n = 3;
              return this.handleRegistrationWithFees({
                options: request.options,
                sender: this.walletAddress,
                spgNftContract: transformRequest.spgNftContract,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              });
            case 3:
              rsp = _context7.v;
              _context7.n = 4;
              return this.getLicenseTermsId(transformRequest.licenseTermsData.map(function (data) {
                return data.terms;
              }));
            case 4:
              computedLicenseTermsIds = _context7.v;
              _context7.n = 5;
              return setMaxLicenseTokens({
                maxLicenseTokensData: request.licenseTermsData,
                licensorIpId: rsp.ipId,
                licenseTermsIds: computedLicenseTermsIds,
                totalLicenseTokenLimitHookClient: this.totalLicenseTokenLimitHookClient,
                templateAddress: this.licenseTemplateAddress
              });
            case 5:
              maxLicenseTokensTxHashes = _context7.v;
              return _context7.a(2, _objectSpread2(_objectSpread2({}, rsp), {}, {
                licenseTermsIds: computedLicenseTermsIds
              }, maxLicenseTokensTxHashes.length > 0 && {
                maxLicenseTokensTxHashes: maxLicenseTokensTxHashes
              }));
            case 6:
              _context7.p = 6;
              _t0 = _context7.v;
              return _context7.a(2, handleError(_t0, "Failed to mint and register IP and attach PIL terms"));
          }
        }, _callee7, this, [[0, 6]]);
      }));
      function mintAndRegisterIpAssetWithPilTerms(_x8) {
        return _mintAndRegisterIpAssetWithPilTerms.apply(this, arguments);
      }
      return mintAndRegisterIpAssetWithPilTerms;
    }()
    /**
     * Batch mint an NFT from a collection and register it as an IP.
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L19 | `LicenseTermsAttached`} events.
     */
    )
  }, {
    key: "batchMintAndRegisterIpAssetWithPilTerms",
    value: (function () {
      var _batchMintAndRegisterIpAssetWithPilTerms = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(request) {
        var calldata, _iterator3, _step3, arg, result, txHash, txReceipt, results, j, licenseTerms, licenseTermsData, i, licenseTerm, licenseTermsIds, maxLicenseTokensTxHashes, _t1, _t10;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              _context8.p = 0;
              calldata = [];
              _iterator3 = _createForOfIteratorHelper(request.args);
              _context8.p = 1;
              _iterator3.s();
            case 2:
              if ((_step3 = _iterator3.n()).done) {
                _context8.n = 5;
                break;
              }
              arg = _step3.value;
              _context8.n = 3;
              return this.mintAndRegisterIpAssetWithPilTerms(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 3:
              result = _context8.v;
              calldata.push(result.encodedTxData.data);
            case 4:
              _context8.n = 2;
              break;
            case 5:
              _context8.n = 7;
              break;
            case 6:
              _context8.p = 6;
              _t1 = _context8.v;
              _iterator3.e(_t1);
            case 7:
              _context8.p = 7;
              _iterator3.f();
              return _context8.f(7);
            case 8:
              _context8.n = 9;
              return this.licenseAttachmentWorkflowsClient.multicall({
                data: calldata
              });
            case 9:
              txHash = _context8.v;
              _context8.n = 10;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 10:
              txReceipt = _context8.v;
              results = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt).map(function (log) {
                return {
                  ipId: log.ipId,
                  tokenId: log.tokenId,
                  spgNftContract: log.tokenContract,
                  licenseTermsIds: []
                };
              }); // Due to emit event log by sequence, we need to get license terms id from request.args
              j = 0;
            case 11:
              if (!(j < request.args.length)) {
                _context8.n = 15;
                break;
              }
              licenseTerms = [];
              licenseTermsData = request.args[j].licenseTermsData;
              for (i = 0; i < licenseTermsData.length; i++) {
                licenseTerm = PILFlavor.validateLicenseTerms(licenseTermsData[i].terms, this.chainId);
                licenseTerms.push(licenseTerm);
              }
              _context8.n = 12;
              return this.getLicenseTermsId(licenseTerms);
            case 12:
              licenseTermsIds = _context8.v;
              results[j].licenseTermsIds = licenseTermsIds;
              _context8.n = 13;
              return setMaxLicenseTokens({
                maxLicenseTokensData: licenseTermsData,
                licensorIpId: results[j].ipId,
                licenseTermsIds: licenseTermsIds,
                totalLicenseTokenLimitHookClient: this.totalLicenseTokenLimitHookClient,
                templateAddress: this.licenseTemplateAddress
              });
            case 13:
              maxLicenseTokensTxHashes = _context8.v;
              if (maxLicenseTokensTxHashes.length > 0) {
                results[j].maxLicenseTokensTxHashes = maxLicenseTokensTxHashes;
              }
            case 14:
              j++;
              _context8.n = 11;
              break;
            case 15:
              return _context8.a(2, {
                txHash: txHash,
                results: results
              });
            case 16:
              _context8.p = 16;
              _t10 = _context8.v;
              return _context8.a(2, handleError(_t10, "Failed to batch mint and register IP and attach PIL terms"));
          }
        }, _callee8, this, [[1, 6, 7, 8], [0, 16]]);
      }));
      function batchMintAndRegisterIpAssetWithPilTerms(_x9) {
        return _batchMintAndRegisterIpAssetWithPilTerms.apply(this, arguments);
      }
      return batchMintAndRegisterIpAssetWithPilTerms;
    }()
    /**
     * Register a given NFT as an IP and attach Programmable IP License Terms.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.registerIpAndAttachPilTerms({
     *   nftContract: '0x...',
     *   tokenId: 123n,
     *   licenseTermsData: [{ terms: PILFlavor.nonCommercialSocialRemixing() }]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerIpAsset({
     *   nft: { type: 'minted', nftContract: '0x...', tokenId: 123n },
     *   licenseTermsData: [{ terms: PILFlavor.nonCommercialSocialRemixing() }]
     * });
     * ```
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L19 | `LicenseTermsAttached`} events.
     */
    )
  }, {
    key: "registerIpAndAttachPilTerms",
    value: (function () {
      var _registerIpAndAttachPilTerms = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(request) {
        var _request$txOptions5, ipIdAddress, isRegistered, _yield$validateLicens, licenseTerms, _yield$transformRegis2, _transformRequest, txHash, txReceipt, log, licenseTermsIds, maxLicenseTokensTxHashes, _t11;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              _context9.p = 0;
              request.tokenId = BigInt(request.tokenId);
              _context9.n = 1;
              return getIpIdAddress({
                nftContract: request.nftContract,
                tokenId: request.tokenId,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 1:
              ipIdAddress = _context9.v;
              _context9.n = 2;
              return this.isRegistered(ipIdAddress);
            case 2:
              isRegistered = _context9.v;
              if (!isRegistered) {
                _context9.n = 3;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 3:
              _context9.n = 4;
              return validateLicenseTermsData(request.licenseTermsData, this.rpcClient, this.chainId);
            case 4:
              _yield$validateLicens = _context9.v;
              licenseTerms = _yield$validateLicens.licenseTerms;
              _context9.n = 5;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 5:
              _yield$transformRegis2 = _context9.v;
              _transformRequest = _yield$transformRegis2.transformRequest;
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context9.n = 6;
                break;
              }
              return _context9.a(2, {
                encodedTxData: this.licenseAttachmentWorkflowsClient.registerIpAndAttachPilTermsEncode(_transformRequest)
              });
            case 6:
              _context9.n = 7;
              return this.licenseAttachmentWorkflowsClient.registerIpAndAttachPilTerms(_transformRequest);
            case 7:
              txHash = _context9.v;
              _context9.n = 8;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 8:
              txReceipt = _context9.v;
              log = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0];
              _context9.n = 9;
              return this.getLicenseTermsId(licenseTerms);
            case 9:
              licenseTermsIds = _context9.v;
              _context9.n = 10;
              return setMaxLicenseTokens({
                maxLicenseTokensData: request.licenseTermsData,
                licensorIpId: log.ipId,
                licenseTermsIds: licenseTermsIds,
                totalLicenseTokenLimitHookClient: this.totalLicenseTokenLimitHookClient,
                templateAddress: this.licenseTemplateAddress
              });
            case 10:
              maxLicenseTokensTxHashes = _context9.v;
              return _context9.a(2, _objectSpread2(_objectSpread2({
                txHash: txHash,
                licenseTermsIds: licenseTermsIds
              }, maxLicenseTokensTxHashes.length > 0 && {
                maxLicenseTokensTxHashes: maxLicenseTokensTxHashes
              }), log));
            case 11:
              _context9.n = 13;
              break;
            case 12:
              _context9.p = 12;
              _t11 = _context9.v;
              return _context9.a(2, handleError(_t11, "Failed to register IP and attach PIL terms"));
            case 13:
              return _context9.a(2);
          }
        }, _callee9, this, [[0, 12]]);
      }));
      function registerIpAndAttachPilTerms(_x0) {
        return _registerIpAndAttachPilTerms.apply(this, arguments);
      }
      return registerIpAndAttachPilTerms;
    }()
    /**
     * Register the given NFT as a derivative IP with metadata without using license tokens.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerDerivativeIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.registerDerivativeIp({
     *   nftContract: '0x...',
     *   tokenId: 123n,
     *   derivData: { parentIpIds: ['0x...'], licenseTermsIds: [1n] }
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerDerivativeIpAsset({
     *   nft: { type: 'minted', nftContract: '0x...', tokenId: 123n },
     *   derivData: { parentIpIds: ['0x...'], licenseTermsIds: [1n] }
     * });
     * ```
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "registerDerivativeIp",
    value: (function () {
      var _registerDerivativeIp = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(request) {
        var _this4 = this;
        var _request$txOptions6, _request$options2, tokenId, ipIdAddress, isRegistered, _yield$transformRegis3, _transformRequest2, encodedTxData, contractCall, _t12;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.p = _context0.n) {
            case 0:
              _context0.p = 0;
              tokenId = BigInt(request.tokenId);
              _context0.n = 1;
              return getIpIdAddress({
                nftContract: request.nftContract,
                tokenId: tokenId,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 1:
              ipIdAddress = _context0.v;
              _context0.n = 2;
              return this.isRegistered(ipIdAddress);
            case 2:
              isRegistered = _context0.v;
              if (!isRegistered) {
                _context0.n = 3;
                break;
              }
              throw new Error("The NFT with id ".concat(tokenId, " is already registered as IP."));
            case 3:
              _context0.n = 4;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 4:
              _yield$transformRegis3 = _context0.v;
              _transformRequest2 = _yield$transformRegis3.transformRequest;
              encodedTxData = this.derivativeWorkflowsClient.registerIpAndMakeDerivativeEncode(_transformRequest2);
              if (!((_request$txOptions6 = request.txOptions) !== null && _request$txOptions6 !== void 0 && _request$txOptions6.encodedTxDataOnly)) {
                _context0.n = 5;
                break;
              }
              return _context0.a(2, {
                encodedTxData: encodedTxData
              });
            case 5:
              contractCall = function contractCall() {
                return _this4.derivativeWorkflowsClient.registerIpAndMakeDerivative(_transformRequest2);
              };
              return _context0.a(2, this.handleRegistrationWithFees({
                options: _objectSpread2(_objectSpread2({}, request.options), {}, {
                  wipOptions: _objectSpread2(_objectSpread2({}, (_request$options2 = request.options) === null || _request$options2 === void 0 ? void 0 : _request$options2.wipOptions), {}, {
                    useMulticallWhenPossible: false
                  })
                }),
                sender: this.walletAddress,
                spgSpenderAddress: this.derivativeWorkflowsClient.address,
                derivData: _transformRequest2.derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 6:
              _context0.p = 6;
              _t12 = _context0.v;
              return _context0.a(2, handleError(_t12, "Failed to register derivative IP"));
          }
        }, _callee0, this, [[0, 6]]);
      }));
      function registerDerivativeIp(_x1) {
        return _registerDerivativeIp.apply(this, arguments);
      }
      return registerDerivativeIp;
    }()
    /**
     * Mint an NFT from a collection and register it as a derivative IP without license tokens.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerDerivativeIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.mintAndRegisterIpAndMakeDerivative({
     *   spgNftContract: '0x...',
     *   derivData: { parentIpIds: ['0x...'], licenseTermsIds: [1n] }
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerDerivativeIpAsset({
     *   nft: { type: 'mint', spgNftContract: '0x...' },
     *   derivData: { parentIpIds: ['0x...'], licenseTermsIds: [1n] }
     * });
     * ```
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivative",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivative = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(request) {
        var _this5 = this;
        var _request$txOptions7, spgNftContract, _yield$transformRegis4, _transformRequest3, encodedTxData, contractCall, _t13;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.p = _context1.n) {
            case 0:
              _context1.p = 0;
              spgNftContract = validateAddress(request.spgNftContract);
              _context1.n = 1;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 1:
              _yield$transformRegis4 = _context1.v;
              _transformRequest3 = _yield$transformRegis4.transformRequest;
              encodedTxData = this.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivativeEncode(_transformRequest3);
              if (!((_request$txOptions7 = request.txOptions) !== null && _request$txOptions7 !== void 0 && _request$txOptions7.encodedTxDataOnly)) {
                _context1.n = 2;
                break;
              }
              return _context1.a(2, {
                encodedTxData: encodedTxData
              });
            case 2:
              contractCall = function contractCall() {
                return _this5.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivative(_transformRequest3);
              };
              return _context1.a(2, this.handleRegistrationWithFees({
                options: request.options,
                sender: this.walletAddress,
                spgSpenderAddress: this.derivativeWorkflowsClient.address,
                spgNftContract: spgNftContract,
                derivData: _transformRequest3.derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 3:
              _context1.p = 3;
              _t13 = _context1.v;
              return _context1.a(2, handleError(_t13, "Failed to mint and register IP and make derivative"));
          }
        }, _callee1, this, [[0, 3]]);
      }));
      function mintAndRegisterIpAndMakeDerivative(_x10) {
        return _mintAndRegisterIpAndMakeDerivative.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivative;
    }()
    /**
     * Batch mint an NFT from a collection and register it as a derivative IP without license tokens.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "batchMintAndRegisterIpAndMakeDerivative",
    value: (function () {
      var _batchMintAndRegisterIpAndMakeDerivative = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(request) {
        var calldata, _iterator4, _step4, arg, result, txHash, txReceipt, _t14, _t15, _t16;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.p = _context10.n) {
            case 0:
              _context10.p = 0;
              calldata = [];
              _iterator4 = _createForOfIteratorHelper(request.args);
              _context10.p = 1;
              _iterator4.s();
            case 2:
              if ((_step4 = _iterator4.n()).done) {
                _context10.n = 7;
                break;
              }
              arg = _step4.value;
              _context10.p = 3;
              _context10.n = 4;
              return this.mintAndRegisterIpAndMakeDerivative(_objectSpread2(_objectSpread2({}, arg), {}, {
                txOptions: {
                  encodedTxDataOnly: true
                }
              }));
            case 4:
              result = _context10.v;
              calldata.push(result.encodedTxData.data);
              _context10.n = 6;
              break;
            case 5:
              _context10.p = 5;
              _t14 = _context10.v;
              throw new Error(_t14.message.replace("Failed to mint and register IP and make derivative: ", "").trim());
            case 6:
              _context10.n = 2;
              break;
            case 7:
              _context10.n = 9;
              break;
            case 8:
              _context10.p = 8;
              _t15 = _context10.v;
              _iterator4.e(_t15);
            case 9:
              _context10.p = 9;
              _iterator4.f();
              return _context10.f(9);
            case 10:
              _context10.n = 11;
              return this.derivativeWorkflowsClient.multicall({
                data: calldata
              });
            case 11:
              txHash = _context10.v;
              _context10.n = 12;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 12:
              txReceipt = _context10.v;
              return _context10.a(2, {
                txHash: txHash,
                results: this.getIpIdAndTokenIdsFromEvent(txReceipt, "spgNftContract")
              });
            case 13:
              _context10.p = 13;
              _t16 = _context10.v;
              return _context10.a(2, handleError(_t16, "Failed to batch mint and register IP and make derivative"));
          }
        }, _callee10, this, [[3, 5], [1, 8, 9, 10], [0, 13]]);
      }));
      function batchMintAndRegisterIpAndMakeDerivative(_x11) {
        return _batchMintAndRegisterIpAndMakeDerivative.apply(this, arguments);
      }
      return batchMintAndRegisterIpAndMakeDerivative;
    }()
    /**
     * Mint an NFT from a SPGNFT collection and register it with metadata as an IP.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.mintAndRegisterIp({
     *   spgNftContract: '0x...',
     *   recipient: '0x...'
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerIpAsset({
     *   nft: { type: 'mint', spgNftContract: '0x...', recipient: '0x...' }
     * });
     * ```
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIp",
    value: (function () {
      var _mintAndRegisterIp = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(request) {
        var _this6 = this;
        var _request$txOptions8, _request$options3, _object, encodedTxData, contractCall, _t17;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              _context11.p = 0;
              _object = {
                spgNftContract: validateAddress(request.spgNftContract),
                recipient: validateAddress(request.recipient || this.walletAddress),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                allowDuplicates: request.allowDuplicates || true
              };
              encodedTxData = this.registrationWorkflowsClient.mintAndRegisterIpEncode(_object);
              if (!((_request$txOptions8 = request.txOptions) !== null && _request$txOptions8 !== void 0 && _request$txOptions8.encodedTxDataOnly)) {
                _context11.n = 1;
                break;
              }
              return _context11.a(2, {
                encodedTxData: encodedTxData
              });
            case 1:
              contractCall = function contractCall() {
                return _this6.registrationWorkflowsClient.mintAndRegisterIp(_object);
              };
              return _context11.a(2, this.handleRegistrationWithFees({
                sender: this.walletAddress,
                spgSpenderAddress: this.registrationWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                spgNftContract: _object.spgNftContract,
                txOptions: request.txOptions,
                options: _objectSpread2(_objectSpread2({}, request.options), {}, {
                  wipOptions: _objectSpread2(_objectSpread2({}, (_request$options3 = request.options) === null || _request$options3 === void 0 ? void 0 : _request$options3.wipOptions), {}, {
                    useMulticallWhenPossible: false
                  })
                })
              }));
            case 2:
              _context11.p = 2;
              _t17 = _context11.v;
              return _context11.a(2, handleError(_t17, "Failed to mint and register IP"));
          }
        }, _callee11, this, [[0, 2]]);
      }));
      function mintAndRegisterIp(_x12) {
        return _mintAndRegisterIp.apply(this, arguments);
      }
      return mintAndRegisterIp;
    }()
    /**
     * Batch mints NFTs from SPGNFT collections and registers them as IP assets.
     *
     * Optimizes transaction processing by grouping requests and automatically selecting the most efficient multicall strategy:
     * - Uses `multicall3` for public minting contracts.
     * - Uses `SPG's multicall` for private minting contracts.
     *
     * @remark
     * For private minting, verifies the `caller` has the `minter role` and avoids `multicall3` batching to ensure correct `msg.sender`.
     *
     * Automatically manages minting fees, including wrapping IP tokens into WIP tokens if balances are insufficient, and checks or sets allowances for all spenders as needed.
     * The `multicall` and token handling behavior can be configured via `wipOptions`.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "batchMintAndRegisterIp",
    value: (function () {
      var _batchMintAndRegisterIp = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee14(request) {
        var _this7 = this;
        var publicMintEncodedTxs, publicMintSpenders, privateMintEncodedTxs, privateMintSpenders, _iterator5, _step5, req, registrationRequest, isPublicMinting, nftMintFee, encodeTx, isMinterRole, handlePublicMintTransactions, handlePrivateMintTransactions, transactionResponses, publicMintResponse, privateMintResponse, _t18, _t19, _t20, _t21;
        return _regenerator().w(function (_context14) {
          while (1) switch (_context14.p = _context14.n) {
            case 0:
              _context14.p = 0;
              publicMintEncodedTxs = [];
              publicMintSpenders = [];
              privateMintEncodedTxs = [];
              privateMintSpenders = [];
              _iterator5 = _createForOfIteratorHelper(request.requests);
              _context14.p = 1;
              _iterator5.s();
            case 2:
              if ((_step5 = _iterator5.n()).done) {
                _context14.n = 9;
                break;
              }
              req = _step5.value;
              registrationRequest = {
                spgNftContract: validateAddress(req.spgNftContract),
                recipient: validateAddress(req.recipient || this.walletAddress),
                ipMetadata: getIpMetadataForWorkflow(req.ipMetadata),
                allowDuplicates: req.allowDuplicates || true
              };
              _context14.n = 3;
              return getPublicMinting(req.spgNftContract, this.rpcClient);
            case 3:
              isPublicMinting = _context14.v;
              _context14.n = 4;
              return calculateSPGMintFee(new SpgnftImplReadOnlyClient(this.rpcClient, registrationRequest.spgNftContract));
            case 4:
              nftMintFee = _context14.v;
              encodeTx = {
                to: this.registrationWorkflowsClient.address,
                data: viem.encodeFunctionData({
                  abi: registrationWorkflowsAbi,
                  functionName: "mintAndRegisterIp",
                  args: [registrationRequest.spgNftContract, registrationRequest.recipient, registrationRequest.ipMetadata, registrationRequest.allowDuplicates]
                })
              };
              if (!isPublicMinting) {
                _context14.n = 5;
                break;
              }
              publicMintSpenders = mergeSpenders(publicMintSpenders, nftMintFee ? [_objectSpread2({
                address: registrationRequest.spgNftContract
              }, nftMintFee)] : []);
              publicMintEncodedTxs.push(encodeTx);
              _context14.n = 8;
              break;
            case 5:
              _context14.n = 6;
              return hasMinterRole(registrationRequest.spgNftContract, this.rpcClient, this.walletAddress);
            case 6:
              isMinterRole = _context14.v;
              if (isMinterRole) {
                _context14.n = 7;
                break;
              }
              throw new Error("Caller ".concat(this.walletAddress, " does not have the minter role for ").concat(registrationRequest.spgNftContract));
            case 7:
              privateMintSpenders = mergeSpenders(privateMintSpenders, nftMintFee ? [_objectSpread2({
                address: registrationRequest.spgNftContract
              }, nftMintFee)] : []);
              privateMintEncodedTxs.push(encodeTx);
            case 8:
              _context14.n = 2;
              break;
            case 9:
              _context14.n = 11;
              break;
            case 10:
              _context14.p = 10;
              _t18 = _context14.v;
              _iterator5.e(_t18);
            case 11:
              _context14.p = 11;
              _iterator5.f();
              return _context14.f(11);
            case 12:
              handlePublicMintTransactions = /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12() {
                  return _regenerator().w(function (_context12) {
                    while (1) switch (_context12.n) {
                      case 0:
                        _context12.n = 1;
                        return contractCallWithFees({
                          options: {
                            wipOptions: request.wipOptions,
                            erc20Options: request.erc20Options
                          },
                          multicall3Address: _this7.multicall3Client.address,
                          rpcClient: _this7.rpcClient,
                          tokenSpenders: publicMintSpenders,
                          contractCall: function contractCall() {
                            return _this7.registrationWorkflowsClient.multicall({
                              data: publicMintEncodedTxs.map(function (tx) {
                                return tx.data;
                              })
                            });
                          },
                          sender: _this7.walletAddress,
                          wallet: _this7.wallet,
                          txOptions: request.txOptions,
                          encodedTxs: publicMintEncodedTxs
                        });
                      case 1:
                        return _context12.a(2, _context12.v);
                    }
                  }, _callee12);
                }));
                return function handlePublicMintTransactions() {
                  return _ref2.apply(this, arguments);
                };
              }();
              handlePrivateMintTransactions = /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13() {
                  return _regenerator().w(function (_context13) {
                    while (1) switch (_context13.n) {
                      case 0:
                        _context13.n = 1;
                        return contractCallWithFees({
                          options: {
                            wipOptions: _objectSpread2(_objectSpread2({}, request.wipOptions), {}, {
                              useMulticallWhenPossible: false
                            }),
                            erc20Options: request.erc20Options
                          },
                          multicall3Address: _this7.multicall3Client.address,
                          rpcClient: _this7.rpcClient,
                          tokenSpenders: privateMintSpenders,
                          contractCall: function contractCall() {
                            return _this7.registrationWorkflowsClient.multicall({
                              data: privateMintEncodedTxs.map(function (tx) {
                                return tx.data;
                              })
                            });
                          },
                          sender: _this7.walletAddress,
                          wallet: _this7.wallet,
                          txOptions: request.txOptions,
                          encodedTxs: privateMintEncodedTxs
                        });
                      case 1:
                        return _context13.a(2, _context13.v);
                    }
                  }, _callee13);
                }));
                return function handlePrivateMintTransactions() {
                  return _ref3.apply(this, arguments);
                };
              }();
              transactionResponses = [];
              if (!(privateMintEncodedTxs.length === 0)) {
                _context14.n = 14;
                break;
              }
              _context14.n = 13;
              return handlePublicMintTransactions();
            case 13:
              _t19 = _context14.v;
              transactionResponses = [_t19];
              _context14.n = 19;
              break;
            case 14:
              if (!(publicMintEncodedTxs.length === 0)) {
                _context14.n = 16;
                break;
              }
              _context14.n = 15;
              return handlePrivateMintTransactions();
            case 15:
              _t20 = _context14.v;
              transactionResponses = [_t20];
              _context14.n = 19;
              break;
            case 16:
              _context14.n = 17;
              return handlePublicMintTransactions();
            case 17:
              publicMintResponse = _context14.v;
              _context14.n = 18;
              return handlePrivateMintTransactions();
            case 18:
              privateMintResponse = _context14.v;
              transactionResponses = [publicMintResponse, privateMintResponse];
            case 19:
              return _context14.a(2, {
                registrationResults: transactionResponses.map(function (r) {
                  return {
                    txHash: r.txHash,
                    receipt: r.receipt,
                    ipIdsAndTokenIds: _this7.getIpIdAndTokenIdsFromEvent(r.receipt, "spgNftContract")
                  };
                })
              });
            case 20:
              _context14.p = 20;
              _t21 = _context14.v;
              return _context14.a(2, handleError(_t21, "Failed to batch mint and register IP"));
          }
        }, _callee14, this, [[1, 10, 11, 12], [0, 20]]);
      }));
      function batchMintAndRegisterIp(_x13) {
        return _batchMintAndRegisterIp.apply(this, arguments);
      }
      return batchMintAndRegisterIp;
    }()
    /**
     * Mint an NFT from a collection and register it as a derivative IP using license tokens.
     * Requires caller to have the minter role or the SPG NFT to allow public minting. Caller must own the license tokens and have approved DerivativeWorkflows to transfer them.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerDerivativeIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens({
     *   spgNftContract: '0x...',
     *   licenseTokenIds: [1n, 2n, 3n]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerDerivativeIpAsset({
     *   nft: { type: 'mint', spgNftContract: '0x...' },
     *   licenseTokenIds: [1n, 2n, 3n]
     * });
     * ```
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee16(request) {
        var _this8 = this;
        var _request$txOptions9, _request$options4, licenseTokenIds, _object2, encodedTxData, contractCall, _t22;
        return _regenerator().w(function (_context16) {
          while (1) switch (_context16.p = _context16.n) {
            case 0:
              _context16.p = 0;
              _context16.n = 1;
              return this.validateLicenseTokenIds(request.licenseTokenIds);
            case 1:
              licenseTokenIds = _context16.v;
              _object2 = {
                spgNftContract: validateAddress(request.spgNftContract),
                recipient: validateAddress(request.recipient || this.walletAddress),
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                licenseTokenIds: licenseTokenIds,
                royaltyContext: viem.zeroAddress,
                maxRts: validateMaxRts(request.maxRts),
                allowDuplicates: request.allowDuplicates || true
              };
              encodedTxData = this.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivativeWithLicenseTokensEncode(_object2);
              if (!((_request$txOptions9 = request.txOptions) !== null && _request$txOptions9 !== void 0 && _request$txOptions9.encodedTxDataOnly)) {
                _context16.n = 2;
                break;
              }
              return _context16.a(2, {
                encodedTxData: encodedTxData
              });
            case 2:
              _context16.n = 3;
              return this.approveLicenseTokensForDerivativeWorkflows(request.licenseTokenIds, request.autoApproveLicenseTokens);
            case 3:
              contractCall = /*#__PURE__*/function () {
                var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee15() {
                  return _regenerator().w(function (_context15) {
                    while (1) switch (_context15.n) {
                      case 0:
                        return _context15.a(2, _this8.derivativeWorkflowsClient.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_object2));
                    }
                  }, _callee15);
                }));
                return function contractCall() {
                  return _ref4.apply(this, arguments);
                };
              }();
              return _context16.a(2, this.handleRegistrationWithFees({
                options: _objectSpread2(_objectSpread2({}, request.options), {}, {
                  wipOptions: _objectSpread2(_objectSpread2({}, (_request$options4 = request.options) === null || _request$options4 === void 0 ? void 0 : _request$options4.wipOptions), {}, {
                    // need to disable multicall to avoid needing to transfer the license
                    // token to the multicall contract.
                    useMulticallWhenPossible: false
                  })
                }),
                sender: this.walletAddress,
                spgNftContract: _object2.spgNftContract,
                spgSpenderAddress: this.derivativeWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              }));
            case 4:
              _context16.p = 4;
              _t22 = _context16.v;
              return _context16.a(2, handleError(_t22, "Failed to mint and register IP and make derivative with license tokens"));
          }
        }, _callee16, this, [[0, 4]]);
      }));
      function mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_x14) {
        return _mintAndRegisterIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * Register the given NFT as a derivative IP using license tokens.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerDerivativeIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.registerIpAndMakeDerivativeWithLicenseTokens({
     *   nftContract: '0x...',
     *   tokenId: 123n,
     *   licenseTokenIds: [1n, 2n, 3n]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerDerivativeIpAsset({
     *   nft: { type: 'minted', nftContract: '0x...', tokenId: 123n },
     *   licenseTokenIds: [1n, 2n, 3n]
     * });
     * ```
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "registerIpAndMakeDerivativeWithLicenseTokens",
    value: (function () {
      var _registerIpAndMakeDerivativeWithLicenseTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee17(request) {
        var _request$txOptions0, tokenId, ipIdAddress, isRegistered, licenseTokenIds, calculatedDeadline, signature, _object3, txHash, receipt, log, _t23;
        return _regenerator().w(function (_context17) {
          while (1) switch (_context17.p = _context17.n) {
            case 0:
              _context17.p = 0;
              tokenId = BigInt(request.tokenId);
              _context17.n = 1;
              return getIpIdAddress({
                nftContract: request.nftContract,
                tokenId: tokenId,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 1:
              ipIdAddress = _context17.v;
              _context17.n = 2;
              return this.isRegistered(ipIdAddress);
            case 2:
              isRegistered = _context17.v;
              if (!isRegistered) {
                _context17.n = 3;
                break;
              }
              throw new Error("The NFT with id ".concat(tokenId, " is already registered as IP."));
            case 3:
              _context17.n = 4;
              return this.validateLicenseTokenIds(request.licenseTokenIds);
            case 4:
              licenseTokenIds = _context17.v;
              _context17.n = 5;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 5:
              calculatedDeadline = _context17.v;
              _context17.n = 6;
              return generateOperationSignature({
                ipIdAddress: ipIdAddress,
                methodType: SignatureMethodType.REGISTER_IP_AND_MAKE_DERIVATIVE_WITH_LICENSE_TOKENS,
                deadline: calculatedDeadline,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 6:
              signature = _context17.v;
              _context17.n = 7;
              return this.approveLicenseTokensForDerivativeWorkflows(licenseTokenIds, request.autoApproveLicenseTokens);
            case 7:
              _object3 = _objectSpread2(_objectSpread2({}, request), {}, {
                tokenId: tokenId,
                licenseTokenIds: licenseTokenIds,
                royaltyContext: viem.zeroAddress,
                ipMetadata: getIpMetadataForWorkflow(request.ipMetadata),
                sigMetadataAndRegister: {
                  signer: validateAddress(this.walletAddress),
                  deadline: calculatedDeadline,
                  signature: signature
                },
                maxRts: validateMaxRts(request.maxRts)
              });
              if (!((_request$txOptions0 = request.txOptions) !== null && _request$txOptions0 !== void 0 && _request$txOptions0.encodedTxDataOnly)) {
                _context17.n = 8;
                break;
              }
              return _context17.a(2, {
                encodedTxData: this.derivativeWorkflowsClient.registerIpAndMakeDerivativeWithLicenseTokensEncode(_object3)
              });
            case 8:
              _context17.n = 9;
              return this.derivativeWorkflowsClient.registerIpAndMakeDerivativeWithLicenseTokens(_object3);
            case 9:
              txHash = _context17.v;
              _context17.n = 10;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 10:
              receipt = _context17.v;
              log = this.getIpIdAndTokenIdsFromEvent(receipt)[0];
              return _context17.a(2, _objectSpread2({
                txHash: txHash
              }, log));
            case 11:
              _context17.n = 13;
              break;
            case 12:
              _context17.p = 12;
              _t23 = _context17.v;
              return _context17.a(2, handleError(_t23, "Failed to register IP and make derivative with license tokens"));
            case 13:
              return _context17.a(2);
          }
        }, _callee17, this, [[0, 12]]);
      }));
      function registerIpAndMakeDerivativeWithLicenseTokens(_x15) {
        return _registerIpAndMakeDerivativeWithLicenseTokens.apply(this, arguments);
      }
      return registerIpAndMakeDerivativeWithLicenseTokens;
    }()
    /**
     * Register the given NFT and attach license terms and distribute royalty
     * tokens. In order to successfully distribute royalty tokens, the first
     * license terms attached to the IP must be a commercial license.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens({
     *   nftContract: '0x...',
     *   tokenId: 123n,
     *   licenseTermsData: [{ terms: PILFlavor.commercialRemix({...}) }],
     *   royaltyShares: [{ recipient: '0x...', percentage: 100 }]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerIpAsset({
     *   nft: { type: 'minted', nftContract: '0x...', tokenId: 123n },
     *   licenseTermsData: [{ terms: PILFlavor.commercialRemix({...}) }],
     *   royaltyShares: [{ recipient: '0x...', percentage: 100 }]
     * });
     * ```
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/royalty/IRoyaltyModule.sol#L88 | `IpRoyaltyVaultDeployed`} events.
     */
    )
  }, {
    key: "registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens",
    value: (function () {
      var _registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee18(request) {
        var _getRoyaltyShares, royaltyShares, totalAmount, _yield$validateLicens2, licenseTerms, calculatedDeadline, ipIdAddress, isRegistered, _yield$transformRegis5, _transformRequest4, registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash, txReceipt, ipId, licenseTermsIds, ipRoyaltyVault, distributeRoyaltyTokensTxHash, maxLicenseTokensTxHashes, _t24;
        return _regenerator().w(function (_context18) {
          while (1) switch (_context18.p = _context18.n) {
            case 0:
              _context18.p = 0;
              _getRoyaltyShares = getRoyaltyShares(request.royaltyShares), royaltyShares = _getRoyaltyShares.royaltyShares, totalAmount = _getRoyaltyShares.totalAmount;
              _context18.n = 1;
              return validateLicenseTermsData(request.licenseTermsData, this.rpcClient, this.chainId);
            case 1:
              _yield$validateLicens2 = _context18.v;
              licenseTerms = _yield$validateLicens2.licenseTerms;
              _context18.n = 2;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 2:
              calculatedDeadline = _context18.v;
              _context18.n = 3;
              return getIpIdAddress({
                nftContract: validateAddress(request.nftContract),
                tokenId: BigInt(request.tokenId),
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 3:
              ipIdAddress = _context18.v;
              _context18.n = 4;
              return this.isRegistered(ipIdAddress);
            case 4:
              isRegistered = _context18.v;
              if (!isRegistered) {
                _context18.n = 5;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 5:
              _context18.n = 6;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 6:
              _yield$transformRegis5 = _context18.v;
              _transformRequest4 = _yield$transformRegis5.transformRequest;
              _context18.n = 7;
              return this.royaltyTokenDistributionWorkflowsClient.registerIpAndAttachPilTermsAndDeployRoyaltyVault(_transformRequest4);
            case 7:
              registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash = _context18.v;
              _context18.n = 8;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash
              }));
            case 8:
              txReceipt = _context18.v;
              ipId = this.getIpIdAndTokenIdsFromEvent(txReceipt)[0].ipId;
              _context18.n = 9;
              return this.getLicenseTermsId(licenseTerms);
            case 9:
              licenseTermsIds = _context18.v;
              ipRoyaltyVault = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(txReceipt)[0].ipRoyaltyVault;
              _context18.n = 10;
              return this.distributeRoyaltyTokens({
                ipId: ipId,
                deadline: calculatedDeadline,
                ipRoyaltyVault: ipRoyaltyVault,
                royaltyShares: royaltyShares,
                totalAmount: totalAmount,
                txOptions: request.txOptions
              });
            case 10:
              distributeRoyaltyTokensTxHash = _context18.v;
              _context18.n = 11;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: distributeRoyaltyTokensTxHash
              }));
            case 11:
              _context18.n = 12;
              return setMaxLicenseTokens({
                maxLicenseTokensData: request.licenseTermsData,
                licensorIpId: ipId,
                licenseTermsIds: licenseTermsIds,
                totalLicenseTokenLimitHookClient: this.totalLicenseTokenLimitHookClient,
                templateAddress: this.licenseTemplateAddress
              });
            case 12:
              maxLicenseTokensTxHashes = _context18.v;
              return _context18.a(2, _objectSpread2({
                registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash: registerIpAndAttachPilTermsAndDeployRoyaltyVaultTxHash,
                distributeRoyaltyTokensTxHash: distributeRoyaltyTokensTxHash,
                ipId: ipId,
                licenseTermsIds: licenseTermsIds,
                ipRoyaltyVault: ipRoyaltyVault
              }, maxLicenseTokensTxHashes.length > 0 && {
                maxLicenseTokensTxHashes: maxLicenseTokensTxHashes
              }));
            case 13:
              _context18.p = 13;
              _t24 = _context18.v;
              return _context18.a(2, handleError(_t24, "Failed to register IP and attach license terms and distribute royalty tokens"));
          }
        }, _callee18, this, [[0, 13]]);
      }));
      function registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens(_x16) {
        return _registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens;
    }()
    /**
     * Register the given NFT as a derivative IP and attach license terms and distribute royalty tokens.  In order to successfully distribute royalty tokens, the license terms attached to the IP must be
     * a commercial license.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerDerivativeIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens({
     *   nftContract: '0x...',
     *   tokenId: 123n,
     *   derivData: { parentIpIds: ['0x...'], licenseTermsIds: [1n] },
     *   royaltyShares: [{ recipient: '0x...', percentage: 100 }]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerDerivativeIpAsset({
     *   nft: { type: 'minted', nftContract: '0x...', tokenId: 123n },
     *   derivData: { parentIpIds: ['0x...'], licenseTermsIds: [1n] },
     *   royaltyShares: [{ recipient: '0x...', percentage: 100 }]
     * });
     * ```
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/royalty/IRoyaltyModule.sol#L88| `IpRoyaltyVaultDeployed`} events.
     */
    )
  }, {
    key: "registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens",
    value: (function () {
      var _registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee19(request) {
        var _this9 = this;
        var _request$options5, ipIdAddress, _yield$transformRegis6, _transformRequest5, _getRoyaltyShares2, royaltyShares, totalAmount, isRegistered, encodedTxData, contractCall, _yield$this$handleReg, txHash, ipId, tokenId, receipt, ipRoyaltyVault, distributeRoyaltyTokensTxHash, _t25;
        return _regenerator().w(function (_context19) {
          while (1) switch (_context19.p = _context19.n) {
            case 0:
              _context19.p = 0;
              _context19.n = 1;
              return getIpIdAddress({
                nftContract: validateAddress(request.nftContract),
                tokenId: BigInt(request.tokenId),
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 1:
              ipIdAddress = _context19.v;
              _context19.n = 2;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 2:
              _yield$transformRegis6 = _context19.v;
              _transformRequest5 = _yield$transformRegis6.transformRequest;
              _getRoyaltyShares2 = getRoyaltyShares(request.royaltyShares), royaltyShares = _getRoyaltyShares2.royaltyShares, totalAmount = _getRoyaltyShares2.totalAmount;
              _context19.n = 3;
              return this.isRegistered(ipIdAddress);
            case 3:
              isRegistered = _context19.v;
              if (!isRegistered) {
                _context19.n = 4;
                break;
              }
              throw new Error("The NFT with id ".concat(request.tokenId, " is already registered as IP."));
            case 4:
              encodedTxData = this.royaltyTokenDistributionWorkflowsClient.registerIpAndMakeDerivativeAndDeployRoyaltyVaultEncode(_transformRequest5);
              contractCall = function contractCall() {
                return _this9.royaltyTokenDistributionWorkflowsClient.registerIpAndMakeDerivativeAndDeployRoyaltyVault(_transformRequest5);
              };
              _context19.n = 5;
              return this.handleRegistrationWithFees({
                options: _objectSpread2(_objectSpread2({}, request.options), {}, {
                  wipOptions: _objectSpread2(_objectSpread2({}, (_request$options5 = request.options) === null || _request$options5 === void 0 ? void 0 : _request$options5.wipOptions), {}, {
                    useMulticallWhenPossible: false
                  })
                }),
                sender: this.walletAddress,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                derivData: _transformRequest5.derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: _objectSpread2({}, request.txOptions)
              });
            case 5:
              _yield$this$handleReg = _context19.v;
              txHash = _yield$this$handleReg.txHash;
              ipId = _yield$this$handleReg.ipId;
              tokenId = _yield$this$handleReg.tokenId;
              receipt = _yield$this$handleReg.receipt;
              if (!(tokenId === undefined || !ipId || !receipt)) {
                _context19.n = 6;
                break;
              }
              throw new Error("Failed to register derivative ip and deploy royalty vault.");
            case 6:
              ipRoyaltyVault = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(receipt).filter(function (item) {
                return item.ipId === ipId;
              })[0].ipRoyaltyVault;
              _context19.n = 7;
              return this.distributeRoyaltyTokens({
                ipId: ipId,
                deadline: request.deadline,
                ipRoyaltyVault: ipRoyaltyVault,
                royaltyShares: royaltyShares,
                totalAmount: totalAmount,
                txOptions: request.txOptions
              });
            case 7:
              distributeRoyaltyTokensTxHash = _context19.v;
              _context19.n = 8;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: distributeRoyaltyTokensTxHash
              }));
            case 8:
              return _context19.a(2, {
                registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokensTxHash: txHash,
                distributeRoyaltyTokensTxHash: distributeRoyaltyTokensTxHash,
                ipId: ipId,
                tokenId: tokenId,
                ipRoyaltyVault: ipRoyaltyVault
              });
            case 9:
              _context19.p = 9;
              _t25 = _context19.v;
              return _context19.a(2, handleError(_t25, "Failed to register derivative IP and attach license terms and distribute royalty tokens"));
          }
        }, _callee19, this, [[0, 9]]);
      }));
      function registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens(_x17) {
        return _registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens;
    }()
    /**
     * Mint an NFT and register the IP, attach PIL terms, and distribute royalty tokens.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens({
     *   spgNftContract: '0x...',
     *   licenseTermsData: [{ terms: PILFlavor.commercialRemix({...}) }],
     *   royaltyShares: [{ recipient: '0x...', percentage: 100 }]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerIpAsset({
     *   nft: { type: 'mint', spgNftContract: '0x...' },
     *   licenseTermsData: [{ terms: PILFlavor.commercialRemix({...}) }],
     *   royaltyShares: [{ recipient: '0x...', percentage: 100 }]
     * });
     * ```
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} and {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/royalty/IRoyaltyModule.sol#L88| `IpRoyaltyVaultDeployed`} events.
     */
    )
  }, {
    key: "mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens",
    value: (function () {
      var _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee20(request) {
        var _this0 = this;
        var _request$options6, _yield$validateLicens3, licenseTerms, _yield$transformRegis7, _transformRequest6, encodedTxData, contractCall, _yield$this$handleReg2, txHash, ipId, tokenId, receipt, licenseTermsIds, ipRoyaltyVault, maxLicenseTokensTxHashes, _t26;
        return _regenerator().w(function (_context20) {
          while (1) switch (_context20.p = _context20.n) {
            case 0:
              _context20.p = 0;
              _context20.n = 1;
              return validateLicenseTermsData(request.licenseTermsData, this.rpcClient, this.chainId);
            case 1:
              _yield$validateLicens3 = _context20.v;
              licenseTerms = _yield$validateLicens3.licenseTerms;
              _context20.n = 2;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 2:
              _yield$transformRegis7 = _context20.v;
              _transformRequest6 = _yield$transformRegis7.transformRequest;
              encodedTxData = this.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokensEncode(_transformRequest6);
              contractCall = function contractCall() {
                return _this0.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_transformRequest6);
              };
              _context20.n = 3;
              return this.handleRegistrationWithFees({
                options: _objectSpread2(_objectSpread2({}, request.options), {}, {
                  wipOptions: _objectSpread2(_objectSpread2({}, (_request$options6 = request.options) === null || _request$options6 === void 0 ? void 0 : _request$options6.wipOptions), {}, {
                    useMulticallWhenPossible: false
                  })
                }),
                sender: this.walletAddress,
                spgNftContract: _transformRequest6.spgNftContract,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              });
            case 3:
              _yield$this$handleReg2 = _context20.v;
              txHash = _yield$this$handleReg2.txHash;
              ipId = _yield$this$handleReg2.ipId;
              tokenId = _yield$this$handleReg2.tokenId;
              receipt = _yield$this$handleReg2.receipt;
              if (receipt) {
                _context20.n = 4;
                break;
              }
              return _context20.a(2, {
                txHash: txHash
              });
            case 4:
              _context20.n = 5;
              return this.getLicenseTermsId(licenseTerms);
            case 5:
              licenseTermsIds = _context20.v;
              ipRoyaltyVault = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(receipt)[0].ipRoyaltyVault;
              _context20.n = 6;
              return setMaxLicenseTokens({
                maxLicenseTokensData: request.licenseTermsData,
                licensorIpId: ipId,
                licenseTermsIds: licenseTermsIds,
                totalLicenseTokenLimitHookClient: this.totalLicenseTokenLimitHookClient,
                templateAddress: this.licenseTemplateAddress
              });
            case 6:
              maxLicenseTokensTxHashes = _context20.v;
              return _context20.a(2, _objectSpread2({
                txHash: txHash,
                ipId: ipId,
                licenseTermsIds: licenseTermsIds,
                ipRoyaltyVault: ipRoyaltyVault,
                tokenId: tokenId
              }, maxLicenseTokensTxHashes.length > 0 && {
                maxLicenseTokensTxHashes: maxLicenseTokensTxHashes
              }));
            case 7:
              _context20.p = 7;
              _t26 = _context20.v;
              return _context20.a(2, handleError(_t26, "Failed to mint and register IP and attach PIL terms and distribute royalty tokens"));
          }
        }, _callee20, this, [[0, 7]]);
      }));
      function mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_x18) {
        return _mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens;
    }()
    /**
     * Mint an NFT and register the IP, make a derivative, and distribute royalty tokens.
     *
     * @deprecated This method is deprecated. Please use the unified entry point {@link registerDerivativeIpAsset} instead.
     * This method will become internal soon.
     *
     * @example Migration Example
     * ```typescript
     * // Before (deprecated):
     * await client.ipAsset.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens({
     *   spgNftContract: '0x...',
     *   derivData: { parentIpIds: ['0x...'], licenseTermsIds: [1n] },
     *   royaltyShares: [{ recipient: '0x...', percentage: 100 }]
     * });
     *
     * // After (recommended):
     * await client.ipAsset.registerDerivativeIpAsset({
     *   nft: { type: 'mint', spgNftContract: '0x...' },
     *   derivData: { parentIpIds: ['0x...'], licenseTermsIds: [1n] },
     *   royaltyShares: [{ recipient: '0x...', percentage: 100 }]
     * });
     * ```
     *
     * Emits on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/registries/IIPAssetRegistry.sol#L17 | `IPRegistered`} event.
     */
    )
  }, {
    key: "mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens",
    value: (function () {
      var _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee21(request) {
        var _this1 = this;
        var _yield$transformRegis8, _transformRequest7, encodedTxData, contractCall, _t27;
        return _regenerator().w(function (_context21) {
          while (1) switch (_context21.p = _context21.n) {
            case 0:
              _context21.p = 0;
              _context21.n = 1;
              return transformRegistrationRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 1:
              _yield$transformRegis8 = _context21.v;
              _transformRequest7 = _yield$transformRegis8.transformRequest;
              encodedTxData = this.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokensEncode(_transformRequest7);
              contractCall = function contractCall() {
                return _this1.royaltyTokenDistributionWorkflowsClient.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_transformRequest7);
              };
              _context21.n = 2;
              return this.handleRegistrationWithFees({
                spgNftContract: _transformRequest7.spgNftContract,
                options: request.options,
                sender: this.walletAddress,
                spgSpenderAddress: this.royaltyTokenDistributionWorkflowsClient.address,
                derivData: _transformRequest7.derivData,
                encodedTxs: [encodedTxData],
                contractCall: contractCall,
                txOptions: request.txOptions
              });
            case 2:
              return _context21.a(2, _context21.v);
            case 3:
              _context21.p = 3;
              _t27 = _context21.v;
              return _context21.a(2, handleError(_t27, "Failed to mint and register IP and make derivative and distribute royalty tokens"));
          }
        }, _callee21, this, [[0, 3]]);
      }));
      function mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_x19) {
        return _mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens.apply(this, arguments);
      }
      return mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens;
    }())
  }, {
    key: "distributeRoyaltyTokens",
    value: function () {
      var _distributeRoyaltyTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee22(request) {
        var _yield$transferDistri, transformRequest, txHash;
        return _regenerator().w(function (_context22) {
          while (1) switch (_context22.n) {
            case 0:
              _context22.n = 1;
              return transferDistributeRoyaltyTokensRequest({
                request: request,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 1:
              _yield$transferDistri = _context22.v;
              transformRequest = _yield$transferDistri.transformRequest;
              _context22.n = 2;
              return this.royaltyTokenDistributionWorkflowsClient.distributeRoyaltyTokens(transformRequest);
            case 2:
              txHash = _context22.v;
              _context22.n = 3;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 3:
              return _context22.a(2, txHash);
          }
        }, _callee22, this);
      }));
      function distributeRoyaltyTokens(_x20) {
        return _distributeRoyaltyTokens.apply(this, arguments);
      }
      return distributeRoyaltyTokens;
    }()
  }, {
    key: "isRegistered",
    value: function () {
      var _isRegistered = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee23(ipId) {
        return _regenerator().w(function (_context23) {
          while (1) switch (_context23.n) {
            case 0:
              _context23.n = 1;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(ipId)
              });
            case 1:
              return _context23.a(2, _context23.v);
          }
        }, _callee23, this);
      }));
      function isRegistered(_x21) {
        return _isRegistered.apply(this, arguments);
      }
      return isRegistered;
    }()
    /**
     * Batch register multiple IP assets in optimized transactions, supporting various registration methods:
     * - {@link mintAndRegisterIpAndMakeDerivative}
     * - {@link mintAndRegisterIpAssetWithPilTerms}
     * - {@link mintAndRegisterIpAndAttachPILTermsAndDistributeRoyaltyTokens}
     * - {@link mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens}
     * - {@link registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens}
     * - {@link registerIpAndAttachPilTerms}
     * - {@link registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens}
     * - {@link registerDerivativeIp}
     *
     * This method optimizes transaction processing by:
     * 1. Transforming all requests into appropriate workflow formats
     * 2. Grouping related workflow requests together
     * 3. Intelligently selecting between multicall3 and SPG's multicall based on compatibility
     *
     * The batching strategy significantly reduces gas costs and improves transaction throughput
     * by minimizing the number of separate blockchain transactions. It also handles complex
     * workflows like royalty token distribution automatically.
     *
     * The method supports automatic token handling for minting fees:
     * - If the wallet's IP token balance is insufficient to cover minting fees, it automatically wraps native IP tokens into WIP tokens.
     * - It checks allowances for all required spenders and automatically approves them if their current allowance is lower than needed.
     * - These automatic processes can be configured through the `options` parameter to control behavior like multicall usage and approval settings.
     *
     * @remark Multicall selection logic:
     *
     * 1. For `mintAndRegister*` methods:
     *    - When `spgNftContract` has public minting disabled: Uses SPG's multicall
     *    - When `spgNftContract` has public minting enabled: Uses multicall3
     *    - Exception: {@link mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens} always uses
     *      SPG's multicall due to contract logic
     *
     * 2. For `register*` methods:
     *    - Always uses SPG's multicall for batching registration operations
     *
     * Additionally, when multicall3 methods are used, transactions maybe cannot use multicall3 based on fee sufficiency and the presence of ERC20 tokens due to `msg.sender` context limitations.
     */
  }, {
    key: "batchRegisterIpAssetsWithOptimizedWorkflows",
    value: (function () {
      var _batchRegisterIpAssetsWithOptimizedWorkflows = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee24(request) {
        var transferWorkflowRequests, _iterator6, _step6, req, res, royaltyDistributionRequests, _yield$handleMultical, txResponses, aggregateRegistrationRequest, responses, royaltyTokensDistributionRequests, _iterator7, _step7, _step7$value, txHash, receipt, iPRegisteredLog, ipRoyaltyVaultEvent, _yield$prepareRoyalty, requests, ipRoyaltyVaults, distributeRoyaltyTokensTxHashes, _yield$handleMultical2, txResponse, registrationResults, _t28, _t29, _t30;
        return _regenerator().w(function (_context24) {
          while (1) switch (_context24.p = _context24.n) {
            case 0:
              _context24.p = 0;
              // Transform requests into workflow format
              transferWorkflowRequests = [];
              _iterator6 = _createForOfIteratorHelper(request.requests);
              _context24.p = 1;
              _iterator6.s();
            case 2:
              if ((_step6 = _iterator6.n()).done) {
                _context24.n = 5;
                break;
              }
              req = _step6.value;
              _context24.n = 3;
              return transformRegistrationRequest({
                request: req,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 3:
              res = _context24.v;
              transferWorkflowRequests.push(res);
            case 4:
              _context24.n = 2;
              break;
            case 5:
              _context24.n = 7;
              break;
            case 6:
              _context24.p = 6;
              _t28 = _context24.v;
              _iterator6.e(_t28);
            case 7:
              _context24.p = 7;
              _iterator6.f();
              return _context24.f(7);
            case 8:
              /**
               * Extract royalty distribution requests from workflow responses that contain royalty shares
               * We need to handle `distributeRoyaltyTokens` separately because this method requires
               * a signature with the royalty vault address, which is only available after the initial registration
               */
              royaltyDistributionRequests = transferWorkflowRequests.filter(function (res) {
                var _res$extraData;
                return (_res$extraData = res.extraData) === null || _res$extraData === void 0 ? void 0 : _res$extraData.royaltyShares;
              }).map(function (res) {
                return {
                  nftContract: res.transformRequest.nftContract,
                  tokenId: res.transformRequest.tokenId,
                  royaltyShares: res.extraData.royaltyShares,
                  deadline: res.extraData.deadline
                };
              }); // Process initial registration transactions
              _context24.n = 9;
              return handleMulticall({
                transferWorkflowRequests: transferWorkflowRequests,
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                walletAddress: this.walletAddress,
                options: request.options,
                chainId: this.chainId
              });
            case 9:
              _yield$handleMultical = _context24.v;
              txResponses = _yield$handleMultical.response;
              aggregateRegistrationRequest = _yield$handleMultical.aggregateRegistrationRequest;
              responses = [];
              royaltyTokensDistributionRequests = []; // Process each transaction response
              _iterator7 = _createForOfIteratorHelper(txResponses);
              _context24.p = 10;
              _iterator7.s();
            case 11:
              if ((_step7 = _iterator7.n()).done) {
                _context24.n = 14;
                break;
              }
              _step7$value = _step7.value, txHash = _step7$value.txHash, receipt = _step7$value.receipt;
              iPRegisteredLog = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(receipt);
              ipRoyaltyVaultEvent = this.royaltyModuleEventClient.parseTxIpRoyaltyVaultDeployedEvent(receipt); // Prepare royalty distribution if needed
              _context24.n = 12;
              return prepareRoyaltyTokensDistributionRequests({
                royaltyDistributionRequests: royaltyDistributionRequests,
                ipRegisteredLog: iPRegisteredLog,
                ipRoyaltyVault: ipRoyaltyVaultEvent,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 12:
              _yield$prepareRoyalty = _context24.v;
              requests = _yield$prepareRoyalty.requests;
              ipRoyaltyVaults = _yield$prepareRoyalty.ipRoyaltyVaults;
              royaltyTokensDistributionRequests.push.apply(royaltyTokensDistributionRequests, _toConsumableArray(requests));
              responses.push({
                txHash: txHash,
                receipt: receipt,
                ipRoyaltyVault: ipRoyaltyVaults,
                ipAssetsWithLicenseTerms: iPRegisteredLog.map(function (log) {
                  return {
                    ipId: log.ipId,
                    tokenId: log.tokenId
                  };
                })
              });
            case 13:
              _context24.n = 11;
              break;
            case 14:
              _context24.n = 16;
              break;
            case 15:
              _context24.p = 15;
              _t29 = _context24.v;
              _iterator7.e(_t29);
            case 16:
              _context24.p = 16;
              _iterator7.f();
              return _context24.f(16);
            case 17:
              if (!(royaltyTokensDistributionRequests.length > 0)) {
                _context24.n = 19;
                break;
              }
              _context24.n = 18;
              return handleMulticall({
                transferWorkflowRequests: royaltyTokensDistributionRequests,
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                walletAddress: this.walletAddress,
                options: request.options,
                chainId: this.chainId
              });
            case 18:
              _yield$handleMultical2 = _context24.v;
              txResponse = _yield$handleMultical2.response;
              distributeRoyaltyTokensTxHashes = txResponse.map(function (tx) {
                return tx.txHash;
              });
            case 19:
              _context24.n = 20;
              return this.populateLicenseAndTokenIdsForRegistrationResults(responses, aggregateRegistrationRequest);
            case 20:
              registrationResults = _context24.v;
              return _context24.a(2, _objectSpread2({
                registrationResults: registrationResults
              }, distributeRoyaltyTokensTxHashes && {
                distributeRoyaltyTokensTxHashes: distributeRoyaltyTokensTxHashes
              }));
            case 21:
              _context24.p = 21;
              _t30 = _context24.v;
              return _context24.a(2, handleError(_t30, "Failed to batch register IP assets with optimized workflows"));
          }
        }, _callee24, this, [[10, 15, 16, 17], [1, 6, 7, 8], [0, 21]]);
      }));
      function batchRegisterIpAssetsWithOptimizedWorkflows(_x22) {
        return _batchRegisterIpAssetsWithOptimizedWorkflows.apply(this, arguments);
      }
      return batchRegisterIpAssetsWithOptimizedWorkflows;
    }()
    /**
     * Register an IP asset, supporting both minted and mint-on-demand NFTs, with optional `licenseTermsData` and `royaltyShares`.
     *
     * This method automatically selects and calls the appropriate workflow from 6 available methods based on your input parameters.
     * Here are three common usage patterns:
     *
     * **1. Minted NFT with License Terms and Royalty Distribution:**
     * ```typescript
     * const result = await client.ipAsset.registerIpAsset({
     *   nft: { type: "minted", nftContract: "0x...", tokenId: 1n },
     *   licenseTermsData: [
     *     {
     *       terms: PILFlavor.commercialRemix({
     *         defaultMintingFee: 10000n,
     *         commercialRevShare: 100,
     *         currency: "0x..."
     *       })
     *     }
     *   ],
     *   royaltyShares: [
     *     { recipient: "0x...", percentage: 100 }
     *   ]
     * });
     * ```
     *
     * **2. Minted NFT with Basic License Terms:**
     * ```typescript
     * const result = await client.ipAsset.registerIpAsset({
     *   nft: { type: "minted", nftContract: "0x...", tokenId: 1n },
     *   licenseTermsData: [
     *     {
     *       terms: PILFlavor.nonCommercialSocialRemixing()
     *     }
     *   ]
     * });
     * ```
     *
     * **3. Mint NFT with IP Asset:**
     * ```typescript
     * const result = await client.ipAsset.registerIpAsset({
     *   nft: { type: "mint", spgNftContract: "0x...", recipient: "0x...", allowDuplicates: false },
     * });
     * ```
     *
     * **Supported Workflows (6 methods automatically selected based on parameters):**
     * - {@link registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens} - Register IP with license terms and royalty distribution
     * - {@link registerIpAndAttachPilTerms} - Register IP with license terms
     * - {@link register} - Register basic IP asset
     * - {@link mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens} - Mint NFT and register IP with license terms and royalty distribution
     * - {@link mintAndRegisterIpAssetWithPilTerms} - Mint NFT and register IP with license terms
     * - {@link mintAndRegisterIp} - Mint NFT and register basic IP asset
     *
     * **Automatic Token Handling:**
     * - If the wallet's IP token balance is insufficient to cover minting fees, it automatically wraps native IP tokens into WIP tokens.
     * - It checks allowances for all required spenders and automatically approves them if their current allowance is lower than needed.
     * - These automatic processes can be configured through the `options` parameter to control behavior like multicall usage and approval settings.
     *
     * @throws {Error} If the NFT type is invalid.
     * @throws {Error} If `licenseTermsData` is not provided when `royaltyShares` are specified.
     *
     */
    )
  }, {
    key: "registerIpAsset",
    value: (function () {
      var _registerIpAsset = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee25(request) {
        var nft, licenseTermsData, royaltyShares, _t31;
        return _regenerator().w(function (_context25) {
          while (1) switch (_context25.p = _context25.n) {
            case 0:
              _context25.p = 0;
              nft = request.nft, licenseTermsData = request.licenseTermsData, royaltyShares = request.royaltyShares; // Validate royalty shares without license terms
              if (!(royaltyShares && !licenseTermsData)) {
                _context25.n = 1;
                break;
              }
              throw new Error("License terms data must be provided when royalty shares are specified.");
            case 1:
              if (!(nft.type === "minted")) {
                _context25.n = 3;
                break;
              }
              _context25.n = 2;
              return this.handleMintedNftRegistration(request);
            case 2:
              return _context25.a(2, _context25.v);
            case 3:
              if (!(nft.type === "mint")) {
                _context25.n = 5;
                break;
              }
              _context25.n = 4;
              return this.handleMintNftRegistration(request);
            case 4:
              return _context25.a(2, _context25.v);
            case 5:
              throw new Error("Invalid NFT type");
            case 6:
              _context25.n = 8;
              break;
            case 7:
              _context25.p = 7;
              _t31 = _context25.v;
              return _context25.a(2, handleError(_t31, "Failed to register IP Asset"));
            case 8:
              return _context25.a(2);
          }
        }, _callee25, this, [[0, 7]]);
      }));
      function registerIpAsset(_x23) {
        return _registerIpAsset.apply(this, arguments);
      }
      return registerIpAsset;
    }()
    /**
     * Register a derivative IP asset, supporting both minted and mint-on-demand NFTs, with optional `derivData`, `royaltyShares` and `licenseTokenIds`.
     *
     * This method automatically selects and calls the appropriate workflow from 6 available methods based on your input parameters.
     * Here are three common usage patterns:
     *
     * **1. Minted NFT with License Terms and Royalty Distribution:**
     * ```typescript
     * const result = await client.ipAsset.registerDerivativeIpAsset({
     *   nft: { type: "minted", nftContract: "0x...", tokenId: 1n },
     *   derivData: {
     *     parentIpIds: ["0x..."],
     *     licenseTermsIds: [1n],
     *     maxMintingFee: 10000n,
     *     maxRevenueShare: 100
     *   },
     *   royaltyShares: [
     *     { recipient: "0x...", percentage: 100 }
     *   ]
     * });
     * ```
     *
     * **2. Minted NFT with Basic Derivative Registration:**
     * ```typescript
     * const result = await client.ipAsset.registerDerivativeIpAsset({
     *   nft: { type: "minted", nftContract: "0x...", tokenId: 1n },
     *   derivData: {
     *     parentIpIds: ["0x..."],
     *     licenseTermsIds: [1n],
     *     maxMintingFee: 10000n,
     *     maxRevenueShare: 100
     *   }
     * });
     * ```
     *
     * **3. Mint NFT with License Token IDs:**
     * ```typescript
     * const result = await client.ipAsset.registerDerivativeIpAsset({
     *   nft: { type: "mint", spgNftContract: "0x...", recipient: "0x...", allowDuplicates: false },
     *   licenseTokenIds: [1, 2, 3],
     * });
     * ```
     *
     * **Supported Workflows (6 methods automatically selected based on parameters):**
     * - {@link registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens} - Register derivative with license terms and royalty distribution
     * - {@link registerDerivativeIp} - Register derivative with basic derivative data
     * - {@link registerIpAndMakeDerivativeWithLicenseTokens} - Register derivative using existing license tokens
     * - {@link mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens} - Mint NFT and register as derivative with royalty distribution
     * - {@link mintAndRegisterIpAndMakeDerivative} - Mint NFT and register as derivative
     * - {@link mintAndRegisterIpAndMakeDerivativeWithLicenseTokens} - Mint NFT and register as derivative using license tokens
     *
     * **Automatic Token Handling:**
     * - If the wallet's IP token balance is insufficient to cover minting fees, it automatically wraps native IP tokens into WIP tokens.
     * - It checks allowances for all required spenders and automatically approves them if their current allowance is lower than needed.
     * - These automatic processes can be configured through the `options` parameter to control behavior like multicall usage and approval settings.
     *
     * @throws {Error} If `derivData` is not provided when `royaltyShares` are provided.
     * @throws {Error} If neither `derivData` nor `licenseTokenIds` are provided.
     * @throws {Error} If the NFT type is invalid.
     */
    )
  }, {
    key: "registerDerivativeIpAsset",
    value: (function () {
      var _registerDerivativeIpAsset = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee26(request) {
        var nft, licenseTokenIds, royaltyShares, derivData, hasDerivData, hasLicenseTokens, _t32;
        return _regenerator().w(function (_context26) {
          while (1) switch (_context26.p = _context26.n) {
            case 0:
              _context26.p = 0;
              nft = request.nft, licenseTokenIds = request.licenseTokenIds, royaltyShares = request.royaltyShares, derivData = request.derivData;
              if (!(royaltyShares && !derivData)) {
                _context26.n = 1;
                break;
              }
              throw new Error("derivData must be provided when royaltyShares are provided.");
            case 1:
              // Validate that at least one valid combination is provided
              hasDerivData = !!derivData;
              hasLicenseTokens = !!(licenseTokenIds && licenseTokenIds.length > 0);
              if (!(!hasDerivData && !hasLicenseTokens)) {
                _context26.n = 2;
                break;
              }
              throw new Error("Either derivData or licenseTokenIds must be provided.");
            case 2:
              if (!(nft.type === "minted")) {
                _context26.n = 4;
                break;
              }
              _context26.n = 3;
              return this.handleMintedNftDerivativeRegistration(request);
            case 3:
              return _context26.a(2, _context26.v);
            case 4:
              if (!(nft.type === "mint")) {
                _context26.n = 6;
                break;
              }
              _context26.n = 5;
              return this.handleMintNftDerivativeRegistration(request);
            case 5:
              return _context26.a(2, _context26.v);
            case 6:
              throw new Error("Invalid NFT type.");
            case 7:
              _context26.n = 9;
              break;
            case 8:
              _context26.p = 8;
              _t32 = _context26.v;
              return _context26.a(2, handleError(_t32, "Failed to register derivative IP Asset"));
            case 9:
              return _context26.a(2);
          }
        }, _callee26, this, [[0, 8]]);
      }));
      function registerDerivativeIpAsset(_x24) {
        return _registerDerivativeIpAsset.apply(this, arguments);
      }
      return registerDerivativeIpAsset;
    }()
    /**
     * Handles derivative registration for already minted NFTs with optional `derivData`, `royaltyShares` and `licenseTokenIds`.
     *
     * Supports the following workflows:
     * - {@link registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens}
     * - {@link registerDerivativeIp}
     * - {@link registerIpAndMakeDerivativeWithLicenseTokens}
     */
    )
  }, {
    key: "handleMintedNftDerivativeRegistration",
    value: (function () {
      var _handleMintedNftDerivativeRegistration = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee27(request) {
        var nft, royaltyShares, derivData, maxRts, licenseTokenIds, deadline, txOptions, options, ipMetadata, baseParams;
        return _regenerator().w(function (_context27) {
          while (1) switch (_context27.n) {
            case 0:
              nft = request.nft, royaltyShares = request.royaltyShares, derivData = request.derivData, maxRts = request.maxRts, licenseTokenIds = request.licenseTokenIds, deadline = request.deadline, txOptions = request.txOptions, options = request.options, ipMetadata = request.ipMetadata;
              baseParams = {
                nftContract: nft.nftContract,
                tokenId: nft.tokenId,
                ipMetadata: ipMetadata,
                deadline: deadline,
                txOptions: txOptions,
                options: options
              };
              if (!(royaltyShares && derivData)) {
                _context27.n = 1;
                break;
              }
              return _context27.a(2, this.registerDerivativeIpAndAttachLicenseTermsAndDistributeRoyaltyTokens(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                royaltyShares: royaltyShares,
                derivData: derivData
              })));
            case 1:
              if (!derivData) {
                _context27.n = 2;
                break;
              }
              return _context27.a(2, this.registerDerivativeIp(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                derivData: derivData
              })));
            case 2:
              return _context27.a(2, this.registerIpAndMakeDerivativeWithLicenseTokens(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                licenseTokenIds: licenseTokenIds,
                maxRts: maxRts,
                autoApproveLicenseTokens: request.autoApproveLicenseTokens
              })));
          }
        }, _callee27, this);
      }));
      function handleMintedNftDerivativeRegistration(_x25) {
        return _handleMintedNftDerivativeRegistration.apply(this, arguments);
      }
      return handleMintedNftDerivativeRegistration;
    }()
    /**
     * Handles derivative registration for minted NFTs with optional `derivData`, `royaltyShares` and `licenseTokenIds`.
     *
     * Supports the following workflows:
     * - {@link mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens}
     * - {@link mintAndRegisterIpAndMakeDerivative}
     * - {@link mintAndRegisterIpAndMakeDerivativeWithLicenseTokens}
     */
    )
  }, {
    key: "handleMintNftDerivativeRegistration",
    value: (function () {
      var _handleMintNftDerivativeRegistration = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee28(request) {
        var nft, royaltyShares, derivData, maxRts, licenseTokenIds, txOptions, options, ipMetadata, baseParams;
        return _regenerator().w(function (_context28) {
          while (1) switch (_context28.n) {
            case 0:
              nft = request.nft, royaltyShares = request.royaltyShares, derivData = request.derivData, maxRts = request.maxRts, licenseTokenIds = request.licenseTokenIds, txOptions = request.txOptions, options = request.options, ipMetadata = request.ipMetadata;
              baseParams = {
                spgNftContract: nft.spgNftContract,
                recipient: nft.recipient,
                allowDuplicates: nft.allowDuplicates,
                ipMetadata: ipMetadata,
                txOptions: txOptions,
                options: options
              };
              if (!(royaltyShares && derivData)) {
                _context28.n = 1;
                break;
              }
              return _context28.a(2, this.mintAndRegisterIpAndMakeDerivativeAndDistributeRoyaltyTokens(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                royaltyShares: royaltyShares,
                derivData: derivData
              })));
            case 1:
              if (!derivData) {
                _context28.n = 2;
                break;
              }
              return _context28.a(2, this.mintAndRegisterIpAndMakeDerivative(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                derivData: derivData
              })));
            case 2:
              return _context28.a(2, this.mintAndRegisterIpAndMakeDerivativeWithLicenseTokens(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                licenseTokenIds: licenseTokenIds,
                maxRts: maxRts,
                autoApproveLicenseTokens: request.autoApproveLicenseTokens
              })));
          }
        }, _callee28, this);
      }));
      function handleMintNftDerivativeRegistration(_x26) {
        return _handleMintNftDerivativeRegistration.apply(this, arguments);
      }
      return handleMintNftDerivativeRegistration;
    }()
    /**
     * Link a derivative IP asset using parent IP's license terms or license tokens.
     *
     * Supports the following workflows:
     * - {@link registerDerivative}
     * - {@link registerDerivativeWithLicenseTokens}
     *
     * @example
     * ```typescript
     * const result = await client.ipAsset.linkDerivative({
     *   licenseTokenIds: [1, 2, 3],
     *   childIpId: "0x...",
     * });
     * ```
     *
     * @example
     * ```typescript
     * const result = await client.ipAsset.linkDerivative({
     *   parentIpIds: ["0x..."],
     *   licenseTermsIds: [1],
     *   childIpId: "0x...",
     * });
     * ```
     *
     * **Automatic Token Handling:**
     * - If the wallet's IP token balance is insufficient to cover minting fees, it automatically wraps native IP tokens into WIP tokens.
     * - It checks allowances for all required spenders and automatically approves them if their current allowance is lower than needed.
     * - These automatic processes can be configured through the `options` parameter to control behavior like multicall usage and approval settings.
     */
    )
  }, {
    key: "linkDerivative",
    value: (function () {
      var _linkDerivative = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee29(request) {
        var _t33;
        return _regenerator().w(function (_context29) {
          while (1) switch (_context29.p = _context29.n) {
            case 0:
              _context29.p = 0;
              if (!("parentIpIds" in request)) {
                _context29.n = 1;
                break;
              }
              return _context29.a(2, this.registerDerivative(request));
            case 1:
              return _context29.a(2, this.registerDerivativeWithLicenseTokens(request));
            case 2:
              _context29.n = 4;
              break;
            case 3:
              _context29.p = 3;
              _t33 = _context29.v;
              return _context29.a(2, handleError(_t33, "Failed to link derivative"));
            case 4:
              return _context29.a(2);
          }
        }, _callee29, this, [[0, 3]]);
      }));
      function linkDerivative(_x27) {
        return _linkDerivative.apply(this, arguments);
      }
      return linkDerivative;
    }()
    /**
     * Handles registration for already minted NFTs with optional license terms and royalty shares.
     *
     * Supports the following workflows:
     * - {@link registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens}
     * - {@link registerIpAndAttachPilTerms}
     * - {@link register}
     */
    )
  }, {
    key: "handleMintedNftRegistration",
    value: (function () {
      var _handleMintedNftRegistration = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee30(request) {
        var nft, ipMetadata, txOptions, licenseTermsData, royaltyShares, deadline, baseParams;
        return _regenerator().w(function (_context30) {
          while (1) switch (_context30.n) {
            case 0:
              nft = request.nft, ipMetadata = request.ipMetadata, txOptions = request.txOptions, licenseTermsData = request.licenseTermsData, royaltyShares = request.royaltyShares, deadline = request.deadline;
              baseParams = {
                nftContract: nft.nftContract,
                tokenId: nft.tokenId,
                ipMetadata: ipMetadata,
                deadline: deadline,
                txOptions: txOptions
              };
              if (!(licenseTermsData && royaltyShares)) {
                _context30.n = 1;
                break;
              }
              return _context30.a(2, this.registerIPAndAttachLicenseTermsAndDistributeRoyaltyTokens(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                licenseTermsData: licenseTermsData,
                royaltyShares: royaltyShares
              })));
            case 1:
              if (!licenseTermsData) {
                _context30.n = 2;
                break;
              }
              return _context30.a(2, this.registerIpAndAttachPilTerms(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                licenseTermsData: licenseTermsData
              })));
            case 2:
              return _context30.a(2, this.register(_objectSpread2({}, baseParams)));
          }
        }, _callee30, this);
      }));
      function handleMintedNftRegistration(_x28) {
        return _handleMintedNftRegistration.apply(this, arguments);
      }
      return handleMintedNftRegistration;
    }()
    /**
     * Handles minting and registration of new NFTs with optional license terms and royalty shares.
     *
     * Supports the following workflows:
     * - {@link mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens}
     * - {@link mintAndRegisterIpAssetWithPilTerms}
     * - {@link mintAndRegisterIp}
     */
    )
  }, {
    key: "handleMintNftRegistration",
    value: (function () {
      var _handleMintNftRegistration = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee31(request) {
        var nft, ipMetadata, txOptions, options, licenseTermsData, royaltyShares, baseParams;
        return _regenerator().w(function (_context31) {
          while (1) switch (_context31.n) {
            case 0:
              nft = request.nft, ipMetadata = request.ipMetadata, txOptions = request.txOptions, options = request.options, licenseTermsData = request.licenseTermsData, royaltyShares = request.royaltyShares;
              baseParams = {
                spgNftContract: nft.spgNftContract,
                recipient: nft.recipient,
                allowDuplicates: nft.allowDuplicates,
                ipMetadata: ipMetadata,
                txOptions: txOptions,
                options: options
              };
              if (!(licenseTermsData && royaltyShares)) {
                _context31.n = 1;
                break;
              }
              return _context31.a(2, this.mintAndRegisterIpAndAttachPilTermsAndDistributeRoyaltyTokens(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                licenseTermsData: licenseTermsData,
                royaltyShares: royaltyShares
              })));
            case 1:
              if (!licenseTermsData) {
                _context31.n = 2;
                break;
              }
              return _context31.a(2, this.mintAndRegisterIpAssetWithPilTerms(_objectSpread2(_objectSpread2({}, baseParams), {}, {
                licenseTermsData: licenseTermsData
              })));
            case 2:
              return _context31.a(2, this.mintAndRegisterIp(_objectSpread2({}, baseParams)));
          }
        }, _callee31, this);
      }));
      function handleMintNftRegistration(_x29) {
        return _handleMintNftRegistration.apply(this, arguments);
      }
      return handleMintNftRegistration;
    }())
  }, {
    key: "getLicenseTermsId",
    value: function () {
      var _getLicenseTermsId = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee32(licenseTerms) {
        var licenseTermsIds, _iterator8, _step8, licenseTerm, licenseRes, _t34;
        return _regenerator().w(function (_context32) {
          while (1) switch (_context32.p = _context32.n) {
            case 0:
              licenseTermsIds = [];
              _iterator8 = _createForOfIteratorHelper(licenseTerms);
              _context32.p = 1;
              _iterator8.s();
            case 2:
              if ((_step8 = _iterator8.n()).done) {
                _context32.n = 5;
                break;
              }
              licenseTerm = _step8.value;
              _context32.n = 3;
              return this.licenseTemplateClient.getLicenseTermsId({
                terms: licenseTerm
              });
            case 3:
              licenseRes = _context32.v;
              licenseTermsIds.push(licenseRes.selectedLicenseTermsId);
            case 4:
              _context32.n = 2;
              break;
            case 5:
              _context32.n = 7;
              break;
            case 6:
              _context32.p = 6;
              _t34 = _context32.v;
              _iterator8.e(_t34);
            case 7:
              _context32.p = 7;
              _iterator8.f();
              return _context32.f(7);
            case 8:
              return _context32.a(2, licenseTermsIds);
          }
        }, _callee32, this, [[1, 6, 7, 8]]);
      }));
      function getLicenseTermsId(_x30) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
  }, {
    key: "validateLicenseTokenIds",
    value: function () {
      var _validateLicenseTokenIds = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee33(licenseTokenIds) {
        var newLicenseTokenIds, _iterator9, _step9, licenseTokenId, tokenOwnerAddress, _t35;
        return _regenerator().w(function (_context33) {
          while (1) switch (_context33.p = _context33.n) {
            case 0:
              if (!(licenseTokenIds.length === 0)) {
                _context33.n = 1;
                break;
              }
              throw new Error("License token IDs must be provided.");
            case 1:
              newLicenseTokenIds = licenseTokenIds.map(function (id) {
                return BigInt(id);
              });
              _iterator9 = _createForOfIteratorHelper(newLicenseTokenIds);
              _context33.p = 2;
              _iterator9.s();
            case 3:
              if ((_step9 = _iterator9.n()).done) {
                _context33.n = 6;
                break;
              }
              licenseTokenId = _step9.value;
              _context33.n = 4;
              return this.licenseTokenReadOnlyClient.ownerOf({
                tokenId: licenseTokenId
              });
            case 4:
              tokenOwnerAddress = _context33.v;
              if (tokenOwnerAddress) {
                _context33.n = 5;
                break;
              }
              throw new Error("License token id ".concat(licenseTokenId, " must be owned by the caller."));
            case 5:
              _context33.n = 3;
              break;
            case 6:
              _context33.n = 8;
              break;
            case 7:
              _context33.p = 7;
              _t35 = _context33.v;
              _iterator9.e(_t35);
            case 8:
              _context33.p = 8;
              _iterator9.f();
              return _context33.f(8);
            case 9:
              return _context33.a(2, newLicenseTokenIds);
          }
        }, _callee33, this, [[2, 7, 8, 9]]);
      }));
      function validateLicenseTokenIds(_x31) {
        return _validateLicenseTokenIds.apply(this, arguments);
      }
      return validateLicenseTokenIds;
    }()
  }, {
    key: "getIpIdAndTokenIdsFromEvent",
    value: function getIpIdAndTokenIdsFromEvent(txReceipt, key) {
      var ipRegisteredLog = this.ipAssetRegistryClient.parseTxIpRegisteredEvent(txReceipt);
      return ipRegisteredLog.map(function (log) {
        var baseResult = {
          ipId: log.ipId,
          tokenId: log.tokenId
        };
        if (key) {
          return _objectSpread2(_objectSpread2({}, baseResult), {}, _defineProperty({}, key, log.tokenContract));
        }
        return baseResult;
      });
    }
  }, {
    key: "handleRegistrationWithFees",
    value: function () {
      var _handleRegistrationWithFees = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee34(_ref5) {
        var _wipOptions$useMultic, _this$getIpIdAndToken, _event$ipId, _event$tokenId;
        var sender, derivData, spgNftContract, spgSpenderAddress, txOptions, options, encodedTxs, contractCall, tokenSpenders, wipOptions, useMulticallWhenPossible, nftMintFee, publicMinting, mintFees, _iterator0, _step0, mintFee, _yield$contractCallWi, txHash, receipt, event;
        return _regenerator().w(function (_context34) {
          while (1) switch (_context34.n) {
            case 0:
              sender = _ref5.sender, derivData = _ref5.derivData, spgNftContract = _ref5.spgNftContract, spgSpenderAddress = _ref5.spgSpenderAddress, txOptions = _ref5.txOptions, options = _ref5.options, encodedTxs = _ref5.encodedTxs, contractCall = _ref5.contractCall;
              tokenSpenders = [];
              wipOptions = options === null || options === void 0 ? void 0 : options.wipOptions;
              useMulticallWhenPossible = (_wipOptions$useMultic = wipOptions === null || wipOptions === void 0 ? void 0 : wipOptions.useMulticallWhenPossible) !== null && _wipOptions$useMultic !== void 0 ? _wipOptions$useMultic : true; // get spg minting fee
              if (!spgNftContract) {
                _context34.n = 3;
                break;
              }
              _context34.n = 1;
              return calculateSPGMintFee(new SpgnftImplReadOnlyClient(this.rpcClient, spgNftContract));
            case 1:
              nftMintFee = _context34.v;
              _context34.n = 2;
              return getPublicMinting(spgNftContract, this.rpcClient);
            case 2:
              publicMinting = _context34.v;
              /**
               * If the SPG NFT contract's public minting is disabled, we need to check if the caller has the `minter role`.
               * When public minting is disabled, we can't use multicall because we need to perform additional role checks
               * that aren't compatible with batched transactions.
               *
               * This is because role-based access control requires the transaction's msg.sender to be verified directly,
               * which is not preserved when using multicall (where the multicall contract becomes the sender).
               */
              if (!publicMinting) {
                useMulticallWhenPossible = false;
              }
              tokenSpenders.push.apply(tokenSpenders, _toConsumableArray(nftMintFee ? [_objectSpread2({
                address: spgNftContract
              }, nftMintFee)] : []));
            case 3:
              if (!derivData) {
                _context34.n = 5;
                break;
              }
              _context34.n = 4;
              return calculateDerivativeMintingFee({
                derivData: derivData,
                rpcClient: this.rpcClient,
                wallet: this.wallet,
                chainId: this.chainId,
                sender: sender
              });
            case 4:
              mintFees = _context34.v;
              _iterator0 = _createForOfIteratorHelper(mintFees);
              try {
                for (_iterator0.s(); !(_step0 = _iterator0.n()).done;) {
                  mintFee = _step0.value;
                  tokenSpenders.push(_objectSpread2({
                    address: spgSpenderAddress
                  }, mintFee));
                }
              } catch (err) {
                _iterator0.e(err);
              } finally {
                _iterator0.f();
              }
            case 5:
              _context34.n = 6;
              return contractCallWithFees({
                options: _objectSpread2(_objectSpread2({}, options), {}, {
                  wipOptions: _objectSpread2(_objectSpread2({}, wipOptions), {}, {
                    useMulticallWhenPossible: useMulticallWhenPossible
                  })
                }),
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                tokenSpenders: tokenSpenders,
                contractCall: contractCall,
                sender: sender,
                wallet: this.wallet,
                txOptions: txOptions,
                encodedTxs: encodedTxs
              });
            case 6:
              _yield$contractCallWi = _context34.v;
              txHash = _yield$contractCallWi.txHash;
              receipt = _yield$contractCallWi.receipt;
              event = (_this$getIpIdAndToken = this.getIpIdAndTokenIdsFromEvent(receipt)) === null || _this$getIpIdAndToken === void 0 ? void 0 : _this$getIpIdAndToken[0];
              return _context34.a(2, _objectSpread2({
                txHash: txHash,
                receipt: receipt
              }, event && {
                ipId: (_event$ipId = event.ipId) !== null && _event$ipId !== void 0 ? _event$ipId : undefined,
                tokenId: (_event$tokenId = event.tokenId) !== null && _event$tokenId !== void 0 ? _event$tokenId : undefined
              }));
          }
        }, _callee34, this);
      }));
      function handleRegistrationWithFees(_x32) {
        return _handleRegistrationWithFees.apply(this, arguments);
      }
      return handleRegistrationWithFees;
    }()
    /**
     * Process the `LicenseTermsIds` and `maxLicenseTokensTxHashes` for each IP asset.
     */
  }, {
    key: "populateLicenseAndTokenIdsForRegistrationResults",
    value: (function () {
      var _populateLicenseAndTokenIdsForRegistrationResults = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee35(registrationResults, aggregateRegistrationRequest) {
        var allExtraDataArrays, allExtraData, extraDataFlatIndex, _iterator1, _step1, registrationResult, i, ipAsset, _t36;
        return _regenerator().w(function (_context35) {
          while (1) switch (_context35.p = _context35.n) {
            case 0:
              allExtraDataArrays = Object.values(aggregateRegistrationRequest).map(function (_ref6) {
                var extraData = _ref6.extraData;
                return extraData;
              });
              allExtraData = allExtraDataArrays.flat();
              extraDataFlatIndex = -1;
              _iterator1 = _createForOfIteratorHelper(registrationResults);
              _context35.p = 1;
              _iterator1.s();
            case 2:
              if ((_step1 = _iterator1.n()).done) {
                _context35.n = 7;
                break;
              }
              registrationResult = _step1.value;
              i = 0;
            case 3:
              if (!(i < registrationResult.ipAssetsWithLicenseTerms.length)) {
                _context35.n = 6;
                break;
              }
              extraDataFlatIndex++;
              if (!(registrationResult.ipAssetsWithLicenseTerms[i] && allExtraData[extraDataFlatIndex])) {
                _context35.n = 5;
                break;
              }
              _context35.n = 4;
              return this.processIpAssetLicenseTerms(registrationResult.ipAssetsWithLicenseTerms[i], allExtraData[extraDataFlatIndex]);
            case 4:
              ipAsset = _context35.v;
              registrationResult.ipAssetsWithLicenseTerms[i] = ipAsset;
            case 5:
              i++;
              _context35.n = 3;
              break;
            case 6:
              _context35.n = 2;
              break;
            case 7:
              _context35.n = 9;
              break;
            case 8:
              _context35.p = 8;
              _t36 = _context35.v;
              _iterator1.e(_t36);
            case 9:
              _context35.p = 9;
              _iterator1.f();
              return _context35.f(9);
            case 10:
              return _context35.a(2, registrationResults);
          }
        }, _callee35, this, [[1, 8, 9, 10]]);
      }));
      function populateLicenseAndTokenIdsForRegistrationResults(_x33, _x34) {
        return _populateLicenseAndTokenIdsForRegistrationResults.apply(this, arguments);
      }
      return populateLicenseAndTokenIdsForRegistrationResults;
    }())
  }, {
    key: "processIpAssetLicenseTerms",
    value: function () {
      var _processIpAssetLicenseTerms = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee36(ipAsset, extraData) {
        var _extraData$licenseTer;
        var licenseTermsIds, maxLicenseTokens, maxLicenseTokensData, maxLicenseTokensTxHashes;
        return _regenerator().w(function (_context36) {
          while (1) switch (_context36.n) {
            case 0:
              if (extraData !== null && extraData !== void 0 && (_extraData$licenseTer = extraData.licenseTermsData) !== null && _extraData$licenseTer !== void 0 && _extraData$licenseTer.length) {
                _context36.n = 1;
                break;
              }
              return _context36.a(2, ipAsset);
            case 1:
              _context36.n = 2;
              return this.getLicenseTermsId(extraData.licenseTermsData.map(function (item) {
                return item.terms;
              }));
            case 2:
              licenseTermsIds = _context36.v;
              ipAsset.licenseTermsIds = licenseTermsIds;
              maxLicenseTokens = extraData.maxLicenseTokens;
              if (maxLicenseTokens !== null && maxLicenseTokens !== void 0 && maxLicenseTokens.length) {
                _context36.n = 3;
                break;
              }
              return _context36.a(2, ipAsset);
            case 3:
              maxLicenseTokensData = maxLicenseTokens.filter(function (maxLicenseToken) {
                return maxLicenseToken !== undefined;
              }).map(function (maxLicenseToken) {
                return {
                  maxLicenseTokens: maxLicenseToken
                };
              });
              _context36.n = 4;
              return setMaxLicenseTokens({
                maxLicenseTokensData: maxLicenseTokensData,
                licensorIpId: ipAsset.ipId,
                licenseTermsIds: licenseTermsIds,
                totalLicenseTokenLimitHookClient: this.totalLicenseTokenLimitHookClient,
                templateAddress: this.licenseTemplateAddress
              });
            case 4:
              maxLicenseTokensTxHashes = _context36.v;
              if (maxLicenseTokensTxHashes !== null && maxLicenseTokensTxHashes !== void 0 && maxLicenseTokensTxHashes.length) {
                ipAsset.maxLicenseTokensTxHashes = maxLicenseTokensTxHashes;
              }
              return _context36.a(2, ipAsset);
          }
        }, _callee36, this);
      }));
      function processIpAssetLicenseTerms(_x35, _x36) {
        return _processIpAssetLicenseTerms.apply(this, arguments);
      }
      return processIpAssetLicenseTerms;
    }()
  }, {
    key: "approveLicenseTokensForDerivativeWorkflows",
    value: function () {
      var _approveLicenseTokensForDerivativeWorkflows = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee37(licenseTokenIds, autoApproveLicenseTokens) {
        var _iterator10, _step10, licenseTokenId, txHash, _t37;
        return _regenerator().w(function (_context37) {
          while (1) switch (_context37.p = _context37.n) {
            case 0:
              if (!(autoApproveLicenseTokens !== false)) {
                _context37.n = 8;
                break;
              }
              _iterator10 = _createForOfIteratorHelper(licenseTokenIds);
              _context37.p = 1;
              _iterator10.s();
            case 2:
              if ((_step10 = _iterator10.n()).done) {
                _context37.n = 5;
                break;
              }
              licenseTokenId = _step10.value;
              _context37.n = 3;
              return this.licenseTokenClient.approve({
                to: this.derivativeWorkflowsClient.address,
                tokenId: BigInt(licenseTokenId)
              });
            case 3:
              txHash = _context37.v;
              _context37.n = 4;
              return waitTx(this.rpcClient, txHash);
            case 4:
              _context37.n = 2;
              break;
            case 5:
              _context37.n = 7;
              break;
            case 6:
              _context37.p = 6;
              _t37 = _context37.v;
              _iterator10.e(_t37);
            case 7:
              _context37.p = 7;
              _iterator10.f();
              return _context37.f(7);
            case 8:
              return _context37.a(2);
          }
        }, _callee37, this, [[1, 6, 7, 8]]);
      }));
      function approveLicenseTokensForDerivativeWorkflows(_x37, _x38) {
        return _approveLicenseTokensForDerivativeWorkflows.apply(this, arguments);
      }
      return approveLicenseTokensForDerivativeWorkflows;
    }()
  }]);
}();

var LicenseClient = /*#__PURE__*/function () {
  function LicenseClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, LicenseClient);
    this.licensingModuleClient = new LicensingModuleClient(rpcClient, wallet);
    this.piLicenseTemplateReadOnlyClient = new PiLicenseTemplateReadOnlyClient(rpcClient);
    this.licenseTemplateClient = new PiLicenseTemplateClient(rpcClient, wallet);
    this.licenseRegistryReadOnlyClient = new LicenseRegistryReadOnlyClient(rpcClient);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.moduleRegistryReadOnlyClient = new ModuleRegistryReadOnlyClient(rpcClient);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.wipClient = new WrappedIpClient(rpcClient, wallet);
    this.totalLicenseTokenLimitHookClient = new TotalLicenseTokenLimitHookClient(rpcClient, wallet);
    this.licenseAttachmentWorkflowsClient = new LicenseAttachmentWorkflowsClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.walletAddress = wallet.account.address;
  }

  /**
   * Registers new license terms and return the ID of the newly registered license terms.
   *
   * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicenseTemplate.sol#L19 | `LicenseTermsRegistered`} event.
   */
  return _createClass(LicenseClient, [{
    key: "registerPILTerms",
    value: (function () {
      var _registerPILTerms = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(request) {
        var object, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              object = PILFlavor.validateLicenseTerms(request, this.chainId);
              _context.n = 1;
              return this.registerPILTermsHelper(object, request.txOptions);
            case 1:
              return _context.a(2, _context.v);
            case 2:
              _context.p = 2;
              _t = _context.v;
              return _context.a(2, handleError(_t, "Failed to register license terms"));
          }
        }, _callee, this, [[0, 2]]);
      }));
      function registerPILTerms(_x) {
        return _registerPILTerms.apply(this, arguments);
      }
      return registerPILTerms;
    }()
    /**
     * Attaches license terms to an IP.
     */
    )
  }, {
    key: "attachLicenseTerms",
    value: (function () {
      var _attachLicenseTerms = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(request) {
        var _request$txOptions, isRegistered, isExisted, isAttachedLicenseTerms, req, txHash, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              request.licenseTermsId = BigInt(request.licenseTermsId);
              _context2.n = 1;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.ipId)
              });
            case 1:
              isRegistered = _context2.v;
              if (isRegistered) {
                _context2.n = 2;
                break;
              }
              throw new Error("The IP with id ".concat(request.ipId, " is not registered."));
            case 2:
              _context2.n = 3;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: request.licenseTermsId
              });
            case 3:
              isExisted = _context2.v;
              if (isExisted) {
                _context2.n = 4;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 4:
              _context2.n = 5;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: request.ipId,
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: request.licenseTermsId
              });
            case 5:
              isAttachedLicenseTerms = _context2.v;
              if (!isAttachedLicenseTerms) {
                _context2.n = 6;
                break;
              }
              return _context2.a(2, {
                success: false
              });
            case 6:
              req = {
                ipId: request.ipId,
                licenseTemplate: request.licenseTemplate || this.licenseTemplateClient.address,
                licenseTermsId: request.licenseTermsId
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context2.n = 7;
                break;
              }
              return _context2.a(2, {
                encodedTxData: this.licensingModuleClient.attachLicenseTermsEncode(req)
              });
            case 7:
              _context2.n = 8;
              return this.licensingModuleClient.attachLicenseTerms(req);
            case 8:
              txHash = _context2.v;
              _context2.n = 9;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 9:
              return _context2.a(2, {
                txHash: txHash,
                success: true
              });
            case 10:
              _context2.n = 12;
              break;
            case 11:
              _context2.p = 11;
              _t2 = _context2.v;
              return _context2.a(2, handleError(_t2, "Failed to attach license terms"));
            case 12:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 11]]);
      }));
      function attachLicenseTerms(_x2) {
        return _attachLicenseTerms.apply(this, arguments);
      }
      return attachLicenseTerms;
    }()
    /**
     * Mints license tokens for the license terms attached to an IP.
     * It might require the caller pay the minting fee, depending on the license terms or configured by the iP owner.
     * The minting fee is paid in the minting fee token specified in the license terms or configured by the IP owner.
     * IP owners can configure the minting fee of their IPs or configure the minting fee module to determine the minting fee.
     *
     * @remarks
     * Before minting license tokens, the license terms must be attached to the IP, with two exceptions:
     * 1. Default license terms can be minted without explicit attachment since they are automatically
     *    attached to all IPs by default
     * 2. IP owners have special privileges and can mint license tokens for their own IPs using any
     *    license terms, even if those terms are not explicitly attached
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L34 | `LicenseTokensMinted`} event.
     */
    )
  }, {
    key: "mintLicenseTokens",
    value: (function () {
      var _mintLicenseTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(request) {
        var _this = this;
        var _request$maxMintingFe, _request$maxRevenueSh, _request$txOptions2, receiver, req, isLicenseIpIdRegistered, isExisted, ipAccount, ipOwner, isAttachedLicenseTerms, encodedTxData, licenseMintingFee, wipSpenders, _yield$contractCallWi, txHash, receipt, targetLogs, startLicenseTokenId, licenseTokenIds, i, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              receiver = validateAddress(request.receiver || this.walletAddress);
              req = {
                licensorIpId: validateAddress(request.licensorIpId),
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: BigInt(request.licenseTermsId),
                amount: BigInt(request.amount === undefined ? 1 : request.amount),
                receiver: receiver,
                royaltyContext: viem.zeroAddress,
                maxMintingFee: BigInt((_request$maxMintingFe = request.maxMintingFee) !== null && _request$maxMintingFe !== void 0 ? _request$maxMintingFe : 0),
                maxRevenueShare: getRevenueShare((_request$maxRevenueSh = request.maxRevenueShare) !== null && _request$maxRevenueSh !== void 0 ? _request$maxRevenueSh : 100, RevShareType.MAX_REVENUE_SHARE)
              };
              if (!(req.maxMintingFee < 0)) {
                _context3.n = 1;
                break;
              }
              throw new Error("The maxMintingFee must be greater than 0.");
            case 1:
              _context3.n = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.licensorIpId)
              });
            case 2:
              isLicenseIpIdRegistered = _context3.v;
              if (isLicenseIpIdRegistered) {
                _context3.n = 3;
                break;
              }
              throw new Error("The licensor IP with id ".concat(request.licensorIpId, " is not registered."));
            case 3:
              _context3.n = 4;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: req.licenseTermsId
              });
            case 4:
              isExisted = _context3.v;
              if (isExisted) {
                _context3.n = 5;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 5:
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, req.licensorIpId);
              _context3.n = 6;
              return ipAccount.owner();
            case 6:
              ipOwner = _context3.v;
              if (!(ipOwner !== this.walletAddress)) {
                _context3.n = 8;
                break;
              }
              _context3.n = 7;
              return this.licenseRegistryReadOnlyClient.hasIpAttachedLicenseTerms({
                ipId: req.licensorIpId,
                licenseTemplate: req.licenseTemplate,
                licenseTermsId: req.licenseTermsId
              });
            case 7:
              isAttachedLicenseTerms = _context3.v;
              if (isAttachedLicenseTerms) {
                _context3.n = 8;
                break;
              }
              throw new Error("License terms id ".concat(req.licenseTermsId, " is not attached to the IP with id ").concat(req.licensorIpId, "."));
            case 8:
              encodedTxData = this.licensingModuleClient.mintLicenseTokensEncode(req);
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.encodedTxDataOnly)) {
                _context3.n = 9;
                break;
              }
              return _context3.a(2, {
                encodedTxData: encodedTxData
              });
            case 9:
              _context3.n = 10;
              return calculateLicenseMintFee({
                predictMintingFeeRequest: req,
                rpcClient: this.rpcClient,
                chainId: this.chainId,
                walletAddress: this.walletAddress
              });
            case 10:
              licenseMintingFee = _context3.v;
              wipSpenders = [];
              if (licenseMintingFee.amount > 0n) {
                wipSpenders.push(_objectSpread2({
                  address: royaltyModuleAddress[this.chainId]
                }, licenseMintingFee));
              }
              _context3.n = 11;
              return contractCallWithFees({
                options: request.options,
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                tokenSpenders: wipSpenders,
                contractCall: function contractCall() {
                  return _this.licensingModuleClient.mintLicenseTokens(req);
                },
                wallet: this.wallet,
                sender: this.walletAddress,
                txOptions: request.txOptions,
                encodedTxs: [encodedTxData]
              });
            case 11:
              _yield$contractCallWi = _context3.v;
              txHash = _yield$contractCallWi.txHash;
              receipt = _yield$contractCallWi.receipt;
              targetLogs = this.licensingModuleClient.parseTxLicenseTokensMintedEvent(receipt);
              startLicenseTokenId = targetLogs[0].startLicenseTokenId;
              licenseTokenIds = [];
              for (i = 0; i < req.amount; i++) {
                licenseTokenIds.push(startLicenseTokenId + BigInt(i));
              }
              return _context3.a(2, {
                txHash: txHash,
                licenseTokenIds: licenseTokenIds,
                receipt: receipt
              });
            case 12:
              _context3.p = 12;
              _t3 = _context3.v;
              return _context3.a(2, handleError(_t3, "Failed to mint license tokens"));
          }
        }, _callee3, this, [[0, 12]]);
      }));
      function mintLicenseTokens(_x3) {
        return _mintLicenseTokens.apply(this, arguments);
      }
      return mintLicenseTokens;
    }()
    /**
     * Gets license terms of the given ID.
     */
    )
  }, {
    key: "getLicenseTerms",
    value: (function () {
      var _getLicenseTerms = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(selectedLicenseTermsId) {
        var _t4;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              _context4.n = 1;
              return this.piLicenseTemplateReadOnlyClient.getLicenseTerms({
                selectedLicenseTermsId: BigInt(selectedLicenseTermsId)
              });
            case 1:
              return _context4.a(2, _context4.v);
            case 2:
              _context4.p = 2;
              _t4 = _context4.v;
              return _context4.a(2, handleError(_t4, "Failed to get license terms"));
          }
        }, _callee4, this, [[0, 2]]);
      }));
      function getLicenseTerms(_x4) {
        return _getLicenseTerms.apply(this, arguments);
      }
      return getLicenseTerms;
    }()
    /**
     * Pre-compute the minting license fee for the given IP and license terms. The function can be used to calculate the minting license fee before minting license tokens.
     */
    )
  }, {
    key: "predictMintingLicenseFee",
    value: (function () {
      var _predictMintingLicenseFee2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(request) {
        var isLicenseIpIdRegistered, licenseTermsId, isExisted, object, _t5;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              _context5.p = 0;
              _context5.n = 1;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(request.licensorIpId)
              });
            case 1:
              isLicenseIpIdRegistered = _context5.v;
              if (isLicenseIpIdRegistered) {
                _context5.n = 2;
                break;
              }
              throw new Error("The licensor IP with id ".concat(request.licensorIpId, " is not registered."));
            case 2:
              licenseTermsId = BigInt(request.licenseTermsId);
              _context5.n = 3;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: licenseTermsId
              });
            case 3:
              isExisted = _context5.v;
              if (isExisted) {
                _context5.n = 4;
                break;
              }
              throw new Error("License terms id ".concat(request.licenseTermsId, " do not exist."));
            case 4:
              object = _objectSpread2(_objectSpread2({}, request), {}, {
                receiver: validateAddress(request.receiver || this.walletAddress),
                amount: BigInt(request.amount),
                royaltyContext: viem.zeroAddress,
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: licenseTermsId
              });
              _context5.n = 5;
              return predictMintingLicenseFee({
                predictMintingFeeRequest: object,
                rpcClient: this.rpcClient,
                chainId: this.chainId,
                walletAddress: this.walletAddress
              });
            case 5:
              return _context5.a(2, _context5.v);
            case 6:
              _context5.p = 6;
              _t5 = _context5.v;
              return _context5.a(2, handleError(_t5, "Failed to predict minting license fee"));
          }
        }, _callee5, this, [[0, 6]]);
      }));
      function predictMintingLicenseFee$1(_x5) {
        return _predictMintingLicenseFee2.apply(this, arguments);
      }
      return predictMintingLicenseFee$1;
    }()
    /**
     * Sets the licensing configuration for a specific license terms of an IP. If both licenseTemplate and licenseTermsId are not specified then the licensing config apply to all licenses of given IP.
     */
    )
  }, {
    key: "setLicensingConfig",
    value: (function () {
      var _setLicensingConfig = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(request) {
        var _request$txOptions3, req, isLicenseIpIdRegistered, isExisted, isRegistered, txHash, _t6;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              _context6.p = 0;
              req = {
                ipId: request.ipId,
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: BigInt(request.licenseTermsId),
                licensingConfig: validateLicenseConfig(request.licensingConfig)
              };
              if (!(req.licenseTemplate === viem.zeroAddress && req.licensingConfig.commercialRevShare !== 0)) {
                _context6.n = 1;
                break;
              }
              throw new Error("The license template cannot be zero address if commercial revenue share is not zero.");
            case 1:
              _context6.n = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(req.ipId)
              });
            case 2:
              isLicenseIpIdRegistered = _context6.v;
              if (isLicenseIpIdRegistered) {
                _context6.n = 3;
                break;
              }
              throw new Error("The licensor IP with id ".concat(req.ipId, " is not registered."));
            case 3:
              _context6.n = 4;
              return this.piLicenseTemplateReadOnlyClient.exists({
                licenseTermsId: req.licenseTermsId
              });
            case 4:
              isExisted = _context6.v;
              if (isExisted) {
                _context6.n = 5;
                break;
              }
              throw new Error("License terms id ".concat(req.licenseTermsId, " do not exist."));
            case 5:
              if (!(req.licensingConfig.licensingHook !== viem.zeroAddress)) {
                _context6.n = 7;
                break;
              }
              _context6.n = 6;
              return this.moduleRegistryReadOnlyClient.isRegistered({
                moduleAddress: req.licensingConfig.licensingHook
              });
            case 6:
              isRegistered = _context6.v;
              if (isRegistered) {
                _context6.n = 7;
                break;
              }
              throw new Error("The licensing hook is not registered.");
            case 7:
              if (!(req.licenseTemplate === viem.zeroAddress && req.licenseTermsId !== 0n)) {
                _context6.n = 8;
                break;
              }
              throw new Error("The license template is zero address but license terms id is not zero.");
            case 8:
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context6.n = 9;
                break;
              }
              return _context6.a(2, {
                encodedTxData: this.licensingModuleClient.setLicensingConfigEncode(req)
              });
            case 9:
              _context6.n = 10;
              return this.licensingModuleClient.setLicensingConfig(req);
            case 10:
              txHash = _context6.v;
              _context6.n = 11;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 11:
              return _context6.a(2, {
                txHash: txHash,
                success: true
              });
            case 12:
              _context6.n = 14;
              break;
            case 13:
              _context6.p = 13;
              _t6 = _context6.v;
              return _context6.a(2, handleError(_t6, "Failed to set licensing config"));
            case 14:
              return _context6.a(2);
          }
        }, _callee6, this, [[0, 13]]);
      }));
      function setLicensingConfig(_x6) {
        return _setLicensingConfig.apply(this, arguments);
      }
      return setLicensingConfig;
    }()
    /**
     * Set the max license token limit for a specific license.
     *
     * @remarks
     * This method automatically configures the licensing hook to use the
     * {@link https://github.com/storyprotocol/protocol-periphery-v1/blob/release/1.3/contracts/hooks/TotalLicenseTokenLimitHook.sol | TotalLicenseTokenLimitHook} contract
     * if the current licensing hook is not set to `TotalLicenseTokenLimitHook`, and sets the max license tokens
     * to the specified limit.
     */
    )
  }, {
    key: "setMaxLicenseTokens",
    value: (function () {
      var _setMaxLicenseTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(_ref) {
        var ipId, licenseTermsId, maxLicenseTokens, licenseTemplate, txOptions, newLicenseTermsId, newLicenseTemplate, licensingConfig, txHash, _t7;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.p = _context7.n) {
            case 0:
              ipId = _ref.ipId, licenseTermsId = _ref.licenseTermsId, maxLicenseTokens = _ref.maxLicenseTokens, licenseTemplate = _ref.licenseTemplate, txOptions = _ref.txOptions;
              _context7.p = 1;
              if (!(maxLicenseTokens < 0)) {
                _context7.n = 2;
                break;
              }
              throw new Error("The max license tokens must be greater than 0.");
            case 2:
              newLicenseTermsId = BigInt(licenseTermsId);
              newLicenseTemplate = validateAddress(licenseTemplate || this.licenseTemplateClient.address);
              _context7.n = 3;
              return this.getLicensingConfig({
                ipId: ipId,
                licenseTermsId: newLicenseTermsId,
                licenseTemplate: newLicenseTemplate
              });
            case 3:
              licensingConfig = _context7.v;
              if (!(licensingConfig.licensingHook !== this.totalLicenseTokenLimitHookClient.address)) {
                _context7.n = 4;
                break;
              }
              _context7.n = 4;
              return this.setLicensingConfig({
                ipId: ipId,
                licenseTermsId: newLicenseTermsId,
                licenseTemplate: newLicenseTemplate,
                licensingConfig: _objectSpread2(_objectSpread2({}, licensingConfig), {}, {
                  licensingHook: this.totalLicenseTokenLimitHookClient.address,
                  // use Math.trunc to avoid precision issues
                  expectMinimumGroupRewardShare: Math.trunc(licensingConfig.expectMinimumGroupRewardShare / 1000000)
                })
              });
            case 4:
              _context7.n = 5;
              return this.totalLicenseTokenLimitHookClient.setTotalLicenseTokenLimit({
                licensorIpId: ipId,
                licenseTemplate: newLicenseTemplate,
                licenseTermsId: newLicenseTermsId,
                limit: BigInt(maxLicenseTokens)
              });
            case 5:
              txHash = _context7.v;
              return _context7.a(2, waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 6:
              _context7.p = 6;
              _t7 = _context7.v;
              return _context7.a(2, handleError(_t7, "Failed to set max license tokens"));
          }
        }, _callee7, this, [[1, 6]]);
      }));
      function setMaxLicenseTokens(_x7) {
        return _setMaxLicenseTokens.apply(this, arguments);
      }
      return setMaxLicenseTokens;
    }())
  }, {
    key: "getLicensingConfig",
    value: function () {
      var _getLicensingConfig = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(request) {
        var licensingConfigParam, _t8;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.p = _context8.n) {
            case 0:
              _context8.p = 0;
              licensingConfigParam = {
                ipId: validateAddress(request.ipId),
                licenseTemplate: validateAddress(request.licenseTemplate || this.licenseTemplateClient.address),
                licenseTermsId: BigInt(request.licenseTermsId)
              };
              _context8.n = 1;
              return this.licenseRegistryReadOnlyClient.getLicensingConfig(licensingConfigParam);
            case 1:
              return _context8.a(2, _context8.v);
            case 2:
              _context8.p = 2;
              _t8 = _context8.v;
              return _context8.a(2, handleError(_t8, "Failed to get licensing config"));
          }
        }, _callee8, this, [[0, 2]]);
      }));
      function getLicensingConfig(_x8) {
        return _getLicensingConfig.apply(this, arguments);
      }
      return getLicensingConfig;
    }()
    /**
     * Register Programmable IP License Terms (if unregistered) and attach it to IP.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicensingModule.sol#L19 | `LicenseTermsAttached`} event.
     */
  }, {
    key: "registerPilTermsAndAttach",
    value: (function () {
      var _registerPilTermsAndAttach = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(request) {
        var _request$txOptions4, ipId, isRegistered, _yield$validateLicens, licenseTerms, licenseTermsData, calculatedDeadline, ipAccount, _yield$ipAccount$stat, state, signature, object, txHash, licenseTermsIds, i, maxLicenseTokensTxHashes, _t9, _t0;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.p = _context9.n) {
            case 0:
              _context9.p = 0;
              ipId = request.ipId;
              _context9.n = 1;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(ipId)
              });
            case 1:
              isRegistered = _context9.v;
              if (isRegistered) {
                _context9.n = 2;
                break;
              }
              throw new Error("The IP with id ".concat(ipId, " is not registered."));
            case 2:
              _context9.n = 3;
              return validateLicenseTermsData(request.licenseTermsData, this.rpcClient, this.chainId);
            case 3:
              _yield$validateLicens = _context9.v;
              licenseTerms = _yield$validateLicens.licenseTerms;
              licenseTermsData = _yield$validateLicens.licenseTermsData;
              _context9.n = 4;
              return getCalculatedDeadline(this.rpcClient, request.deadline);
            case 4:
              calculatedDeadline = _context9.v;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              _context9.n = 5;
              return ipAccount.state();
            case 5:
              _yield$ipAccount$stat = _context9.v;
              state = _yield$ipAccount$stat.result;
              _context9.n = 6;
              return generateOperationSignature({
                ipIdAddress: ipId,
                methodType: SignatureMethodType.REGISTER_PIL_TERMS_AND_ATTACH,
                deadline: calculatedDeadline,
                state: state,
                wallet: this.wallet,
                chainId: this.chainId
              });
            case 6:
              signature = _context9.v;
              object = {
                ipId: ipId,
                licenseTermsData: licenseTermsData,
                sigAttachAndConfig: {
                  signer: validateAddress(this.walletAddress),
                  deadline: calculatedDeadline,
                  signature: signature
                }
              };
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.encodedTxDataOnly)) {
                _context9.n = 7;
                break;
              }
              return _context9.a(2, {
                encodedTxData: this.licenseAttachmentWorkflowsClient.registerPilTermsAndAttachEncode(object)
              });
            case 7:
              _context9.n = 8;
              return this.licenseAttachmentWorkflowsClient.registerPilTermsAndAttach(object);
            case 8:
              txHash = _context9.v;
              _context9.n = 9;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 9:
              licenseTermsIds = [];
              i = 0;
            case 10:
              if (!(i < licenseTerms.length)) {
                _context9.n = 13;
                break;
              }
              _t9 = licenseTermsIds;
              _context9.n = 11;
              return this.getLicenseTermsId(licenseTerms[i]);
            case 11:
              _t9.push.call(_t9, _context9.v);
            case 12:
              i++;
              _context9.n = 10;
              break;
            case 13:
              _context9.n = 14;
              return setMaxLicenseTokens({
                maxLicenseTokensData: request.licenseTermsData,
                licensorIpId: ipId,
                licenseTermsIds: licenseTermsIds,
                totalLicenseTokenLimitHookClient: this.totalLicenseTokenLimitHookClient,
                templateAddress: this.licenseTemplateClient.address
              });
            case 14:
              maxLicenseTokensTxHashes = _context9.v;
              return _context9.a(2, _objectSpread2({
                txHash: txHash,
                licenseTermsIds: licenseTermsIds
              }, maxLicenseTokensTxHashes.length > 0 && {
                maxLicenseTokensTxHashes: maxLicenseTokensTxHashes
              }));
            case 15:
              _context9.n = 17;
              break;
            case 16:
              _context9.p = 16;
              _t0 = _context9.v;
              return _context9.a(2, handleError(_t0, "Failed to register PIL terms and attach"));
            case 17:
              return _context9.a(2);
          }
        }, _callee9, this, [[0, 16]]);
      }));
      function registerPilTermsAndAttach(_x9) {
        return _registerPilTermsAndAttach.apply(this, arguments);
      }
      return registerPilTermsAndAttach;
    }()
    /**
     * @deprecated Use {@link PILFlavor.nonCommercialSocialRemixing} with {@link LicenseClient.registerPILTerms} instead.
     *  This method will be removed soon.
     *
     * Convenient function to register a PIL non commercial social remix license to the registry
     *
     * For more details, see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-flavors#flavor-%231%3A-non-commercial-social-remixing | Non Commercial Social Remixing}.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicenseTemplate.sol#L19 | `LicenseTermsRegistered`} event.
     */
    )
  }, {
    key: "registerNonComSocialRemixingPIL",
    value: (function () {
      var _registerNonComSocialRemixingPIL = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee0(request) {
        var licenseTerms, _t1;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.p = _context0.n) {
            case 0:
              _context0.p = 0;
              licenseTerms = PILFlavor.nonCommercialSocialRemixing();
              _context0.n = 1;
              return this.registerPILTermsHelper(licenseTerms, request === null || request === void 0 ? void 0 : request.txOptions);
            case 1:
              return _context0.a(2, _context0.v);
            case 2:
              _context0.p = 2;
              _t1 = _context0.v;
              return _context0.a(2, handleError(_t1, "Failed to register non commercial social remixing PIL"));
          }
        }, _callee0, this, [[0, 2]]);
      }));
      function registerNonComSocialRemixingPIL(_x0) {
        return _registerNonComSocialRemixingPIL.apply(this, arguments);
      }
      return registerNonComSocialRemixingPIL;
    }()
    /**
     * @deprecated Use {@link PILFlavor.commercialUse} with {@link LicenseClient.registerPILTerms} instead.
     *  This method will be removed soon.
     *
     * Convenient function to register a PIL commercial use license to the registry.
     *
     * For more details, see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-flavors#flavor-%232%3A-commercial-use | Commercial Use}.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicenseTemplate.sol#L19 | `LicenseTermsRegistered`} event.
     */
    )
  }, {
    key: "registerCommercialUsePIL",
    value: (function () {
      var _registerCommercialUsePIL = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee1(request) {
        var licenseTerms, _t10;
        return _regenerator().w(function (_context1) {
          while (1) switch (_context1.p = _context1.n) {
            case 0:
              _context1.p = 0;
              licenseTerms = PILFlavor.commercialUse({
                defaultMintingFee: Number(request.defaultMintingFee),
                currency: request.currency,
                royaltyPolicy: request.royaltyPolicyAddress
              });
              _context1.n = 1;
              return this.registerPILTermsHelper(licenseTerms, request.txOptions);
            case 1:
              return _context1.a(2, _context1.v);
            case 2:
              _context1.p = 2;
              _t10 = _context1.v;
              return _context1.a(2, handleError(_t10, "Failed to register commercial use PIL"));
          }
        }, _callee1, this, [[0, 2]]);
      }));
      function registerCommercialUsePIL(_x1) {
        return _registerCommercialUsePIL.apply(this, arguments);
      }
      return registerCommercialUsePIL;
    }()
    /**
     * @deprecated Use {@link PILFlavor.commercialRemix} with {@link LicenseClient.registerPILTerms} instead.
     *  This method will be removed soon.
     *
     * Convenient function to register a PIL commercial Remix license to the registry.
     *
     * For more details, see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-flavors#flavor-%233%3A-commercial-remix | Commercial Remix }.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicenseTemplate.sol#L19 | `LicenseTermsRegistered`} event.
     */
    )
  }, {
    key: "registerCommercialRemixPIL",
    value: (function () {
      var _registerCommercialRemixPIL = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee10(_ref2) {
        var defaultMintingFee, currency, royaltyPolicyAddress, commercialRevShare, txOptions, licenseTerms, _t11;
        return _regenerator().w(function (_context10) {
          while (1) switch (_context10.p = _context10.n) {
            case 0:
              defaultMintingFee = _ref2.defaultMintingFee, currency = _ref2.currency, royaltyPolicyAddress = _ref2.royaltyPolicyAddress, commercialRevShare = _ref2.commercialRevShare, txOptions = _ref2.txOptions;
              _context10.p = 1;
              licenseTerms = PILFlavor.commercialRemix({
                defaultMintingFee: Number(defaultMintingFee),
                currency: currency,
                royaltyPolicy: royaltyPolicyAddress,
                commercialRevShare: commercialRevShare
              });
              _context10.n = 2;
              return this.registerPILTermsHelper(licenseTerms, txOptions);
            case 2:
              return _context10.a(2, _context10.v);
            case 3:
              _context10.p = 3;
              _t11 = _context10.v;
              return _context10.a(2, handleError(_t11, "Failed to register commercial remix PIL"));
          }
        }, _callee10, this, [[1, 3]]);
      }));
      function registerCommercialRemixPIL(_x10) {
        return _registerCommercialRemixPIL.apply(this, arguments);
      }
      return registerCommercialRemixPIL;
    }()
    /**
     * @deprecated Use {@link PILFlavor.creativeCommonsAttribution} with {@link LicenseClient.registerPILTerms} instead.
     *  This method will be removed soon.
     *
     * Convenient function to register a PIL creative commons attribution license to the registry.
     * Creates a Creative Commons Attribution (CC-BY) license terms flavor.
     *
     * For more details, see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-flavors#flavor-%234%3A-creative-commons-attribution | Creative Commons Attribution}.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/modules/licensing/ILicenseTemplate.sol#L19 | `LicenseTermsRegistered`} event.
     */
    )
  }, {
    key: "registerCreativeCommonsAttributionPIL",
    value: (function () {
      var _registerCreativeCommonsAttributionPIL = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee11(_ref3) {
        var currency, royaltyPolicyAddress, txOptions, _t12;
        return _regenerator().w(function (_context11) {
          while (1) switch (_context11.p = _context11.n) {
            case 0:
              currency = _ref3.currency, royaltyPolicyAddress = _ref3.royaltyPolicyAddress, txOptions = _ref3.txOptions;
              _context11.p = 1;
              _context11.n = 2;
              return this.registerPILTermsHelper(PILFlavor.creativeCommonsAttribution({
                currency: currency,
                royaltyPolicy: royaltyPolicyAddress
              }), txOptions);
            case 2:
              return _context11.a(2, _context11.v);
            case 3:
              _context11.p = 3;
              _t12 = _context11.v;
              return _context11.a(2, handleError(_t12, "Failed to register creative commons attribution PIL"));
          }
        }, _callee11, this, [[1, 3]]);
      }));
      function registerCreativeCommonsAttributionPIL(_x11) {
        return _registerCreativeCommonsAttributionPIL.apply(this, arguments);
      }
      return registerCreativeCommonsAttributionPIL;
    }())
  }, {
    key: "getLicenseTermsId",
    value: function () {
      var _getLicenseTermsId = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee12(licenseTerms) {
        var licenseRes;
        return _regenerator().w(function (_context12) {
          while (1) switch (_context12.n) {
            case 0:
              _context12.n = 1;
              return this.licenseTemplateClient.getLicenseTermsId({
                terms: licenseTerms
              });
            case 1:
              licenseRes = _context12.v;
              return _context12.a(2, licenseRes.selectedLicenseTermsId);
          }
        }, _callee12, this);
      }));
      function getLicenseTermsId(_x12) {
        return _getLicenseTermsId.apply(this, arguments);
      }
      return getLicenseTermsId;
    }()
  }, {
    key: "registerPILTermsHelper",
    value: function () {
      var _registerPILTermsHelper = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee13(licenseTerms, txOptions) {
        var licenseTermsId, txHash, _yield$waitForTxRecei, receipt, targetLogs;
        return _regenerator().w(function (_context13) {
          while (1) switch (_context13.n) {
            case 0:
              licenseTerms.commercialRevShare = getRevenueShare(licenseTerms.commercialRevShare);
              if (!(txOptions !== null && txOptions !== void 0 && txOptions.encodedTxDataOnly)) {
                _context13.n = 1;
                break;
              }
              return _context13.a(2, {
                encodedTxData: this.licenseTemplateClient.registerLicenseTermsEncode({
                  terms: licenseTerms
                })
              });
            case 1:
              _context13.n = 2;
              return this.getLicenseTermsId(licenseTerms);
            case 2:
              licenseTermsId = _context13.v;
              if (!(licenseTermsId !== 0n)) {
                _context13.n = 3;
                break;
              }
              return _context13.a(2, {
                licenseTermsId: licenseTermsId
              });
            case 3:
              _context13.n = 4;
              return this.licenseTemplateClient.registerLicenseTerms({
                terms: licenseTerms
              });
            case 4:
              txHash = _context13.v;
              _context13.n = 5;
              return waitForTxReceipt({
                txOptions: txOptions,
                rpcClient: this.rpcClient,
                txHash: txHash
              });
            case 5:
              _yield$waitForTxRecei = _context13.v;
              receipt = _yield$waitForTxRecei.receipt;
              targetLogs = this.licenseTemplateClient.parseTxLicenseTermsRegisteredEvent(receipt);
              return _context13.a(2, {
                txHash: txHash,
                licenseTermsId: targetLogs[0].licenseTermsId
              });
            case 6:
              return _context13.a(2);
          }
        }, _callee13, this);
      }));
      function registerPILTermsHelper(_x13, _x14) {
        return _registerPILTermsHelper.apply(this, arguments);
      }
      return registerPILTermsHelper;
    }()
  }]);
}();

var NftClient = /*#__PURE__*/function () {
  function NftClient(rpcClient, wallet) {
    _classCallCheck(this, NftClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.registrationWorkflowsClient = new RegistrationWorkflowsClient(rpcClient, wallet);
  }

  /**
   * Creates a new SPG NFT Collection.
   *
   * Emits an on-chain `CollectionCreated` event.
   * @see {@link https://github.com/storyprotocol/protocol-periphery-v1/blob/v1.3.1/contracts/interfaces/workflows/IRegistrationWorkflows.sol#L12 | IRegistrationWorkflows}
   */
  return _createClass(NftClient, [{
    key: "createNFTCollection",
    value: (function () {
      var _createNFTCollection = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(request) {
        var _request$baseURI, _request$maxSupply, _request$mintFee, _request$mintFeeToken, _request$txOptions, object, txHash, txReceipt, targetLogs, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              if (!(request.mintFee !== undefined && (request.mintFee < 0n || request.mintFeeToken === viem.zeroAddress || !viem.isAddress(request.mintFeeToken || "")))) {
                _context.n = 1;
                break;
              }
              throw new Error("Invalid mint fee token address, mint fee is greater than 0.");
            case 1:
              object = {
                spgNftInitParams: {
                  name: request.name,
                  symbol: request.symbol,
                  baseURI: (_request$baseURI = request.baseURI) !== null && _request$baseURI !== void 0 ? _request$baseURI : "",
                  maxSupply: (_request$maxSupply = request.maxSupply) !== null && _request$maxSupply !== void 0 ? _request$maxSupply : Number(viem.maxUint32),
                  mintFee: BigInt((_request$mintFee = request.mintFee) !== null && _request$mintFee !== void 0 ? _request$mintFee : 0),
                  mintFeeToken: (_request$mintFeeToken = request.mintFeeToken) !== null && _request$mintFeeToken !== void 0 ? _request$mintFeeToken : viem.zeroAddress,
                  owner: validateAddress(request.owner || this.wallet.account.address),
                  mintFeeRecipient: validateAddress(request.mintFeeRecipient),
                  mintOpen: request.mintOpen,
                  isPublicMinting: request.isPublicMinting,
                  contractURI: request.contractURI
                }
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.n = 2;
                break;
              }
              return _context.a(2, {
                encodedTxData: this.registrationWorkflowsClient.createCollectionEncode(object)
              });
            case 2:
              _context.n = 3;
              return this.registrationWorkflowsClient.createCollection(object);
            case 3:
              txHash = _context.v;
              _context.n = 4;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 4:
              txReceipt = _context.v;
              targetLogs = this.registrationWorkflowsClient.parseTxCollectionCreatedEvent(txReceipt);
              return _context.a(2, {
                txHash: txHash,
                spgNftContract: targetLogs[0].spgNftContract
              });
            case 5:
              _context.n = 7;
              break;
            case 6:
              _context.p = 6;
              _t = _context.v;
              return _context.a(2, handleError(_t, "Failed to create an SPG NFT collection"));
            case 7:
              return _context.a(2);
          }
        }, _callee, this, [[0, 6]]);
      }));
      function createNFTCollection(_x) {
        return _createNFTCollection.apply(this, arguments);
      }
      return createNFTCollection;
    }()
    /**
     * Returns the current mint token of the collection.
     */
    )
  }, {
    key: "getMintFeeToken",
    value: (function () {
      var _getMintFeeToken = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(spgNftContract) {
        var spgNftClient;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              spgNftClient = new SpgnftImplReadOnlyClient(this.rpcClient, validateAddress(spgNftContract));
              return _context2.a(2, spgNftClient.mintFeeToken());
          }
        }, _callee2, this);
      }));
      function getMintFeeToken(_x2) {
        return _getMintFeeToken.apply(this, arguments);
      }
      return getMintFeeToken;
    }()
    /**
     * Returns the current mint fee of the collection.
     */
    )
  }, {
    key: "getMintFee",
    value: (function () {
      var _getMintFee = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(spgNftContract) {
        var spgNftClient;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.n) {
            case 0:
              spgNftClient = new SpgnftImplReadOnlyClient(this.rpcClient, validateAddress(spgNftContract));
              return _context3.a(2, spgNftClient.mintFee());
          }
        }, _callee3, this);
      }));
      function getMintFee(_x3) {
        return _getMintFee.apply(this, arguments);
      }
      return getMintFee;
    }()
    /**
     * Sets the token URI for a specific token id.
     *
     * @remarks
     * Only callable by the owner of the token.
     */
    )
  }, {
    key: "setTokenURI",
    value: (function () {
      var _setTokenURI = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(_ref) {
        var tokenId, tokenURI, spgNftContract, txOptions, spgNftClient, txHash, _t2;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              tokenId = _ref.tokenId, tokenURI = _ref.tokenURI, spgNftContract = _ref.spgNftContract, txOptions = _ref.txOptions;
              _context4.p = 1;
              spgNftClient = new SpgnftImplClient(this.rpcClient, this.wallet, validateAddress(spgNftContract));
              _context4.n = 2;
              return spgNftClient.setTokenUri({
                tokenId: BigInt(tokenId),
                tokenUri: tokenURI
              });
            case 2:
              txHash = _context4.v;
              return _context4.a(2, waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 3:
              _context4.p = 3;
              _t2 = _context4.v;
              return _context4.a(2, handleError(_t2, "Failed to set token URI"));
          }
        }, _callee4, this, [[1, 3]]);
      }));
      function setTokenURI(_x4) {
        return _setTokenURI.apply(this, arguments);
      }
      return setTokenURI;
    }()
    /**
     * Returns the token URI for a specific token id.
     */
    )
  }, {
    key: "getTokenURI",
    value: (function () {
      var _getTokenURI = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(_ref2) {
        var tokenId, spgNftContract, spgNftClient;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.n) {
            case 0:
              tokenId = _ref2.tokenId, spgNftContract = _ref2.spgNftContract;
              spgNftClient = new SpgnftImplReadOnlyClient(this.rpcClient, spgNftContract);
              _context5.n = 1;
              return spgNftClient.tokenUri({
                tokenId: BigInt(tokenId)
              });
            case 1:
              return _context5.a(2, _context5.v);
          }
        }, _callee5, this);
      }));
      function getTokenURI(_x5) {
        return _getTokenURI.apply(this, arguments);
      }
      return getTokenURI;
    }())
  }]);
}();

var PermissionClient = /*#__PURE__*/function () {
  function PermissionClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, PermissionClient);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.accessControllerClient = new AccessControllerClient(this.rpcClient, this.wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(this.rpcClient, this.wallet);
    this.coreMetadataModuleClient = new CoreMetadataModuleClient(this.rpcClient, this.wallet);
  }

  /**
   * Sets the permission for a specific function call.
   * Each policy is represented as a mapping from an IP account address to a signer address to a recipient
   * address to a function selector to a permission level. The permission level is an enum of `AccessPermission`.
   * By default, all policies are set to ABSTAIN, which means that the permission is not set.
   * The owner of ipAccount by default has all permission.
   *
   * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
   */
  return _createClass(PermissionClient, [{
    key: "setPermission",
    value: (function () {
      var _setPermission = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(request) {
        var _request$txOptions, req, txHash, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              _context.n = 1;
              return this.checkIsRegistered(request.ipId);
            case 1:
              req = {
                ipAccount: request.ipId,
                signer: request.signer,
                to: request.to,
                func: request.func ? viem.toFunctionSelector(request.func) : defaultFunctionSelector,
                permission: request.permission
              };
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context.n = 2;
                break;
              }
              return _context.a(2, {
                encodedTxData: this.accessControllerClient.setPermissionEncode(req)
              });
            case 2:
              _context.n = 3;
              return this.accessControllerClient.setPermission(req);
            case 3:
              txHash = _context.v;
              _context.n = 4;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 4:
              return _context.a(2, {
                txHash: txHash,
                success: true
              });
            case 5:
              _context.n = 7;
              break;
            case 6:
              _context.p = 6;
              _t = _context.v;
              return _context.a(2, handleError(_t, "Failed to set permissions"));
            case 7:
              return _context.a(2);
          }
        }, _callee, this, [[0, 6]]);
      }));
      function setPermission(_x) {
        return _setPermission.apply(this, arguments);
      }
      return setPermission;
    }()
    /**
     * Specific permission overrides wildcard permission with signature.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
     */
    )
  }, {
    key: "createSetPermissionSignature",
    value: (function () {
      var _createSetPermissionSignature = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(request) {
        var _request$txOptions2, ipId, signer, to, txOptions, func, permission, deadline, ipAccountClient, data, _yield$ipAccountClien, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS, signature, req, txHash, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              _context2.p = 0;
              ipId = request.ipId, signer = request.signer, to = request.to, txOptions = request.txOptions, func = request.func, permission = request.permission, deadline = request.deadline;
              _context2.n = 1;
              return this.checkIsRegistered(ipId);
            case 1:
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              data = viem.encodeFunctionData({
                abi: accessControllerAbi,
                functionName: "setTransientPermission",
                args: [ipId, validateAddress(signer), validateAddress(to), func ? viem.toFunctionSelector(func) : defaultFunctionSelector, permission]
              });
              _context2.n = 2;
              return ipAccountClient.state();
            case 2:
              _yield$ipAccountClien = _context2.v;
              state = _yield$ipAccountClien.result;
              _context2.n = 3;
              return this.rpcClient.getBlock();
            case 3:
              blockTimestamp = _context2.v.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, deadline);
              _context2.n = 4;
              return getPermissionSignature({
                ipId: ipId,
                deadline: calculatedDeadline,
                state: state,
                permissions: [{
                  ipId: ipId,
                  signer: signer,
                  to: to,
                  permission: permission,
                  func: func
                }],
                chainId: this.chainId,
                wallet: this.wallet
              });
            case 4:
              _yield$getPermissionS = _context2.v;
              signature = _yield$getPermissionS.signature;
              req = {
                to: validateAddress(this.accessControllerClient.address),
                value: BigInt(0),
                data: data,
                signer: signer,
                deadline: calculatedDeadline,
                signature: signature
              };
              if (!((_request$txOptions2 = request.txOptions) !== null && _request$txOptions2 !== void 0 && _request$txOptions2.encodedTxDataOnly)) {
                _context2.n = 5;
                break;
              }
              return _context2.a(2, {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 5:
              _context2.n = 6;
              return ipAccountClient.executeWithSig(req);
            case 6:
              txHash = _context2.v;
              _context2.n = 7;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 7:
              return _context2.a(2, {
                txHash: txHash,
                success: true
              });
            case 8:
              _context2.n = 10;
              break;
            case 9:
              _context2.p = 9;
              _t2 = _context2.v;
              return _context2.a(2, handleError(_t2, "Failed to create set permission signature"));
            case 10:
              return _context2.a(2);
          }
        }, _callee2, this, [[0, 9]]);
      }));
      function createSetPermissionSignature(_x2) {
        return _createSetPermissionSignature.apply(this, arguments);
      }
      return createSetPermissionSignature;
    }()
    /**
     * Sets permission to a signer for all functions across all modules.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
     */
    )
  }, {
    key: "setAllPermissions",
    value: (function () {
      var _setAllPermissions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(request) {
        var _request$txOptions3, req, txHash, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              _context3.n = 1;
              return this.checkIsRegistered(request.ipId);
            case 1:
              req = {
                ipAccount: request.ipId,
                signer: request.signer,
                permission: request.permission
              };
              if (!((_request$txOptions3 = request.txOptions) !== null && _request$txOptions3 !== void 0 && _request$txOptions3.encodedTxDataOnly)) {
                _context3.n = 2;
                break;
              }
              return _context3.a(2, {
                encodedTxData: this.accessControllerClient.setAllPermissionsEncode(req)
              });
            case 2:
              _context3.n = 3;
              return this.accessControllerClient.setAllPermissions(req);
            case 3:
              txHash = _context3.v;
              _context3.n = 4;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, request.txOptions), {}, {
                hash: txHash
              }));
            case 4:
              return _context3.a(2, {
                txHash: txHash,
                success: true
              });
            case 5:
              _context3.n = 7;
              break;
            case 6:
              _context3.p = 6;
              _t3 = _context3.v;
              return _context3.a(2, handleError(_t3, "Failed to set all permissions"));
            case 7:
              return _context3.a(2);
          }
        }, _callee3, this, [[0, 6]]);
      }));
      function setAllPermissions(_x3) {
        return _setAllPermissions.apply(this, arguments);
      }
      return setAllPermissions;
    }()
    /**
     * Sets a batch of permissions in a single transaction.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
     */
    )
  }, {
    key: "setBatchPermissions",
    value: (function () {
      var _setBatchPermissions = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(request) {
        var _request$txOptions4, permissions, txOptions, _iterator, _step, permission, req, txHash, _t4, _t5;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              permissions = request.permissions, txOptions = request.txOptions;
              _iterator = _createForOfIteratorHelper(permissions);
              _context4.p = 1;
              _iterator.s();
            case 2:
              if ((_step = _iterator.n()).done) {
                _context4.n = 4;
                break;
              }
              permission = _step.value;
              _context4.n = 3;
              return this.checkIsRegistered(permission.ipId);
            case 3:
              _context4.n = 2;
              break;
            case 4:
              _context4.n = 6;
              break;
            case 5:
              _context4.p = 5;
              _t4 = _context4.v;
              _iterator.e(_t4);
            case 6:
              _context4.p = 6;
              _iterator.f();
              return _context4.f(6);
            case 7:
              req = {
                permissions: permissions.map(function (permission) {
                  return {
                    ipAccount: permission.ipId,
                    signer: permission.signer,
                    to: permission.to,
                    func: permission.func ? viem.toFunctionSelector(permission.func) : defaultFunctionSelector,
                    permission: permission.permission
                  };
                })
              };
              if (!((_request$txOptions4 = request.txOptions) !== null && _request$txOptions4 !== void 0 && _request$txOptions4.encodedTxDataOnly)) {
                _context4.n = 8;
                break;
              }
              return _context4.a(2, {
                encodedTxData: this.accessControllerClient.setBatchPermissionsEncode(req)
              });
            case 8:
              _context4.n = 9;
              return this.accessControllerClient.setBatchPermissions(req);
            case 9:
              txHash = _context4.v;
              _context4.n = 10;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 10:
              return _context4.a(2, {
                txHash: txHash,
                success: true
              });
            case 11:
              _context4.n = 13;
              break;
            case 12:
              _context4.p = 12;
              _t5 = _context4.v;
              return _context4.a(2, handleError(_t5, "Failed to set batch permissions"));
            case 13:
              return _context4.a(2);
          }
        }, _callee4, this, [[1, 5, 6, 7], [0, 12]]);
      }));
      function setBatchPermissions(_x4) {
        return _setBatchPermissions.apply(this, arguments);
      }
      return setBatchPermissions;
    }()
    /**
     * Sets a batch of permissions in a single transaction with signature.
     *
     * Emits an on-chain {@link https://github.com/storyprotocol/protocol-core-v1/blob/v1.3.1/contracts/interfaces/access/IAccessController.sol#L13 | `PermissionSet`} event.
     */
    )
  }, {
    key: "createBatchPermissionSignature",
    value: (function () {
      var _createBatchPermissionSignature = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(request) {
        var _request$txOptions5, permissions, deadline, ipId, txOptions, _iterator2, _step2, permission, ipAccountClient, data, _yield$ipAccountClien2, state, blockTimestamp, calculatedDeadline, _yield$getPermissionS2, signature, req, txHash, _t6, _t7;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              _context5.p = 0;
              permissions = request.permissions, deadline = request.deadline, ipId = request.ipId, txOptions = request.txOptions;
              _iterator2 = _createForOfIteratorHelper(permissions);
              _context5.p = 1;
              _iterator2.s();
            case 2:
              if ((_step2 = _iterator2.n()).done) {
                _context5.n = 4;
                break;
              }
              permission = _step2.value;
              _context5.n = 3;
              return this.checkIsRegistered(permission.ipId);
            case 3:
              _context5.n = 2;
              break;
            case 4:
              _context5.n = 6;
              break;
            case 5:
              _context5.p = 5;
              _t6 = _context5.v;
              _iterator2.e(_t6);
            case 6:
              _context5.p = 6;
              _iterator2.f();
              return _context5.f(6);
            case 7:
              ipAccountClient = new IpAccountImplClient(this.rpcClient, this.wallet, ipId);
              data = viem.encodeFunctionData({
                abi: accessControllerAbi,
                functionName: "setBatchTransientPermissions",
                args: [permissions.map(function (permission) {
                  return {
                    ipAccount: permission.ipId,
                    signer: permission.signer,
                    to: permission.to,
                    func: permission.func ? viem.toFunctionSelector(permission.func) : defaultFunctionSelector,
                    permission: permission.permission
                  };
                })]
              });
              _context5.n = 8;
              return ipAccountClient.state();
            case 8:
              _yield$ipAccountClien2 = _context5.v;
              state = _yield$ipAccountClien2.result;
              _context5.n = 9;
              return this.rpcClient.getBlock();
            case 9:
              blockTimestamp = _context5.v.timestamp;
              calculatedDeadline = getDeadline(blockTimestamp, deadline);
              _context5.n = 10;
              return getPermissionSignature({
                ipId: ipId,
                deadline: calculatedDeadline,
                state: state,
                permissions: permissions,
                chainId: this.chainId,
                wallet: this.wallet
              });
            case 10:
              _yield$getPermissionS2 = _context5.v;
              signature = _yield$getPermissionS2.signature;
              req = {
                to: validateAddress(this.accessControllerClient.address),
                value: BigInt(0),
                data: data,
                signer: validateAddress(this.wallet.account.address),
                deadline: calculatedDeadline,
                signature: signature
              };
              if (!((_request$txOptions5 = request.txOptions) !== null && _request$txOptions5 !== void 0 && _request$txOptions5.encodedTxDataOnly)) {
                _context5.n = 11;
                break;
              }
              return _context5.a(2, {
                encodedTxData: ipAccountClient.executeWithSigEncode(req)
              });
            case 11:
              _context5.n = 12;
              return ipAccountClient.executeWithSig(req);
            case 12:
              txHash = _context5.v;
              _context5.n = 13;
              return this.rpcClient.waitForTransactionReceipt(_objectSpread2(_objectSpread2({}, txOptions), {}, {
                hash: txHash
              }));
            case 13:
              return _context5.a(2, {
                txHash: txHash,
                success: true
              });
            case 14:
              _context5.n = 16;
              break;
            case 15:
              _context5.p = 15;
              _t7 = _context5.v;
              return _context5.a(2, handleError(_t7, "Failed to create batch permission signature"));
            case 16:
              return _context5.a(2);
          }
        }, _callee5, this, [[1, 5, 6, 7], [0, 15]]);
      }));
      function createBatchPermissionSignature(_x5) {
        return _createBatchPermissionSignature.apply(this, arguments);
      }
      return createBatchPermissionSignature;
    }())
  }, {
    key: "checkIsRegistered",
    value: function () {
      var _checkIsRegistered = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(ipId) {
        var isRegistered;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              _context6.n = 1;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(ipId)
              });
            case 1:
              isRegistered = _context6.v;
              if (isRegistered) {
                _context6.n = 2;
                break;
              }
              throw new Error("IP id with ".concat(ipId, " is not registered."));
            case 2:
              return _context6.a(2);
          }
        }, _callee6, this);
      }));
      function checkIsRegistered(_x6) {
        return _checkIsRegistered.apply(this, arguments);
      }
      return checkIsRegistered;
    }()
  }]);
}();

var RoyaltyClient = /*#__PURE__*/function () {
  function RoyaltyClient(rpcClient, wallet, chainId) {
    _classCallCheck(this, RoyaltyClient);
    this.royaltyModuleClient = new RoyaltyModuleClient(rpcClient, wallet);
    this.ipAssetRegistryClient = new IpAssetRegistryClient(rpcClient, wallet);
    this.ipRoyaltyVaultImplReadOnlyClient = new IpRoyaltyVaultImplReadOnlyClient(rpcClient);
    this.ipRoyaltyVaultImplEventClient = new IpRoyaltyVaultImplEventClient(rpcClient);
    this.royaltyWorkflowsClient = new RoyaltyWorkflowsClient(rpcClient, wallet);
    this.multicall3Client = new Multicall3Client(rpcClient, wallet);
    this.wrappedIpClient = new WrappedIpClient(rpcClient, wallet);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
    this.chainId = chainId;
    this.walletAddress = wallet.account.address;
  }

  /**
   * Claims all revenue from the child IPs of an ancestor IP, then transfer
   * all claimed tokens to the wallet if the wallet owns the IP or is the claimer.
   * If claimed token is WIP, it will also be converted back to IP.
   *
   * @remarks
   * Even if there are no child IPs, you must still populate {@link ClaimAllRevenueRequest.currencyTokens} with
   * the token addresses you wish to claim. This is required for the claim operation to know which
   * token balances to process.
   */
  return _createClass(RoyaltyClient, [{
    key: "claimAllRevenue",
    value: (function () {
      var _claimAllRevenue = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(req) {
        var _req$claimOptions, _req$claimOptions2, ancestorIpId, claimer, childIpIds, royaltyPolicies, currencyTokens, txHashes, txHash, receipt, _yield$this$getClaime, ownsClaimer, isClaimerIp, ipAccount, claimedTokens, autoTransfer, autoUnwrapIp, hashes, _hashes, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              _context.p = 0;
              ancestorIpId = validateAddress(req.ancestorIpId);
              claimer = validateAddress(req.claimer);
              childIpIds = validateAddresses(req.childIpIds);
              royaltyPolicies = validateAddresses(req.royaltyPolicies);
              currencyTokens = validateAddresses(req.currencyTokens);
              txHashes = [];
              _context.n = 1;
              return this.royaltyWorkflowsClient.claimAllRevenue({
                ancestorIpId: ancestorIpId,
                claimer: claimer,
                childIpIds: childIpIds,
                royaltyPolicies: royaltyPolicies,
                currencyTokens: currencyTokens
              });
            case 1:
              txHash = _context.v;
              _context.n = 2;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 2:
              receipt = _context.v;
              txHashes.push(txHash);

              // determine if the claimer is an IP owned by the wallet
              _context.n = 3;
              return this.getClaimerInfo(claimer);
            case 3:
              _yield$this$getClaime = _context.v;
              ownsClaimer = _yield$this$getClaime.ownsClaimer;
              isClaimerIp = _yield$this$getClaime.isClaimerIp;
              ipAccount = _yield$this$getClaime.ipAccount;
              claimedTokens = this.ipRoyaltyVaultImplEventClient.parseTxRevenueTokenClaimedEvent(receipt);
              autoTransfer = ((_req$claimOptions = req.claimOptions) === null || _req$claimOptions === void 0 ? void 0 : _req$claimOptions.autoTransferAllClaimedTokensFromIp) !== false;
              autoUnwrapIp = ((_req$claimOptions2 = req.claimOptions) === null || _req$claimOptions2 === void 0 ? void 0 : _req$claimOptions2.autoUnwrapIpTokens) !== false; // transfer claimed tokens from IP to wallet if wallet owns IP
              if (!(autoTransfer && isClaimerIp && ownsClaimer)) {
                _context.n = 5;
                break;
              }
              _context.n = 4;
              return this.transferClaimedTokensFromIpToWallet({
                ipAccount: ipAccount,
                claimedTokens: claimedTokens
              });
            case 4:
              hashes = _context.v;
              txHashes.push.apply(txHashes, _toConsumableArray(hashes));
            case 5:
              if (!(autoUnwrapIp && ownsClaimer)) {
                _context.n = 7;
                break;
              }
              _context.n = 6;
              return this.unwrapWipTokens(claimedTokens);
            case 6:
              _hashes = _context.v;
              if (_hashes) {
                txHashes.push(_hashes);
              }
            case 7:
              return _context.a(2, {
                receipt: receipt,
                claimedTokens: claimedTokens,
                txHashes: txHashes
              });
            case 8:
              _context.p = 8;
              _t = _context.v;
              return _context.a(2, handleError(_t, "Failed to claim all revenue"));
          }
        }, _callee, this, [[0, 8]]);
      }));
      function claimAllRevenue(_x) {
        return _claimAllRevenue.apply(this, arguments);
      }
      return claimAllRevenue;
    }()
    /**
     * Automatically batch claims all revenue from the child IPs of multiple ancestor IPs.
     * if multicall is disabled, it will call @link{claimAllRevenue} for each ancestor IP.
     * Then transfer all claimed tokens to the wallet if the wallet owns the IP or is the claimer.
     * If claimed token is WIP, it will also be converted back to IP.
     *
     * @remarks
     * Even if there are no child IPs, you must still populate `currencyTokens` in each ancestor IP
     * with the token addresses you wish to claim. This is required for the claim operation to know which
     * token balances to process.
     */
    )
  }, {
    key: "batchClaimAllRevenue",
    value: (function () {
      var _batchClaimAllRevenue = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(request) {
        var _this = this;
        var _request$options, _request$claimOptions, _request$claimOptions2, txHashes, receipts, claimedTokens, useMulticallWhenPossible, _iterator, _step, ancestorIp, result, encodedTxs, txHash, receipt, claimedTokenLogs, aggregatedClaimedTokens, claimers, autoTransfer, autoUnwrapIp, wipClaimableAmounts, _iterator2, _step2, _loop, hash, _t2, _t3, _t4;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              txHashes = [];
              receipts = [];
              claimedTokens = []; // if the number of ancestor IPs is 1 or if multicall is disabled, then just call claimAllRevenue.
              useMulticallWhenPossible = ((_request$options = request.options) === null || _request$options === void 0 ? void 0 : _request$options.useMulticallWhenPossible) !== false;
              if (!(request.ancestorIps.length === 1 || !useMulticallWhenPossible)) {
                _context3.n = 9;
                break;
              }
              _iterator = _createForOfIteratorHelper(request.ancestorIps);
              _context3.p = 1;
              _iterator.s();
            case 2:
              if ((_step = _iterator.n()).done) {
                _context3.n = 5;
                break;
              }
              ancestorIp = _step.value;
              _context3.n = 3;
              return this.claimAllRevenue(_objectSpread2(_objectSpread2({}, ancestorIp), {}, {
                ancestorIpId: ancestorIp.ipId,
                claimOptions: {
                  autoTransferAllClaimedTokensFromIp: false,
                  autoUnwrapIpTokens: false
                }
              }));
            case 3:
              result = _context3.v;
              txHashes.push.apply(txHashes, _toConsumableArray(result.txHashes));
              receipts.push(result.receipt);
              if (result.claimedTokens) {
                claimedTokens.push.apply(claimedTokens, _toConsumableArray(result.claimedTokens));
              }
            case 4:
              _context3.n = 2;
              break;
            case 5:
              _context3.n = 7;
              break;
            case 6:
              _context3.p = 6;
              _t2 = _context3.v;
              _iterator.e(_t2);
            case 7:
              _context3.p = 7;
              _iterator.f();
              return _context3.f(7);
            case 8:
              _context3.n = 12;
              break;
            case 9:
              // Batch claimAllRevenue the calls into a single multicall
              encodedTxs = request.ancestorIps.map(function (_ref) {
                var ipId = _ref.ipId,
                  claimer = _ref.claimer,
                  childIpIds = _ref.childIpIds,
                  royaltyPolicies = _ref.royaltyPolicies,
                  currencyTokens = _ref.currencyTokens;
                var claim = {
                  ancestorIpId: validateAddress(ipId),
                  claimer: validateAddress(claimer),
                  childIpIds: validateAddresses(childIpIds),
                  royaltyPolicies: validateAddresses(royaltyPolicies),
                  currencyTokens: validateAddresses(currencyTokens)
                };
                return _this.royaltyWorkflowsClient.claimAllRevenueEncode(claim).data;
              });
              _context3.n = 10;
              return this.royaltyWorkflowsClient.multicall({
                data: encodedTxs
              });
            case 10:
              txHash = _context3.v;
              _context3.n = 11;
              return this.rpcClient.waitForTransactionReceipt({
                hash: txHash
              });
            case 11:
              receipt = _context3.v;
              txHashes.push(txHash);
              receipts.push(receipt);
              claimedTokenLogs = this.ipRoyaltyVaultImplEventClient.parseTxRevenueTokenClaimedEvent(receipt);
              claimedTokens.push.apply(claimedTokens, _toConsumableArray(claimedTokenLogs));
            case 12:
              // Aggregate claimed tokens by claimer and token address
              aggregatedClaimedTokens = Object.values(claimedTokens.reduce(function (acc, curr) {
                var key = "".concat(curr.claimer, "_").concat(curr.token);
                if (!acc[key]) {
                  acc[key] = _objectSpread2({}, curr);
                } else {
                  acc[key].amount += curr.amount;
                }
                return acc;
              }, {}));
              claimers = _toConsumableArray(new Set(request.ancestorIps.map(function (_ref2) {
                var claimer = _ref2.claimer;
                return claimer;
              })));
              autoTransfer = ((_request$claimOptions = request.claimOptions) === null || _request$claimOptions === void 0 ? void 0 : _request$claimOptions.autoTransferAllClaimedTokensFromIp) !== false;
              autoUnwrapIp = ((_request$claimOptions2 = request.claimOptions) === null || _request$claimOptions2 === void 0 ? void 0 : _request$claimOptions2.autoUnwrapIpTokens) !== false;
              wipClaimableAmounts = 0n;
              _iterator2 = _createForOfIteratorHelper(claimers);
              _context3.p = 13;
              _loop = /*#__PURE__*/_regenerator().m(function _loop() {
                var claimer, _yield$_this$getClaim, ownsClaimer, isClaimerIp, ipAccount, filterClaimedTokens, hashes;
                return _regenerator().w(function (_context2) {
                  while (1) switch (_context2.n) {
                    case 0:
                      claimer = _step2.value;
                      _context2.n = 1;
                      return _this.getClaimerInfo(claimer);
                    case 1:
                      _yield$_this$getClaim = _context2.v;
                      ownsClaimer = _yield$_this$getClaim.ownsClaimer;
                      isClaimerIp = _yield$_this$getClaim.isClaimerIp;
                      ipAccount = _yield$_this$getClaim.ipAccount;
                      if (ownsClaimer) {
                        _context2.n = 2;
                        break;
                      }
                      return _context2.a(2, 1);
                    case 2:
                      filterClaimedTokens = aggregatedClaimedTokens.filter(function (item) {
                        return item.claimer === claimer;
                      }); // transfer claimed tokens from IP to wallet if wallet owns IP
                      if (!(autoTransfer && isClaimerIp && ownsClaimer)) {
                        _context2.n = 4;
                        break;
                      }
                      _context2.n = 3;
                      return _this.transferClaimedTokensFromIpToWallet({
                        ipAccount: ipAccount,
                        claimedTokens: filterClaimedTokens
                      });
                    case 3:
                      hashes = _context2.v;
                      txHashes.push.apply(txHashes, _toConsumableArray(hashes));
                    case 4:
                      // Sum up the amount of WIP tokens claimed
                      wipClaimableAmounts += filterClaimedTokens.reduce(function (acc, curr) {
                        if (curr.token === WIP_TOKEN_ADDRESS) {
                          return acc + curr.amount;
                        }
                        return acc;
                      }, 0n);
                    case 5:
                      return _context2.a(2);
                  }
                }, _loop);
              });
              _iterator2.s();
            case 14:
              if ((_step2 = _iterator2.n()).done) {
                _context3.n = 17;
                break;
              }
              return _context3.d(_regeneratorValues(_loop()), 15);
            case 15:
              if (!_context3.v) {
                _context3.n = 16;
                break;
              }
              return _context3.a(3, 16);
            case 16:
              _context3.n = 14;
              break;
            case 17:
              _context3.n = 19;
              break;
            case 18:
              _context3.p = 18;
              _t3 = _context3.v;
              _iterator2.e(_t3);
            case 19:
              _context3.p = 19;
              _iterator2.f();
              return _context3.f(19);
            case 20:
              if (!(wipClaimableAmounts > 0n && autoUnwrapIp)) {
                _context3.n = 22;
                break;
              }
              _context3.n = 21;
              return this.unwrapWipTokens([{
                token: WIP_TOKEN_ADDRESS,
                amount: wipClaimableAmounts,
                claimer: this.walletAddress
              }]);
            case 21:
              hash = _context3.v;
              if (hash) {
                txHashes.push(hash);
              }
            case 22:
              return _context3.a(2, {
                receipts: receipts,
                claimedTokens: aggregatedClaimedTokens,
                txHashes: txHashes
              });
            case 23:
              _context3.p = 23;
              _t4 = _context3.v;
              return _context3.a(2, handleError(new Error(_t4.message.replace("Failed to claim all revenue: ", "").trim()), "Failed to batch claim all revenue"));
          }
        }, _callee2, this, [[13, 18, 19, 20], [1, 6, 7, 8], [0, 23]]);
      }));
      function batchClaimAllRevenue(_x2) {
        return _batchClaimAllRevenue.apply(this, arguments);
      }
      return batchClaimAllRevenue;
    }()
    /**
     * Allows the function caller to pay royalties to the receiver IP asset on behalf of the payer IP asset.
     */
    )
  }, {
    key: "payRoyaltyOnBehalf",
    value: (function () {
      var _payRoyaltyOnBehalf = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(request) {
        var _this2 = this;
        var _request$txOptions, receiverIpId, payerIpId, token, amount, options, txOptions, sender, payAmount, isReceiverRegistered, isPayerRegistered, req, encodedTxData, contractCall, tokenSpenders, _t5;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.p = _context4.n) {
            case 0:
              _context4.p = 0;
              receiverIpId = request.receiverIpId, payerIpId = request.payerIpId, token = request.token, amount = request.amount, options = request.options, txOptions = request.txOptions;
              sender = this.wallet.account.address;
              payAmount = BigInt(amount);
              if (!(payAmount <= 0n)) {
                _context4.n = 1;
                break;
              }
              throw new Error("The amount to pay must be number greater than 0.");
            case 1:
              _context4.n = 2;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(receiverIpId)
              });
            case 2:
              isReceiverRegistered = _context4.v;
              if (isReceiverRegistered) {
                _context4.n = 3;
                break;
              }
              throw new Error("The receiver IP with id ".concat(receiverIpId, " is not registered."));
            case 3:
              if (!(validateAddress(payerIpId) && payerIpId !== viem.zeroAddress)) {
                _context4.n = 5;
                break;
              }
              _context4.n = 4;
              return this.ipAssetRegistryClient.isRegistered({
                id: payerIpId
              });
            case 4:
              isPayerRegistered = _context4.v;
              if (isPayerRegistered) {
                _context4.n = 5;
                break;
              }
              throw new Error("The payer IP with id ".concat(request.payerIpId, " is not registered."));
            case 5:
              req = {
                receiverIpId: receiverIpId,
                payerIpId: payerIpId,
                token: validateAddress(token),
                amount: BigInt(amount)
              };
              encodedTxData = this.royaltyModuleClient.payRoyaltyOnBehalfEncode(req);
              if (!((_request$txOptions = request.txOptions) !== null && _request$txOptions !== void 0 && _request$txOptions.encodedTxDataOnly)) {
                _context4.n = 6;
                break;
              }
              return _context4.a(2, {
                encodedTxData: encodedTxData
              });
            case 6:
              contractCall = function contractCall() {
                return _this2.royaltyModuleClient.payRoyaltyOnBehalf(req);
              };
              tokenSpenders = [{
                address: this.royaltyModuleClient.address,
                amount: payAmount,
                token: token
              }];
              _context4.n = 7;
              return contractCallWithFees({
                options: options,
                multicall3Address: this.multicall3Client.address,
                rpcClient: this.rpcClient,
                tokenSpenders: tokenSpenders,
                contractCall: contractCall,
                sender: sender,
                wallet: this.wallet,
                txOptions: txOptions,
                encodedTxs: [encodedTxData]
              });
            case 7:
              return _context4.a(2, _context4.v);
            case 8:
              _context4.p = 8;
              _t5 = _context4.v;
              return _context4.a(2, handleError(_t5, "Failed to pay royalty on behalf"));
          }
        }, _callee3, this, [[0, 8]]);
      }));
      function payRoyaltyOnBehalf(_x3) {
        return _payRoyaltyOnBehalf.apply(this, arguments);
      }
      return payRoyaltyOnBehalf;
    }()
    /**
     * Get total amount of revenue token claimable by a royalty token holder.
     * Returns the amount of revenue token claimable by the claimer.
     */
    )
  }, {
    key: "claimableRevenue",
    value: (function () {
      var _claimableRevenue = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(request) {
        var proxyAddress, ipRoyaltyVault, _t6;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              _context5.p = 0;
              _context5.n = 1;
              return this.getRoyaltyVaultAddress(validateAddress(request.ipId));
            case 1:
              proxyAddress = _context5.v;
              ipRoyaltyVault = new IpRoyaltyVaultImplReadOnlyClient(this.rpcClient, proxyAddress);
              _context5.n = 2;
              return ipRoyaltyVault.claimableRevenue({
                claimer: validateAddress(request.claimer),
                token: validateAddress(request.token)
              });
            case 2:
              return _context5.a(2, _context5.v);
            case 3:
              _context5.p = 3;
              _t6 = _context5.v;
              return _context5.a(2, handleError(_t6, "Failed to calculate claimable revenue"));
          }
        }, _callee4, this, [[0, 3]]);
      }));
      function claimableRevenue(_x4) {
        return _claimableRevenue.apply(this, arguments);
      }
      return claimableRevenue;
    }()
    /**
     * Get the royalty vault proxy address of given ip id of the royalty vault.
     */
    )
  }, {
    key: "getRoyaltyVaultAddress",
    value: (function () {
      var _getRoyaltyVaultAddress = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(ipId) {
        var isRoyaltyVaultIpIdRegistered;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.n) {
            case 0:
              _context6.n = 1;
              return this.ipAssetRegistryClient.isRegistered({
                id: validateAddress(ipId)
              });
            case 1:
              isRoyaltyVaultIpIdRegistered = _context6.v;
              if (isRoyaltyVaultIpIdRegistered) {
                _context6.n = 2;
                break;
              }
              throw new Error("The royalty vault IP with id ".concat(ipId, " is not registered."));
            case 2:
              _context6.n = 3;
              return this.royaltyModuleClient.ipRoyaltyVaults({
                ipId: ipId
              });
            case 3:
              return _context6.a(2, _context6.v);
          }
        }, _callee5, this);
      }));
      function getRoyaltyVaultAddress(_x5) {
        return _getRoyaltyVaultAddress.apply(this, arguments);
      }
      return getRoyaltyVaultAddress;
    }()
    /**
     * Transfers to vault an amount of revenue tokens claimable via a royalty policy.
     */
    )
  }, {
    key: "transferToVault",
    value: (function () {
      var _transferToVault = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(_ref3) {
        var txOptions, ipId, royaltyPolicy, ancestorIpId, token, royaltyPolicyAddress, protocolArgs, _yield$this$rpcClient, call, txHash;
        return _regenerator().w(function (_context7) {
          while (1) switch (_context7.n) {
            case 0:
              txOptions = _ref3.txOptions, ipId = _ref3.ipId, royaltyPolicy = _ref3.royaltyPolicy, ancestorIpId = _ref3.ancestorIpId, token = _ref3.token;
              royaltyPolicyAddress = royaltyPolicyInputToAddress(royaltyPolicy, this.chainId);
              protocolArgs = [validateAddress(ipId), validateAddress(ancestorIpId), validateAddress(token)];
              _context7.n = 1;
              return this.rpcClient.simulateContract({
                abi: royaltyPolicyLrpAbi,
                // same abi for all royalty policies
                address: royaltyPolicyAddress,
                functionName: "transferToVault",
                account: this.wallet.account,
                args: protocolArgs
              });
            case 1:
              _yield$this$rpcClient = _context7.v;
              call = _yield$this$rpcClient.request;
              _context7.n = 2;
              return this.wallet.writeContract(call);
            case 2:
              txHash = _context7.v;
              return _context7.a(2, waitForTxReceipt({
                txHash: txHash,
                rpcClient: this.rpcClient,
                txOptions: txOptions
              }));
          }
        }, _callee6, this);
      }));
      function transferToVault(_x6) {
        return _transferToVault.apply(this, arguments);
      }
      return transferToVault;
    }())
  }, {
    key: "transferClaimedTokensFromIpToWallet",
    value: function () {
      var _transferClaimedTokensFromIpToWallet = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee7(_ref4) {
        var ipAccount, claimedTokens, txHashes, calls, _iterator3, _step3, _step3$value, token, amount, hash;
        return _regenerator().w(function (_context8) {
          while (1) switch (_context8.n) {
            case 0:
              ipAccount = _ref4.ipAccount, claimedTokens = _ref4.claimedTokens;
              txHashes = [];
              calls = [];
              _iterator3 = _createForOfIteratorHelper(claimedTokens);
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  _step3$value = _step3.value, token = _step3$value.token, amount = _step3$value.amount;
                  calls.push({
                    target: token,
                    value: BigInt(0),
                    data: viem.encodeFunctionData({
                      abi: viem.erc20Abi,
                      functionName: "transfer",
                      args: [this.walletAddress, amount]
                    })
                  });
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
              _context8.n = 1;
              return ipAccount.executeBatch({
                calls: calls,
                operation: 0
              });
            case 1:
              hash = _context8.v;
              _context8.n = 2;
              return this.rpcClient.waitForTransactionReceipt({
                hash: hash
              });
            case 2:
              txHashes.push(hash);
              return _context8.a(2, txHashes);
          }
        }, _callee7, this);
      }));
      function transferClaimedTokensFromIpToWallet(_x7) {
        return _transferClaimedTokensFromIpToWallet.apply(this, arguments);
      }
      return transferClaimedTokensFromIpToWallet;
    }()
  }, {
    key: "getClaimerInfo",
    value: function () {
      var _getClaimerInfo = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee8(claimer) {
        var isClaimerIp, ipAccount, ownsClaimer, ipOwner;
        return _regenerator().w(function (_context9) {
          while (1) switch (_context9.n) {
            case 0:
              _context9.n = 1;
              return this.ipAssetRegistryClient.isRegistered({
                id: claimer
              });
            case 1:
              isClaimerIp = _context9.v;
              ipAccount = new IpAccountImplClient(this.rpcClient, this.wallet, claimer);
              ownsClaimer = claimer === this.walletAddress;
              if (!isClaimerIp) {
                _context9.n = 3;
                break;
              }
              _context9.n = 2;
              return ipAccount.owner();
            case 2:
              ipOwner = _context9.v;
              ownsClaimer = ipOwner === this.walletAddress;
            case 3:
              return _context9.a(2, {
                ownsClaimer: ownsClaimer,
                isClaimerIp: isClaimerIp,
                ipAccount: ipAccount
              });
          }
        }, _callee8, this);
      }));
      function getClaimerInfo(_x8) {
        return _getClaimerInfo.apply(this, arguments);
      }
      return getClaimerInfo;
    }()
    /**
     * Unwraps WIP tokens back to their underlying IP tokens. Only accepts a single WIP token entry
     * in the claimed tokens array. Throws an error if multiple WIP tokens are found.
     */
  }, {
    key: "unwrapWipTokens",
    value: (function () {
      var _unwrapWipTokens = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee9(claimedTokens) {
        var wipTokens, wipToken, hash;
        return _regenerator().w(function (_context0) {
          while (1) switch (_context0.n) {
            case 0:
              wipTokens = claimedTokens.filter(function (token) {
                return token.token === WIP_TOKEN_ADDRESS;
              });
              if (!(wipTokens.length > 1)) {
                _context0.n = 1;
                break;
              }
              throw new Error("Multiple WIP tokens found in the claimed tokens.");
            case 1:
              wipToken = wipTokens[0];
              if (!(!wipToken || wipToken.amount <= 0n)) {
                _context0.n = 2;
                break;
              }
              return _context0.a(2);
            case 2:
              _context0.n = 3;
              return this.wrappedIpClient.withdraw({
                value: wipToken.amount
              });
            case 3:
              hash = _context0.v;
              _context0.n = 4;
              return this.rpcClient.waitForTransactionReceipt({
                hash: hash
              });
            case 4:
              return _context0.a(2, hash);
          }
        }, _callee9, this);
      }));
      function unwrapWipTokens(_x9) {
        return _unwrapWipTokens.apply(this, arguments);
      }
      return unwrapWipTokens;
    }())
  }]);
}();

var WipClient = /*#__PURE__*/function () {
  function WipClient(rpcClient, wallet) {
    _classCallCheck(this, WipClient);
    this.wrappedIpClient = new WrappedIpClient(rpcClient, wallet, WIP_TOKEN_ADDRESS);
    this.rpcClient = rpcClient;
    this.wallet = wallet;
  }

  /**
   * Wraps the selected amount of IP to WIP.
   * The WIP will be deposited to the wallet that transferred the IP.
   */
  return _createClass(WipClient, [{
    key: "deposit",
    value: (function () {
      var _deposit = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(_ref) {
        var amount, txOptions, _yield$this$rpcClient, call, txHash, _t;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.p = _context.n) {
            case 0:
              amount = _ref.amount, txOptions = _ref.txOptions;
              _context.p = 1;
              if (!(amount <= 0)) {
                _context.n = 2;
                break;
              }
              throw new Error("WIP deposit amount must be greater than 0.");
            case 2:
              _context.n = 3;
              return this.rpcClient.simulateContract({
                abi: wrappedIpAbi,
                address: WIP_TOKEN_ADDRESS,
                functionName: "deposit",
                account: this.wallet.account,
                value: BigInt(amount)
              });
            case 3:
              _yield$this$rpcClient = _context.v;
              call = _yield$this$rpcClient.request;
              _context.n = 4;
              return this.wallet.writeContract(call);
            case 4:
              txHash = _context.v;
              return _context.a(2, waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 5:
              _context.p = 5;
              _t = _context.v;
              return _context.a(2, handleError(_t, "Failed to deposit IP for WIP"));
          }
        }, _callee, this, [[1, 5]]);
      }));
      function deposit(_x) {
        return _deposit.apply(this, arguments);
      }
      return deposit;
    }()
    /**
     * Unwraps the selected amount of WIP to IP.
     */
    )
  }, {
    key: "withdraw",
    value: (function () {
      var _withdraw = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(_ref2) {
        var amount, txOptions, targetAmt, txHash, _t2;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.p = _context2.n) {
            case 0:
              amount = _ref2.amount, txOptions = _ref2.txOptions;
              _context2.p = 1;
              targetAmt = BigInt(amount);
              if (!(targetAmt <= 0)) {
                _context2.n = 2;
                break;
              }
              throw new Error("WIP withdraw amount must be greater than 0.");
            case 2:
              _context2.n = 3;
              return this.wrappedIpClient.withdraw({
                value: targetAmt
              });
            case 3:
              txHash = _context2.v;
              return _context2.a(2, waitForTxReceipt({
                txHash: txHash,
                txOptions: txOptions,
                rpcClient: this.rpcClient
              }));
            case 4:
              _context2.p = 4;
              _t2 = _context2.v;
              return _context2.a(2, handleError(_t2, "Failed to withdraw WIP"));
          }
        }, _callee2, this, [[1, 4]]);
      }));
      function withdraw(_x2) {
        return _withdraw.apply(this, arguments);
      }
      return withdraw;
    }()
    /**
     * Approve a spender to use the wallet's WIP balance.
     */
    )
  }, {
    key: "approve",
    value: (function () {
      var _approve = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(req) {
        var amount, spender, txHash, _t3;
        return _regenerator().w(function (_context3) {
          while (1) switch (_context3.p = _context3.n) {
            case 0:
              _context3.p = 0;
              amount = BigInt(req.amount);
              if (!(amount <= 0)) {
                _context3.n = 1;
                break;
              }
              throw new Error("WIP approve amount must be greater than 0.");
            case 1:
              spender = validateAddress(req.spender);
              _context3.n = 2;
              return this.wrappedIpClient.approve({
                spender: spender,
                amount: amount
              });
            case 2:
              txHash = _context3.v;
              return _context3.a(2, waitForTxReceipt({
                txHash: txHash,
                txOptions: req.txOptions,
                rpcClient: this.rpcClient
              }));
            case 3:
              _context3.p = 3;
              _t3 = _context3.v;
              return _context3.a(2, handleError(_t3, "Failed to approve WIP"));
          }
        }, _callee3, this, [[0, 3]]);
      }));
      function approve(_x3) {
        return _approve.apply(this, arguments);
      }
      return approve;
    }()
    /**
     * Returns the balance of WIP for an address.
     */
    )
  }, {
    key: "balanceOf",
    value: (function () {
      var _balanceOf = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(addr) {
        var owner, ret;
        return _regenerator().w(function (_context4) {
          while (1) switch (_context4.n) {
            case 0:
              owner = validateAddress(addr);
              _context4.n = 1;
              return this.wrappedIpClient.balanceOf({
                owner: owner
              });
            case 1:
              ret = _context4.v;
              return _context4.a(2, ret.result);
          }
        }, _callee4, this);
      }));
      function balanceOf(_x4) {
        return _balanceOf.apply(this, arguments);
      }
      return balanceOf;
    }()
    /**
     * Transfers `amount` of WIP to a recipient `to`.
     */
    )
  }, {
    key: "transfer",
    value: (function () {
      var _transfer = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(request) {
        var amount, txHash, _t4;
        return _regenerator().w(function (_context5) {
          while (1) switch (_context5.p = _context5.n) {
            case 0:
              _context5.p = 0;
              amount = BigInt(request.amount);
              if (!(amount <= 0)) {
                _context5.n = 1;
                break;
              }
              throw new Error("WIP transfer amount must be greater than 0.");
            case 1:
              _context5.n = 2;
              return this.wrappedIpClient.transfer({
                to: validateAddress(request.to),
                amount: amount
              });
            case 2:
              txHash = _context5.v;
              return _context5.a(2, waitForTxReceipt({
                txHash: txHash,
                txOptions: request.txOptions,
                rpcClient: this.rpcClient
              }));
            case 3:
              _context5.p = 3;
              _t4 = _context5.v;
              return _context5.a(2, handleError(_t4, "Failed to transfer WIP"));
          }
        }, _callee5, this, [[0, 3]]);
      }));
      function transfer(_x5) {
        return _transfer.apply(this, arguments);
      }
      return transfer;
    }()
    /**
     * Transfers `amount` of WIP from `from` to a recipient `to`.
     */
    )
  }, {
    key: "transferFrom",
    value: (function () {
      var _transferFrom = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee6(request) {
        var amount, txHash, _t5;
        return _regenerator().w(function (_context6) {
          while (1) switch (_context6.p = _context6.n) {
            case 0:
              _context6.p = 0;
              amount = BigInt(request.amount);
              if (!(amount <= 0)) {
                _context6.n = 1;
                break;
              }
              throw new Error("WIP transfer amount must be greater than 0.");
            case 1:
              _context6.n = 2;
              return this.wrappedIpClient.transferFrom({
                to: validateAddress(request.to),
                amount: amount,
                from: validateAddress(request.from)
              });
            case 2:
              txHash = _context6.v;
              return _context6.a(2, waitForTxReceipt({
                txHash: txHash,
                txOptions: request.txOptions,
                rpcClient: this.rpcClient
              }));
            case 3:
              _context6.p = 3;
              _t5 = _context6.v;
              return _context6.a(2, handleError(_t5, "Failed to transfer WIP"));
          }
        }, _callee6, this, [[0, 3]]);
      }));
      function transferFrom(_x6) {
        return _transferFrom.apply(this, arguments);
      }
      return transferFrom;
    }())
  }]);
}();

if (typeof process !== "undefined") {
  dotenv__namespace.config();
}
/**
 * The StoryClient is the main entry point for the SDK.
 */
var StoryClient = /*#__PURE__*/function () {
  function StoryClient(config) {
    _classCallCheck(this, StoryClient);
    _defineProperty(this, "_ipAsset", null);
    _defineProperty(this, "_permission", null);
    _defineProperty(this, "_license", null);
    _defineProperty(this, "_dispute", null);
    _defineProperty(this, "_ipAccount", null);
    _defineProperty(this, "_royalty", null);
    _defineProperty(this, "_nftClient", null);
    _defineProperty(this, "_group", null);
    _defineProperty(this, "_wip", null);
    this.config = _objectSpread2(_objectSpread2({}, config), {}, {
      chainId: chain[config.chainId || 1315]
    });
    if (!this.config.transport) {
      throw new Error("transport is null, please pass in a valid RPC Provider URL as the transport.");
    }
    var clientConfig = {
      chain: chainStringToViemChain(this.chainId),
      transport: this.config.transport
    };
    this.rpcClient = viem.createPublicClient(clientConfig);
    if (this.config.wallet) {
      this.wallet = this.config.wallet;
    } else if (this.config.account) {
      var account = this.config.account;
      this.wallet = viem.createWalletClient(_objectSpread2(_objectSpread2({}, clientConfig), {}, {
        account: account
      }));
    } else {
      throw new Error("must specify a wallet or account");
    }
  }
  return _createClass(StoryClient, [{
    key: "chainId",
    get: function get() {
      return this.config.chainId;
    }

    /**
     * Factory method for creating an SDK client with a signer.
     *
     */
  }, {
    key: "ipAsset",
    get:
    /**
     * Getter for the ip asset client. The client is lazily created when
     * this method is called.
     */
    function get() {
      if (this._ipAsset === null) {
        this._ipAsset = new IPAssetClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._ipAsset;
    }

    /**
     * Getter for the permission client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "permission",
    get: function get() {
      if (this._permission === null) {
        this._permission = new PermissionClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._permission;
    }

    /**
     * Getter for the license client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "license",
    get: function get() {
      if (this._license === null) {
        this._license = new LicenseClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._license;
    }

    /**
     * Getter for the dispute client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "dispute",
    get: function get() {
      if (this._dispute === null) {
        this._dispute = new DisputeClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._dispute;
    }

    /**
     * Getter for the ip account client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "ipAccount",
    get: function get() {
      if (this._ipAccount === null) {
        this._ipAccount = new IPAccountClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._ipAccount;
    }

    /**
     * Getter for the royalty client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "royalty",
    get: function get() {
      if (this._royalty === null) {
        this._royalty = new RoyaltyClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._royalty;
    }

    /**
     * Getter for the NFT client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "nftClient",
    get: function get() {
      if (this._nftClient === null) {
        this._nftClient = new NftClient(this.rpcClient, this.wallet);
      }
      return this._nftClient;
    }

    /**
     * Getter for the group client. The client is lazily created when
     * this method is called.
     */
  }, {
    key: "groupClient",
    get: function get() {
      if (this._group === null) {
        this._group = new GroupClient(this.rpcClient, this.wallet, this.chainId);
      }
      return this._group;
    }
  }, {
    key: "wipClient",
    get: function get() {
      if (this._wip === null) {
        this._wip = new WipClient(this.rpcClient, this.wallet);
      }
      return this._wip;
    }
  }, {
    key: "getWalletBalance",
    value: function () {
      var _getWalletBalance = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (this.wallet.account) {
                _context.n = 1;
                break;
              }
              throw new Error("No account found in wallet");
            case 1:
              _context.n = 2;
              return this.getBalance(this.wallet.account.address);
            case 2:
              return _context.a(2, _context.v);
          }
        }, _callee, this);
      }));
      function getWalletBalance() {
        return _getWalletBalance.apply(this, arguments);
      }
      return getWalletBalance;
    }()
  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(address) {
        var validAddress;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              validAddress = validateAddress(address);
              _context2.n = 1;
              return this.rpcClient.getBalance({
                address: validAddress
              });
            case 1:
              return _context2.a(2, _context2.v);
          }
        }, _callee2, this);
      }));
      function getBalance(_x) {
        return _getBalance.apply(this, arguments);
      }
      return getBalance;
    }()
  }], [{
    key: "newClient",
    value: function newClient(config) {
      return new StoryClient(config);
    }

    /**
     * Factory method for creating an SDK client with a signer.
     */
  }, {
    key: "newClientUseWallet",
    value: function newClientUseWallet(config) {
      return new StoryClient({
        chainId: config.chainId,
        transport: config.transport,
        wallet: config.wallet
      });
    }

    /**
     * Factory method for creating an SDK client with a signer.
     */
  }, {
    key: "newClientUseAccount",
    value: function newClientUseAccount(config) {
      return new StoryClient({
        account: config.account,
        chainId: config.chainId,
        transport: config.transport
      });
    }
  }]);
}();

/**
 * IPA Metadata Standard Parameters
 *
 * This is the metadata that is associated with an IP Asset,
 * and gets stored inside of an IP Account.
 *
 * @see {@link https://docs.story.foundation/docs/ipa-metadata-standard|IPA Metadata Standard Docs}
 */

/**
 * Experimental ip metadata fields that are not required but may be
 * considered for future use.
 */

/**
 * Enum representing the various relationship types in a story narrative.
 */
var StoryRelationship = /*#__PURE__*/function (StoryRelationship) {
  /** A character appears in a chapter. */
  StoryRelationship["APPEARS_IN"] = "APPEARS_IN";
  /** A chapter belongs to a book. */
  StoryRelationship["BELONGS_TO"] = "BELONGS_TO";
  /** A book is part of a series. */
  StoryRelationship["PART_OF"] = "PART_OF";
  /** A chapter continues from the previous one. */
  StoryRelationship["CONTINUES_FROM"] = "CONTINUES_FROM";
  /** An event leads to a consequence. */
  StoryRelationship["LEADS_TO"] = "LEADS_TO";
  /** An event foreshadows future developments. */
  StoryRelationship["FORESHADOWS"] = "FORESHADOWS";
  /** A character conflicts with another character. */
  StoryRelationship["CONFLICTS_WITH"] = "CONFLICTS_WITH";
  /** A decision results in a significant change. */
  StoryRelationship["RESULTS_IN"] = "RESULTS_IN";
  /** A subplot depends on the main plot. */
  StoryRelationship["DEPENDS_ON"] = "DEPENDS_ON";
  /** A prologue sets up the story. */
  StoryRelationship["SETS_UP"] = "SETS_UP";
  /** A chapter follows from the previous one. */
  StoryRelationship["FOLLOWS_FROM"] = "FOLLOWS_FROM";
  /** A twist reveals that something unexpected occurred. */
  StoryRelationship["REVEALS_THAT"] = "REVEALS_THAT";
  /** A character develops over the course of the story. */
  StoryRelationship["DEVELOPS_OVER"] = "DEVELOPS_OVER";
  /** A chapter introduces a new character or element. */
  StoryRelationship["INTRODUCES"] = "INTRODUCES";
  /** A conflict resolves in a particular outcome. */
  StoryRelationship["RESOLVES_IN"] = "RESOLVES_IN";
  /** A theme connects to the main narrative. */
  StoryRelationship["CONNECTS_TO"] = "CONNECTS_TO";
  /** A subplot relates to the central theme. */
  StoryRelationship["RELATES_TO"] = "RELATES_TO";
  /** A scene transitions from one setting to another. */
  StoryRelationship["TRANSITIONS_FROM"] = "TRANSITIONS_FROM";
  /** A character interacted with another character. */
  StoryRelationship["INTERACTED_WITH"] = "INTERACTED_WITH";
  /** An event leads into the climax. */
  StoryRelationship["LEADS_INTO"] = "LEADS_INTO";
  /** Story happening in parallel or around the same timeframe. */
  StoryRelationship["PARALLEL"] = "PARALLEL";
  return StoryRelationship;
}({});

/**
 * Enum representing the different relationship types for AI-related metadata.
 */
var AIRelationship = /*#__PURE__*/function (AIRelationship) {
  /** A model is trained on a dataset. */
  AIRelationship["TRAINED_ON"] = "TRAINED_ON";
  /** A model is finetuned from a base model. */
  AIRelationship["FINETUNED_FROM"] = "FINETUNED_FROM";
  /** An image is generated from a fine-tuned model. */
  AIRelationship["GENERATED_FROM"] = "GENERATED_FROM";
  /** A model requires data for training. */
  AIRelationship["REQUIRES_DATA"] = "REQUIRES_DATA";
  /** A remix is based on a specific workflow. */
  AIRelationship["BASED_ON"] = "BASED_ON";
  /** Sample data influences model output. */
  AIRelationship["INFLUENCES"] = "INFLUENCES";
  /** A pipeline creates a fine-tuned model. */
  AIRelationship["CREATES"] = "CREATES";
  /** A workflow utilizes a base model. */
  AIRelationship["UTILIZES"] = "UTILIZES";
  /** A fine-tuned model is derived from a base model. */
  AIRelationship["DERIVED_FROM"] = "DERIVED_FROM";
  /** A model produces generated images. */
  AIRelationship["PRODUCES"] = "PRODUCES";
  /** A remix modifies the base workflow. */
  AIRelationship["MODIFIES"] = "MODIFIES";
  /** An AI-generated image references original data. */
  AIRelationship["REFERENCES"] = "REFERENCES";
  /** A model is optimized by specific algorithms. */
  AIRelationship["OPTIMIZED_BY"] = "OPTIMIZED_BY";
  /** A fine-tuned model inherits features from the base model. */
  AIRelationship["INHERITS"] = "INHERITS";
  /** A fine-tuning process applies to a model. */
  AIRelationship["APPLIES_TO"] = "APPLIES_TO";
  /** A remix combines elements from multiple datasets. */
  AIRelationship["COMBINES"] = "COMBINES";
  /** A model generates variants of an image. */
  AIRelationship["GENERATES_VARIANTS"] = "GENERATES_VARIANTS";
  /** A fine-tuning process expands on base capabilities. */
  AIRelationship["EXPANDS_ON"] = "EXPANDS_ON";
  /** A workflow configures a models parameters. */
  AIRelationship["CONFIGURES"] = "CONFIGURES";
  /** A fine-tuned model adapts to new data. */
  AIRelationship["ADAPTS_TO"] = "ADAPTS_TO";
  return AIRelationship;
}({});

/**
 * This structure defines the terms for a Programmable IP License (PIL).
 * These terms can be attached to IP Assets.
 *
 * For more information, see {@link https://docs.story.foundation/concepts/programmable-ip-license/pil-terms | PIL}.
 **/

/**
 * @deprecated Use `PILFlavor.nonCommercialSocialRemixing`, `PILFlavor.commercialUse`, `PILFlavor.commercialRemix`, or `PILFlavor.creativeCommonsAttribution` instead.
 *
 * The type of PIL.
 */
var PIL_TYPE = /*#__PURE__*/function (PIL_TYPE) {
  PIL_TYPE[PIL_TYPE["NON_COMMERCIAL_REMIX"] = 0] = "NON_COMMERCIAL_REMIX";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_USE"] = 1] = "COMMERCIAL_USE";
  PIL_TYPE[PIL_TYPE["COMMERCIAL_REMIX"] = 2] = "COMMERCIAL_REMIX";
  PIL_TYPE[PIL_TYPE["CREATIVE_COMMONS_ATTRIBUTION"] = 3] = "CREATIVE_COMMONS_ATTRIBUTION";
  return PIL_TYPE;
}({});

/**
 * Tags refer to the labels that can be applied to IP Assets in the protocol when raising a dispute.
 * Tags must be whitelisted by protocol governance to be used in a dispute.
 * @see {@link https://docs.story.foundation/docs/dispute-module#dispute-tags | Dispute Tags}
 */
var DisputeTargetTag = /*#__PURE__*/function (DisputeTargetTag) {
  /** Refers to registration of IP that already exists. */
  DisputeTargetTag["IMPROPER_REGISTRATION"] = "IMPROPER_REGISTRATION";
  /**
   * Refers to improper use of an IP Asset across multiple items.
   * For more details, @see {@link https://docs.story.foundation/concepts/programmable-ip-license/overview | Programmable IP License (PIL)} documentation.
   */
  DisputeTargetTag["IMPROPER_USAGE"] = "IMPROPER_USAGE";
  /** Refers to missing payments associated with an IP. */
  DisputeTargetTag["IMPROPER_PAYMENT"] = "IMPROPER_PAYMENT";
  /**
   * Refers to No-Hate, Suitable-for-All-Ages, No-Drugs-or-Weapons and No-Pornography.
   * These items can be found in more detail in the {@link https://docs.story.foundation/concepts/programmable-ip-license/overview  |  Programmable IP License (PIL) } legal document.
   */
  DisputeTargetTag["CONTENT_STANDARDS_VIOLATION"] = "CONTENT_STANDARDS_VIOLATION";
  /**
   * Different from the other 4, this is a temporary tag that goes away
   * at the end of a dispute and is replaced by 0x in case of no infringement or is replaced by one of the other tags.
   */
  DisputeTargetTag["IN_DISPUTE"] = "IN_DISPUTE";
  return DisputeTargetTag;
}({});

exports.AIRelationship = AIRelationship;
exports.AccessPermission = AccessPermission;
exports.DisputeClient = DisputeClient;
exports.DisputeTargetTag = DisputeTargetTag;
exports.GroupClient = GroupClient;
exports.IPAccountClient = IPAccountClient;
exports.IPAssetClient = IPAssetClient;
exports.LicenseClient = LicenseClient;
exports.NativeRoyaltyPolicy = NativeRoyaltyPolicy;
exports.NftClient = NftClient;
exports.PILFlavor = PILFlavor;
exports.PIL_TYPE = PIL_TYPE;
exports.PermissionClient = PermissionClient;
exports.RevShareType = RevShareType;
exports.RoyaltyClient = RoyaltyClient;
exports.StoryClient = StoryClient;
exports.StoryRelationship = StoryRelationship;
exports.WIP_TOKEN_ADDRESS = WIP_TOKEN_ADDRESS;
exports.WipClient = WipClient;
exports.aeneid = aeneid;
exports.convertCIDtoHashIPFS = convertCIDtoHashIPFS;
exports.convertHashIPFStoCID = convertHashIPFStoCID;
exports.getPermissionSignature = getPermissionSignature;
exports.getSignature = getSignature;
exports.mainnet = mainnet;
exports.royaltyPolicyLapAddress = royaltyPolicyLapAddress;
exports.royaltyPolicyLrpAddress = royaltyPolicyLrpAddress;
exports.settleAssertion = settleAssertion;
